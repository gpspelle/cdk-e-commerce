/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/aws-sdk/clients/cognitoidentity.js":
/*!*********************************************************!*\
  !*** ./node_modules/aws-sdk/clients/cognitoidentity.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/node_loader */ "./node_modules/aws-sdk/lib/node_loader.js");
var AWS = __webpack_require__(/*! ../lib/core */ "./node_modules/aws-sdk/lib/core.js");
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/cognito-identity-2014-06-30.min.json */ "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/cognito-identity-2014-06-30.paginators.json */ "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json").pagination);
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;


/***/ }),

/***/ "./node_modules/aws-sdk/clients/dynamodb.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/clients/dynamodb.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/node_loader */ "./node_modules/aws-sdk/lib/node_loader.js");
var AWS = __webpack_require__(/*! ../lib/core */ "./node_modules/aws-sdk/lib/core.js");
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['dynamodb'] = {};
AWS.DynamoDB = Service.defineService('dynamodb', ['2011-12-05', '2012-08-10']);
__webpack_require__(/*! ../lib/services/dynamodb */ "./node_modules/aws-sdk/lib/services/dynamodb.js");
Object.defineProperty(apiLoader.services['dynamodb'], '2011-12-05', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/dynamodb-2011-12-05.min.json */ "./node_modules/aws-sdk/apis/dynamodb-2011-12-05.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/dynamodb-2011-12-05.paginators.json */ "./node_modules/aws-sdk/apis/dynamodb-2011-12-05.paginators.json").pagination);
    model.waiters = (__webpack_require__(/*! ../apis/dynamodb-2011-12-05.waiters2.json */ "./node_modules/aws-sdk/apis/dynamodb-2011-12-05.waiters2.json").waiters);
    return model;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(apiLoader.services['dynamodb'], '2012-08-10', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/dynamodb-2012-08-10.min.json */ "./node_modules/aws-sdk/apis/dynamodb-2012-08-10.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/dynamodb-2012-08-10.paginators.json */ "./node_modules/aws-sdk/apis/dynamodb-2012-08-10.paginators.json").pagination);
    model.waiters = (__webpack_require__(/*! ../apis/dynamodb-2012-08-10.waiters2.json */ "./node_modules/aws-sdk/apis/dynamodb-2012-08-10.waiters2.json").waiters);
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.DynamoDB;


/***/ }),

/***/ "./node_modules/aws-sdk/clients/sts.js":
/*!*********************************************!*\
  !*** ./node_modules/aws-sdk/clients/sts.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../lib/node_loader */ "./node_modules/aws-sdk/lib/node_loader.js");
var AWS = __webpack_require__(/*! ../lib/core */ "./node_modules/aws-sdk/lib/core.js");
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
__webpack_require__(/*! ../lib/services/sts */ "./node_modules/aws-sdk/lib/services/sts.js");
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = __webpack_require__(/*! ../apis/sts-2011-06-15.min.json */ "./node_modules/aws-sdk/apis/sts-2011-06-15.min.json");
    model.paginators = (__webpack_require__(/*! ../apis/sts-2011-06-15.paginators.json */ "./node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json").pagination);
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/api_loader.js":
/*!************************************************!*\
  !*** ./node_modules/aws-sdk/lib/api_loader.js ***!
  \************************************************/
/***/ ((module) => {

function apiLoader(svc, version) {
  if (!apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return apiLoader.services[svc][version];
}

/**
 * @api private
 *
 * This member of AWS.apiLoader is private, but changing it will necessitate a
 * change to ../scripts/services-table-generator.ts
 */
apiLoader.services = {};

/**
 * @api private
 */
module.exports = apiLoader;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/config.js":
/*!********************************************!*\
  !*** ./node_modules/aws-sdk/lib/config.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ./credentials */ "./node_modules/aws-sdk/lib/credentials.js");
__webpack_require__(/*! ./credentials/credential_provider_chain */ "./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js");
var PromisesDependency;

/**
 * The main configuration class used by all service objects to set
 * the region, credentials, and other options for requests.
 *
 * By default, credentials and region settings are left unconfigured.
 * This should be configured by the application before using any
 * AWS service APIs.
 *
 * In order to set global configuration options, properties should
 * be assigned to the global {AWS.config} object.
 *
 * @see AWS.config
 *
 * @!group General Configuration Options
 *
 * @!attribute credentials
 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
 *
 * @!attribute region
 *   @example Set the global region setting to us-west-2
 *     AWS.config.update({region: 'us-west-2'});
 *   @return [AWS.Credentials] The region to send service requests to.
 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
 *     A list of available endpoints for each AWS service
 *
 * @!attribute maxRetries
 *   @return [Integer] the maximum amount of retries to perform for a
 *     service request. By default this value is calculated by the specific
 *     service object that the request is being made to.
 *
 * @!attribute maxRedirects
 *   @return [Integer] the maximum amount of redirects to follow for a
 *     service request. Defaults to 10.
 *
 * @!attribute paramValidation
 *   @return [Boolean|map] whether input parameters should be validated against
 *     the operation description before sending the request. Defaults to true.
 *     Pass a map to enable any of the following specific validation features:
 *
 *     * **min** [Boolean] &mdash; Validates that a value meets the min
 *       constraint. This is enabled by default when paramValidation is set
 *       to `true`.
 *     * **max** [Boolean] &mdash; Validates that a value meets the max
 *       constraint.
 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
 *       regular expression.
 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
 *       of the allowable enum values.
 *
 * @!attribute computeChecksums
 *   @return [Boolean] whether to compute checksums for payload bodies when
 *     the service accepts it (currently supported in S3 and SQS only).
 *
 * @!attribute convertResponseTypes
 *   @return [Boolean] whether types are converted when parsing response data.
 *     Currently only supported for JSON based services. Turning this off may
 *     improve performance on large response payloads. Defaults to `true`.
 *
 * @!attribute correctClockSkew
 *   @return [Boolean] whether to apply a clock skew correction and retry
 *     requests that fail because of an skewed client clock. Defaults to
 *     `false`.
 *
 * @!attribute sslEnabled
 *   @return [Boolean] whether SSL is enabled for requests
 *
 * @!attribute s3ForcePathStyle
 *   @return [Boolean] whether to force path style URLs for S3 objects
 *
 * @!attribute s3BucketEndpoint
 *   @note Setting this configuration option requires an `endpoint` to be
 *     provided explicitly to the service constructor.
 *   @return [Boolean] whether the provided endpoint addresses an individual
 *     bucket (false if it addresses the root API endpoint).
 *
 * @!attribute s3DisableBodySigning
 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
 *     Body signing can only be disabled when using https. Defaults to `true`.
 *
 * @!attribute s3UsEast1RegionalEndpoint
 *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
 *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
 *     applicable to S3 client;
 *     Defaults to 'legacy'
 * @!attribute s3UseArnRegion
 *   @return [Boolean] whether to override the request region with the region inferred
 *     from requested resource's ARN. Only available for S3 buckets
 *     Defaults to `true`
 *
 * @!attribute useAccelerateEndpoint
 *   @note This configuration option is only compatible with S3 while accessing
 *     dns-compatible buckets.
 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
 *     Defaults to `false`.
 *
 * @!attribute retryDelayOptions
 *   @example Set the base retry delay for all services to 300 ms
 *     AWS.config.update({retryDelayOptions: {base: 300}});
 *     // Delays with maxRetries = 3: 300, 600, 1200
 *   @example Set a custom backoff function to provide delay values on retries
 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
 *       // returns delay in ms
 *     }}});
 *   @return [map] A set of options to configure the retry delay on retryable errors.
 *     Currently supported options are:
 *
 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
 *       DynamoDB, where it defaults to 50ms.
 *
 *     * **customBackoff ** [function] &mdash; A custom function that accepts a
 *       retry count and error and returns the amount of time to delay in
 *       milliseconds. If the result is a non-zero negative value, no further
 *       retry attempts will be made. The `base` option will be ignored if this
 *       option is supplied. The function is only called for retryable errors.
 *
 * @!attribute httpOptions
 *   @return [map] A set of options to pass to the low-level HTTP request.
 *     Currently supported options are:
 *
 *     * **proxy** [String] &mdash; the URL to proxy requests through
 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
 *       HTTP requests with. Used for connection pooling. Note that for
 *       SSL connections, a special Agent object is used in order to enable
 *       peer certificate verification. This feature is only supported in the
 *       Node.js environment.
 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
 *       failing to establish a connection with the server after
 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
 *       connection has been established.
 *     * **timeout** [Integer] &mdash; The number of milliseconds a request can
 *       take before automatically being terminated.
 *       Defaults to two minutes (120000).
 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
 *       HTTP requests. Used in the browser environment only. Set to false to
 *       send requests synchronously. Defaults to true (async on).
 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
 *       property of an XMLHttpRequest object. Used in the browser environment
 *       only. Defaults to false.
 * @!attribute logger
 *   @return [#write,#log] an object that responds to .write() (like a stream)
 *     or .log() (like the console object) in order to log information about
 *     requests
 *
 * @!attribute systemClockOffset
 *   @return [Number] an offset value in milliseconds to apply to all signing
 *     times. Use this to compensate for clock skew when your system may be
 *     out of sync with the service time. Note that this configuration option
 *     can only be applied to the global `AWS.config` object and cannot be
 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
 *
 * @!attribute signatureVersion
 *   @return [String] the signature version to sign requests with (overriding
 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
 *
 * @!attribute signatureCache
 *   @return [Boolean] whether the signature to sign requests with (overriding
 *     the API configuration) is cached. Only applies to the signature version 'v4'.
 *     Defaults to `true`.
 *
 * @!attribute endpointDiscoveryEnabled
 *   @return [Boolean|undefined] whether to call operations with endpoints
 *     given by service dynamically. Setting this config to `true` will enable
 *     endpoint discovery for all applicable operations. Setting it to `false`
 *     will explicitly disable endpoint discovery even though operations that
 *     require endpoint discovery will presumably fail. Leaving it to
 *     `undefined` means SDK only do endpoint discovery when it's required.
 *     Defaults to `undefined`
 *
 * @!attribute endpointCacheSize
 *   @return [Number] the size of the global cache storing endpoints from endpoint
 *     discovery operations. Once endpoint cache is created, updating this setting
 *     cannot change existing cache size.
 *     Defaults to 1000
 *
 * @!attribute hostPrefixEnabled
 *   @return [Boolean] whether to marshal request parameters to the prefix of
 *     hostname. Defaults to `true`.
 *
 * @!attribute stsRegionalEndpoints
 *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
 *     regional endpoints.
 *     Defaults to 'legacy'.
 *
 * @!attribute useFipsEndpoint
 *   @return [Boolean] Enables FIPS compatible endpoints. Defaults to `false`.
 *
 * @!attribute useDualstackEndpoint
 *   @return [Boolean] Enables IPv6 dualstack endpoint. Defaults to `false`.
 */
AWS.Config = AWS.util.inherit({
  /**
   * @!endgroup
   */

  /**
   * Creates a new configuration object. This is the object that passes
   * option data along to service requests, including credentials, security,
   * region information, and some service specific settings.
   *
   * @example Creating a new configuration object with credentials and region
   *   var config = new AWS.Config({
   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
   *   });
   * @option options accessKeyId [String] your AWS access key ID.
   * @option options secretAccessKey [String] your AWS secret access key.
   * @option options sessionToken [AWS.Credentials] the optional AWS
   *   session token to sign requests with.
   * @option options credentials [AWS.Credentials] the AWS credentials
   *   to sign requests with. You can either specify this object, or
   *   specify the accessKeyId and secretAccessKey options directly.
   * @option options credentialProvider [AWS.CredentialProviderChain] the
   *   provider chain used to resolve credentials if no static `credentials`
   *   property is set.
   * @option options region [String] the region to send service requests to.
   *   See {region} for more information.
   * @option options maxRetries [Integer] the maximum amount of retries to
   *   attempt with a request. See {maxRetries} for more information.
   * @option options maxRedirects [Integer] the maximum amount of redirects to
   *   follow with a request. See {maxRedirects} for more information.
   * @option options sslEnabled [Boolean] whether to enable SSL for
   *   requests.
   * @option options paramValidation [Boolean|map] whether input parameters
   *   should be validated against the operation description before sending
   *   the request. Defaults to true. Pass a map to enable any of the
   *   following specific validation features:
   *
   *   * **min** [Boolean] &mdash; Validates that a value meets the min
   *     constraint. This is enabled by default when paramValidation is set
   *     to `true`.
   *   * **max** [Boolean] &mdash; Validates that a value meets the max
   *     constraint.
   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *     regular expression.
   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
   *     of the allowable enum values.
   * @option options computeChecksums [Boolean] whether to compute checksums
   *   for payload bodies when the service accepts it (currently supported
   *   in S3 only)
   * @option options convertResponseTypes [Boolean] whether types are converted
   *     when parsing response data. Currently only supported for JSON based
   *     services. Turning this off may improve performance on large response
   *     payloads. Defaults to `true`.
   * @option options correctClockSkew [Boolean] whether to apply a clock skew
   *     correction and retry requests that fail because of an skewed client
   *     clock. Defaults to `false`.
   * @option options s3ForcePathStyle [Boolean] whether to force path
   *   style URLs for S3 objects.
   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
   *   addresses an individual bucket (false if it addresses the root API
   *   endpoint). Note that setting this configuration option requires an
   *   `endpoint` to be provided explicitly to the service constructor.
   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
   *   should be disabled when using signature version `v4`. Body signing
   *   can only be disabled when using https. Defaults to `true`.
   * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
   *   is set to 'us-east-1', whether to send s3 request to global endpoints or
   *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
   *   Defaults to `legacy`
   * @option options s3UseArnRegion [Boolean] whether to override the request region
   *   with the region inferred from requested resource's ARN. Only available for S3 buckets
   *   Defaults to `true`
   *
   * @option options retryDelayOptions [map] A set of options to configure
   *   the retry delay on retryable errors. Currently supported options are:
   *
   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
   *     exponential backoff for operation retries. Defaults to 100 ms for all
   *     services except DynamoDB, where it defaults to 50ms.
   *   * **customBackoff ** [function] &mdash; A custom function that accepts a
   *     retry count and error and returns the amount of time to delay in
   *     milliseconds. If the result is a non-zero negative value, no further
   *     retry attempts will be made. The `base` option will be ignored if this
   *     option is supplied. The function is only called for retryable errors.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
   *     milliseconds of inactivity on the socket. Defaults to two minutes
   *     (120000).
   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
   *     HTTP requests. Used in the browser environment only. Set to false to
   *     send requests synchronously. Defaults to true (async on).
   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
   *     property of an XMLHttpRequest object. Used in the browser environment
   *     only. Defaults to false.
   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
   *   (or a date) that represents the latest possible API version that can be
   *   used in all services (unless overridden by `apiVersions`). Specify
   *   'latest' to use the latest possible version.
   * @option options apiVersions [map<String, String|Date>] a map of service
   *   identifiers (the lowercase service class name) with the API version to
   *   use when instantiating a service. Specify 'latest' for each individual
   *   that can use the latest available version.
   * @option options logger [#write,#log] an object that responds to .write()
   *   (like a stream) or .log() (like the console object) in order to log
   *   information about requests
   * @option options systemClockOffset [Number] an offset value in milliseconds
   *   to apply to all signing times. Use this to compensate for clock skew
   *   when your system may be out of sync with the service time. Note that
   *   this configuration option can only be applied to the global `AWS.config`
   *   object and cannot be overridden in service-specific configuration.
   *   Defaults to 0 milliseconds.
   * @option options signatureVersion [String] the signature version to sign
   *   requests with (overriding the API configuration). Possible values are:
   *   'v2', 'v3', 'v4'.
   * @option options signatureCache [Boolean] whether the signature to sign
   *   requests with (overriding the API configuration) is cached. Only applies
   *   to the signature version 'v4'. Defaults to `true`.
   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
   * @option options useAccelerateEndpoint [Boolean] Whether to use the
   *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
   * @option options clientSideMonitoring [Boolean] whether to collect and
   *   publish this client's performance metrics of all its API requests.
   * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
   *   call operations with endpoints given by service dynamically. Setting this
   * config to `true` will enable endpoint discovery for all applicable operations.
   *   Setting it to `false` will explicitly disable endpoint discovery even though
   *   operations that require endpoint discovery will presumably fail. Leaving it
   *   to `undefined` means SDK will only do endpoint discovery when it's required.
   *   Defaults to `undefined`
   * @option options endpointCacheSize [Number] the size of the global cache storing
   *   endpoints from endpoint discovery operations. Once endpoint cache is created,
   *   updating this setting cannot change existing cache size.
   *   Defaults to 1000
   * @option options hostPrefixEnabled [Boolean] whether to marshal request
   *   parameters to the prefix of hostname.
   *   Defaults to `true`.
   * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
   *   to global endpoints or regional endpoints.
   *   Defaults to 'legacy'.
   * @option options useFipsEndpoint [Boolean] Enables FIPS compatible endpoints.
   *   Defaults to `false`.
   * @option options useDualstackEndpoint [Boolean] Enables IPv6 dualstack endpoint.
   *   Defaults to `false`.
   */
  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },

  /**
   * @!group Managing Credentials
   */

  /**
   * Loads credentials from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Credentials} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your credentials are loaded prior to a request, you can use this method
   * directly to provide accurate credential data stored in the object.
   *
   * @note If you configure the SDK with static or environment credentials,
   *   the credential data should already be present in {credentials} attribute.
   *   This method is primarily necessary to load credentials from asynchronous
   *   sources, or sources that can refresh credentials periodically.
   * @example Getting your access key
   *   AWS.config.getCredentials(function(err) {
   *     if (err) console.log(err.stack); // credentials not loaded
   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
   *   })
   * @callback callback function(err)
   *   Called when the {credentials} have been properly set on the configuration
   *   object.
   *
   *   @param err [Error] if this is set, credentials were not successfully
   *     loaded and this error provides information why.
   * @see credentials
   * @see Credentials
   */
  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError',
        message: msg,
        name: 'CredentialsError'
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },

  /**
   * @!group Loading and Setting Configuration Options
   */

  /**
   * @overload update(options, allowUnknownKeys = false)
   *   Updates the current configuration object with new options.
   *
   *   @example Update maxRetries property of a configuration object
   *     config.update({maxRetries: 10});
   *   @param [Object] options a map of option keys and values.
   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
   *     the configuration object. Defaults to `false`.
   *   @see constructor
   */
  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },

  /**
   * Loads configuration data from a JSON file into this config object.
   * @note Loading configuration will reset all existing configuration
   *   on the object.
   * @!macro nobrowser
   * @param path [String] the path relative to your process's current
   *    working directory to load configuration from.
   * @return [AWS.Config] the same configuration object
   */
  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },

  /**
   * Clears configuration data on this object
   *
   * @api private
   */
  clear: function clear() {
    /*jshint forin:false */
    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    // reset credential provider
    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },

  /**
   * Sets a property on the configuration object, allowing for a
   * default value
   * @api private
   */
  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      // deep merge httpOptions
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },

  /**
   * All of the keys with their default values.
   *
   * @constant
   * @api private
   */
  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    s3UsEast1RegionalEndpoint: 'legacy',
    s3UseArnRegion: undefined,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {},
    useAccelerateEndpoint: false,
    clientSideMonitoring: false,
    endpointDiscoveryEnabled: undefined,
    endpointCacheSize: 1000,
    hostPrefixEnabled: true,
    stsRegionalEndpoints: 'legacy',
    useFipsEndpoint: false,
    useDualstackEndpoint: false
  },

  /**
   * Extracts accessKeyId, secretAccessKey and sessionToken
   * from a configuration hash.
   *
   * @api private
   */
  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },

  /**
   * Sets the promise dependency the SDK will use wherever Promises are returned.
   * Passing `null` will force the SDK to use native Promises if they are available.
   * If native Promises are not available, passing `null` will have no effect.
   * @param [Constructor] dep A reference to a Promise constructor
   */
  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    // if null was passed in, we should try to use native promises
    if (dep === null && typeof Promise === 'function') {
      PromisesDependency = Promise;
    }
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3) {
      constructors.push(AWS.S3);
      if (AWS.S3.ManagedUpload) {
        constructors.push(AWS.S3.ManagedUpload);
      }
    }
    AWS.util.addPromises(constructors, PromisesDependency);
  },

  /**
   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
   */
  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});

/**
 * @return [AWS.Config] The global configuration object singleton instance
 * @readonly
 * @see AWS.Config
 */
AWS.config = new AWS.Config();


/***/ }),

/***/ "./node_modules/aws-sdk/lib/config_regional_endpoint.js":
/*!**************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/config_regional_endpoint.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
/**
 * @api private
 */
function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
  if (typeof configValue !== 'string') return undefined;
  else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
    return configValue.toLowerCase();
  } else {
    throw AWS.util.error(new Error(), errorOptions);
  }
}

/**
 * Resolve the configuration value for regional endpoint from difference sources: client
 * config, environmental variable, shared config file. Value can be case-insensitive
 * 'legacy' or 'reginal'.
 * @param originalConfig user-supplied config object to resolve
 * @param options a map of config property names from individual configuration source
 *  - env: name of environmental variable that refers to the config
 *  - sharedConfig: name of shared configuration file property that refers to the config
 *  - clientConfig: name of client configuration property that refers to the config
 *
 * @api private
 */
function resolveRegionalEndpointsFlag(originalConfig, options) {
  originalConfig = originalConfig || {};
  //validate config value
  var resolved;
  if (originalConfig[options.clientConfig]) {
    resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
      code: 'InvalidConfiguration',
      message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy" ' +
      ' or "regional". Got "' + originalConfig[options.clientConfig] + '".'
    });
    if (resolved) return resolved;
  }
  if (!AWS.util.isNode()) return resolved;
  //validate environmental variable
  if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
    var envFlag = process.env[options.env];
    resolved = validateRegionalEndpointsFlagValue(envFlag, {
      code: 'InvalidEnvironmentalVariable',
      message: 'invalid ' + options.env + ' environmental variable. Expect "legacy" ' +
      ' or "regional". Got "' + process.env[options.env] + '".'
    });
    if (resolved) return resolved;
  }
  //validate shared config file
  var profile = {};
  try {
    var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
    profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
  } catch (e) {};
  if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
    var fileFlag = profile[options.sharedConfig];
    resolved = validateRegionalEndpointsFlagValue(fileFlag, {
      code: 'InvalidConfiguration',
      message: 'invalid ' + options.sharedConfig + ' profile config. Expect "legacy" ' +
      ' or "regional". Got "' + profile[options.sharedConfig] + '".'
    });
    if (resolved) return resolved;
  }
  return resolved;
}

module.exports = resolveRegionalEndpointsFlag;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/aws-sdk/lib/core.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * The main AWS namespace
 */
var AWS = { util: __webpack_require__(/*! ./util */ "./node_modules/aws-sdk/lib/util.js") };

/**
 * @api private
 * @!macro [new] nobrowser
 *   @note This feature is not supported in the browser environment of the SDK.
 */
var _hidden = {}; _hidden.toString(); // hack to parse macro

/**
 * @api private
 */
module.exports = AWS;

AWS.util.update(AWS, {

  /**
   * @constant
   */
  VERSION: '2.1058.0',

  /**
   * @api private
   */
  Signers: {},

  /**
   * @api private
   */
  Protocol: {
    Json: __webpack_require__(/*! ./protocol/json */ "./node_modules/aws-sdk/lib/protocol/json.js"),
    Query: __webpack_require__(/*! ./protocol/query */ "./node_modules/aws-sdk/lib/protocol/query.js"),
    Rest: __webpack_require__(/*! ./protocol/rest */ "./node_modules/aws-sdk/lib/protocol/rest.js"),
    RestJson: __webpack_require__(/*! ./protocol/rest_json */ "./node_modules/aws-sdk/lib/protocol/rest_json.js"),
    RestXml: __webpack_require__(/*! ./protocol/rest_xml */ "./node_modules/aws-sdk/lib/protocol/rest_xml.js")
  },

  /**
   * @api private
   */
  XML: {
    Builder: __webpack_require__(/*! ./xml/builder */ "./node_modules/aws-sdk/lib/xml/builder.js"),
    Parser: null // conditionally set based on environment
  },

  /**
   * @api private
   */
  JSON: {
    Builder: __webpack_require__(/*! ./json/builder */ "./node_modules/aws-sdk/lib/json/builder.js"),
    Parser: __webpack_require__(/*! ./json/parser */ "./node_modules/aws-sdk/lib/json/parser.js")
  },

  /**
   * @api private
   */
  Model: {
    Api: __webpack_require__(/*! ./model/api */ "./node_modules/aws-sdk/lib/model/api.js"),
    Operation: __webpack_require__(/*! ./model/operation */ "./node_modules/aws-sdk/lib/model/operation.js"),
    Shape: __webpack_require__(/*! ./model/shape */ "./node_modules/aws-sdk/lib/model/shape.js"),
    Paginator: __webpack_require__(/*! ./model/paginator */ "./node_modules/aws-sdk/lib/model/paginator.js"),
    ResourceWaiter: __webpack_require__(/*! ./model/resource_waiter */ "./node_modules/aws-sdk/lib/model/resource_waiter.js")
  },

  /**
   * @api private
   */
  apiLoader: __webpack_require__(/*! ./api_loader */ "./node_modules/aws-sdk/lib/api_loader.js"),

  /**
   * @api private
   */
  EndpointCache: (__webpack_require__(/*! ../vendor/endpoint-cache */ "./node_modules/aws-sdk/vendor/endpoint-cache/index.js").EndpointCache)
});
__webpack_require__(/*! ./sequential_executor */ "./node_modules/aws-sdk/lib/sequential_executor.js");
__webpack_require__(/*! ./service */ "./node_modules/aws-sdk/lib/service.js");
__webpack_require__(/*! ./config */ "./node_modules/aws-sdk/lib/config.js");
__webpack_require__(/*! ./http */ "./node_modules/aws-sdk/lib/http.js");
__webpack_require__(/*! ./event_listeners */ "./node_modules/aws-sdk/lib/event_listeners.js");
__webpack_require__(/*! ./request */ "./node_modules/aws-sdk/lib/request.js");
__webpack_require__(/*! ./response */ "./node_modules/aws-sdk/lib/response.js");
__webpack_require__(/*! ./resource_waiter */ "./node_modules/aws-sdk/lib/resource_waiter.js");
__webpack_require__(/*! ./signers/request_signer */ "./node_modules/aws-sdk/lib/signers/request_signer.js");
__webpack_require__(/*! ./param_validator */ "./node_modules/aws-sdk/lib/param_validator.js");

/**
 * @readonly
 * @return [AWS.SequentialExecutor] a collection of global event listeners that
 *   are attached to every sent request.
 * @see AWS.Request AWS.Request for a list of events to listen for
 * @example Logging the time taken to send a request
 *   AWS.events.on('send', function startSend(resp) {
 *     resp.startTime = new Date().getTime();
 *   }).on('complete', function calculateTime(resp) {
 *     var time = (new Date().getTime() - resp.startTime) / 1000;
 *     console.log('Request took ' + time + ' seconds');
 *   });
 *
 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
 */
AWS.events = new AWS.SequentialExecutor();

//create endpoint cache lazily
AWS.util.memoizedProperty(AWS, 'endpointCache', function() {
  return new AWS.EndpointCache(AWS.config.endpointCacheSize);
}, true);


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Represents your AWS security credentials, specifically the
 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
 * Creating a `Credentials` object allows you to pass around your
 * security information to configuration and service objects.
 *
 * Note that this class typically does not need to be constructed manually,
 * as the {AWS.Config} and {AWS.Service} classes both accept simple
 * options hashes with the three keys. These structures will be converted
 * into Credentials objects automatically.
 *
 * ## Expiring and Refreshing Credentials
 *
 * Occasionally credentials can expire in the middle of a long-running
 * application. In this case, the SDK will automatically attempt to
 * refresh the credentials from the storage location if the Credentials
 * class implements the {refresh} method.
 *
 * If you are implementing a credential storage location, you
 * will want to create a subclass of the `Credentials` class and
 * override the {refresh} method. This method allows credentials to be
 * retrieved from the backing store, be it a file system, database, or
 * some network storage. The method should reset the credential attributes
 * on the object.
 *
 * @!attribute expired
 *   @return [Boolean] whether the credentials have been expired and
 *     require a refresh. Used in conjunction with {expireTime}.
 * @!attribute expireTime
 *   @return [Date] a time when credentials should be considered expired. Used
 *     in conjunction with {expired}.
 * @!attribute accessKeyId
 *   @return [String] the AWS access key ID
 * @!attribute secretAccessKey
 *   @return [String] the AWS secret access key
 * @!attribute sessionToken
 *   @return [String] an optional AWS session token
 */
AWS.Credentials = AWS.util.inherit({
  /**
   * A credentials object can be created using positional arguments or an options
   * hash.
   *
   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
   *   Creates a Credentials object with a given set of credential information
   *   as positional arguments.
   *   @param accessKeyId [String] the AWS access key ID
   *   @param secretAccessKey [String] the AWS secret access key
   *   @param sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
   * @overload AWS.Credentials(options)
   *   Creates a Credentials object with a given set of credential information
   *   as an options hash.
   *   @option options accessKeyId [String] the AWS access key ID
   *   @option options secretAccessKey [String] the AWS secret access key
   *   @option options sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials({
   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
   *     });
   */
  constructor: function Credentials() {
    // hide secretAccessKey from being displayed with util.inspect
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    this.refreshCallbacks = [];
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },

  /**
   * @return [Integer] the number of seconds before {expireTime} during which
   *   the credentials will be considered expired.
   */
  expiryWindow: 15,

  /**
   * @return [Boolean] whether the credentials object should call {refresh}
   * @note Subclasses should override this method to provide custom refresh
   *   logic.
   */
  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },

  /**
   * Gets the existing credentials, refreshing them if they are not yet loaded
   * or have expired. Users should call this method before using {refresh},
   * as this will not attempt to reload credentials when they are already
   * loaded into the object.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means either credentials
   *   do not need to be refreshed or refreshed credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   */
  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },

  /**
   * @!method  getPromise()
   *   Returns a 'thenable' promise.
   *   Gets the existing credentials, refreshing them if they are not yet loaded
   *   or have expired. Users should call this method before using {refresh},
   *   as this will not attempt to reload credentials when they are already
   *   loaded into the object.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means either credentials do not need to be refreshed or refreshed
   *     credentials information has been loaded into the object (as the
   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `get` call.
   *   @example Calling the `getPromise` method.
   *     var promise = credProvider.getPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * @!method  refreshPromise()
   *   Returns a 'thenable' promise.
   *   Refreshes the credentials. Users should call {get} before attempting
   *   to forcibly refresh credentials.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means refreshed credentials information has been loaded into the object
   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Calling the `refreshPromise` method.
   *     var promise = credProvider.refreshPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * Refreshes the credentials. Users should call {get} before attempting
   * to forcibly refresh credentials.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means refreshed
   *   credentials information has been loaded into the object (as the
   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @note Subclasses should override this class to reset the
   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
   *   on the credentials object and then call the callback with
   *   any error information.
   * @see get
   */
  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  },

  /**
   * @api private
   * @param callback
   */
  coalesceRefresh: function coalesceRefresh(callback, sync) {
    var self = this;
    if (self.refreshCallbacks.push(callback) === 1) {
      self.load(function onLoad(err) {
        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {
          if (sync) {
            callback(err);
          } else {
            // callback could throw, so defer to ensure all callbacks are notified
            AWS.util.defer(function () {
              callback(err);
            });
          }
        });
        self.refreshCallbacks.length = 0;
      });
    }
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    callback();
  }
});

/**
 * @api private
 */
AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};

/**
 * @api private
 */
AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in
 * the way masterCredentials and refreshes are handled.
 * AWS.ChainableTemporaryCredentials refreshes expired credentials using the
 * masterCredentials passed by the user to support chaining of STS credentials.
 * However, AWS.TemporaryCredentials recursively collapses the masterCredentials
 * during instantiation, precluding the ability to refresh credentials which
 * require intermediate, temporary credentials.
 *
 * For example, if the application should use RoleA, which must be assumed from
 * RoleB, and the environment provides credentials which can assume RoleB, then
 * AWS.ChainableTemporaryCredentials must be used to support refreshing the
 * temporary credentials for RoleA:
 *
 * ```javascript
 * var roleACreds = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: 'RoleA'},
 *   masterCredentials: new AWS.ChainableTemporaryCredentials({
 *     params: {RoleArn: 'RoleB'},
 *     masterCredentials: new AWS.EnvironmentCredentials('AWS')
 *   })
 * });
 * ```
 *
 * If AWS.TemporaryCredentials had been used in the previous example,
 * `roleACreds` would fail to refresh because `roleACreds` would
 * use the environment credentials for the AssumeRole request.
 *
 * Another difference is that AWS.ChainableTemporaryCredentials creates the STS
 * service instance during instantiation while AWS.TemporaryCredentials creates
 * the STS service instance during the first refresh. Creating the service
 * instance during instantiation effectively captures the master credentials
 * from the global config, so that subsequent changes to the global config do
 * not affect the master credentials used to refresh the temporary credentials.
 *
 * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned
 * to AWS.config.credentials:
 *
 * ```javascript
 * var envCreds = new AWS.EnvironmentCredentials('AWS');
 * AWS.config.credentials = envCreds;
 * // masterCredentials will be envCreds
 * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * Similarly, to use the CredentialProviderChain's default providers as the
 * master credentials, simply create a new instance of
 * AWS.ChainableTemporaryCredentials:
 *
 * ```javascript
 * AWS.config.credentials = new ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * @!attribute service
 *   @return [AWS.STS] the STS service instance used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @param options [map] a set of options
   * @option options params [map] ({}) a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
   *   also be passed in or an error will be thrown.
   * @option options masterCredentials [AWS.Credentials] the master credentials
   *   used to get and refresh temporary credentials from AWS STS. By default,
   *   AWS.config.credentials or AWS.config.credentialProvider will be used.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
   *   is called with value of `SerialNumber` and `callback`, and should provide
   *   the `TokenCode` or an error to the callback in the format
   *   `callback(err, token)`.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
   *     params: {
   *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
   *     }
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function ChainableTemporaryCredentials(options) {
    AWS.Credentials.call(this);
    options = options || {};
    this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
    this.expired = true;
    this.tokenCodeFn = null;

    var params = AWS.util.copy(options.params) || {};
    if (params.RoleArn) {
      params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
    }
    if (params.SerialNumber) {
      if (!options.tokenCodeFn || (typeof options.tokenCodeFn !== 'function')) {
        throw new AWS.util.error(
          new Error('tokenCodeFn must be a function when params.SerialNumber is given'),
          {code: this.errorCode}
        );
      } else {
        this.tokenCodeFn = options.tokenCodeFn;
      }
    }
    var config = AWS.util.merge(
      {
        params: params,
        credentials: options.masterCredentials || AWS.config.credentials
      },
      options.stsConfig || {}
    );
    this.service = new STS(config);
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
    this.getTokenCode(function (err, tokenCode) {
      var params = {};
      if (err) {
        callback(err);
        return;
      }
      if (tokenCode) {
        params.TokenCode = tokenCode;
      }
      self.service[operation](params, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  getTokenCode: function getTokenCode(callback) {
    var self = this;
    if (this.tokenCodeFn) {
      this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
        if (err) {
          var message = err;
          if (err instanceof Error) {
            message = err.message;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: self.errorCode}
            )
          );
          return;
        }
        callback(null, token);
      });
    } else {
      callback(null);
    }
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js":
/*!******************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var CognitoIdentity = __webpack_require__(/*! ../../clients/cognitoidentity */ "./node_modules/aws-sdk/clients/cognitoidentity.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");

/**
 * Represents credentials retrieved from STS Web Identity Federation using
 * the Amazon Cognito Identity service.
 *
 * By default this provider gets credentials using the
 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
 * obtain an `IdentityId`. If the identity or identity pool is not configured in
 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
 * is provided, then this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
 *
 * In addition, if this credential provider is used to provide authenticated
 * login, the `Logins` map may be set to the tokens provided by the respective
 * identity providers. See {constructor} for an example on creating a credentials
 * object with proper property values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.CognitoIdentity.getId},
 *     {AWS.CognitoIdentity.getOpenIdToken}, and
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 * @!attribute identityId
 *   @return [String] the Cognito ID returned by the last call to
 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
 *     final resolved identity ID from Amazon Cognito.
 */
AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * @api private
   */
  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },

  /**
   * Creates a new credentials object.
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
   *
   *     // either IdentityPoolId or IdentityId is required
   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
   *
   *     // optional, only necessary when the identity pool is not configured
   *     // to use IAM roles in the Amazon Cognito Console
   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
   *
   *     // optional tokens, used for authenticated login
   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
   *     Logins: {
   *       'graph.facebook.com': 'FBTOKEN',
   *       'www.amazon.com': 'AMAZONTOKEN',
   *       'accounts.google.com': 'GOOGLETOKEN',
   *       'api.twitter.com': 'TWITTERTOKEN',
   *       'www.digits.com': 'DIGITSTOKEN'
   *     },
   *
   *     // optional name, defaults to web-identity
   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleSessionName: 'web',
   *
   *     // optional, only necessary when application runs in a browser
   *     // and multiple users are signed in at once, used for caching
   *     LoginId: 'example@gmail.com'
   *
   *   }, {
   *      // optionally provide configuration to apply to the underlying service clients
   *      // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *      // region should match the region your identity pool is located in
   *      region: 'us-east-1',
   *
   *      // specify timeout options
   *      httpOptions: {
   *        timeout: 100
   *      }
   *   });
   * @see AWS.CognitoIdentity.getId
   * @see AWS.CognitoIdentity.getCredentialsForIdentity
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.CognitoIdentity.getOpenIdToken
   * @see AWS.Config
   * @note If a region is not provided in the global AWS.config, or
   *   specified in the `clientConfig` to the CognitoIdentityCredentials
   *   constructor, you may encounter a 'Missing credentials in config' error
   *   when calling making a service call.
   */
  constructor: function CognitoIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this._identityId = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
    this.loadCachedId();
    var self = this;
    Object.defineProperty(this, 'identityId', {
      get: function() {
        self.loadCachedId();
        return self._identityId || self.params.IdentityId;
      },
      set: function(identityId) {
        self._identityId = identityId;
      }
    });
  },

  /**
   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
   * or {AWS.STS.assumeRoleWithWebIdentity}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self._identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * Clears the cached Cognito ID associated with the currently configured
   * identity pool ID. Use this to manually invalidate your cache if
   * the identity pool ID was deleted.
   */
  clearCachedId: function clearCache() {
    this._identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },

  /**
   * @api private
   */
  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },

  /**
   * Retrieves a Cognito ID, loading from cache if it was already retrieved
   * on this device.
   *
   * @callback callback function(err, identityId)
   *   @param err [Error, null] an error object if the call failed or null if
   *     it succeeded.
   *   @param identityId [String, null] if successful, the callback will return
   *     the Cognito ID.
   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
   *   localStorage in the browser environment of a device.
   * @api private
   */
  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },


  /**
   * @api private
   */
  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },

  /**
   * @api private
   */
  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * @api private
   */
  loadCachedId: function loadCachedId() {
    var self = this;

    // in the browser we source default IdentityId from localStorage
    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        // only load ID if at least one provider used this ID before
        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    var clientConfig = this._clientConfig;
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params, clientConfig);
    if (!this.cognito) {
      var cognitoConfig = AWS.util.merge({}, clientConfig);
      cognitoConfig.params = this.params;
      this.cognito = new CognitoIdentity(cognitoConfig);
    }
    this.sts = this.sts || new STS(clientConfig);
  },

  /**
   * @api private
   */
  cacheId: function cacheId(data) {
    this._identityId = data.IdentityId;
    this.params.IdentityId = this._identityId;

    // cache this IdentityId in browser localStorage if possible
    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },

  /**
   * @api private
   */
  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },

  /**
   * @api private
   */
  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },

  /**
   * @api private
   */
  storage: (function() {
    try {
      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
          window.localStorage : {};

      // Test set/remove which would throw an error in Safari's private browsing
      storage['aws.test-storage'] = 'foobar';
      delete storage['aws.test-storage'];

      return storage;
    } catch (_) {
      return {};
    }
  })()
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js":
/*!***************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Creates a credential provider chain that searches for AWS credentials
 * in a list of credential providers specified by the {providers} property.
 *
 * By default, the chain will use the {defaultProviders} to resolve credentials.
 * These providers will look in the environment using the
 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
 *
 * ## Setting Providers
 *
 * Each provider in the {providers} list should be a function that returns
 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
 * form allows for delayed execution of the credential construction.
 *
 * ## Resolving Credentials from a Chain
 *
 * Call {resolve} to return the first valid credential object that can be
 * loaded by the provider chain.
 *
 * For example, to resolve a chain with a custom provider that checks a file
 * on disk after the set of {defaultProviders}:
 *
 * ```javascript
 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
 * var chain = new AWS.CredentialProviderChain();
 * chain.providers.push(diskProvider);
 * chain.resolve();
 * ```
 *
 * The above code will return the `diskProvider` object if the
 * file contains credentials and the `defaultProviders` do not contain
 * any credential settings.
 *
 * @!attribute providers
 *   @return [Array<AWS.Credentials, Function>]
 *     a list of credentials objects or functions that return credentials
 *     objects. If the provider is a function, the function will be
 *     executed lazily when the provider needs to be checked for valid
 *     credentials. By default, this object will be set to the
 *     {defaultProviders}.
 *   @see defaultProviders
 */
AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new CredentialProviderChain with a default set of providers
   * specified by {defaultProviders}.
   */
  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
    this.resolveCallbacks = [];
  },

  /**
   * @!method  resolvePromise()
   *   Returns a 'thenable' promise.
   *   Resolves the provider chain by searching for the first set of
   *   credentials in {providers}.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(credentials)
   *     Called if the promise is fulfilled and the provider resolves the chain
   *     to a credentials object
   *     @param credentials [AWS.Credentials] the credentials object resolved
   *       by the provider chain.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param err [Error] the error object returned if no credentials are found.
   *   @return [Promise] A promise that represents the state of the `resolve` method call.
   *   @example Calling the `resolvePromise` method.
   *     var promise = chain.resolvePromise();
   *     promise.then(function(credentials) { ... }, function(err) { ... });
   */

  /**
   * Resolves the provider chain by searching for the first set of
   * credentials in {providers}.
   *
   * @callback callback function(err, credentials)
   *   Called when the provider resolves the chain to a credentials object
   *   or null if no credentials can be found.
   *
   *   @param err [Error] the error object returned if no credentials are
   *     found.
   *   @param credentials [AWS.Credentials] the credentials object resolved
   *     by the provider chain.
   * @return [AWS.CredentialProviderChain] the provider, for chaining.
   */
  resolve: function resolve(callback) {
    var self = this;
    if (self.providers.length === 0) {
      callback(new Error('No providers'));
      return self;
    }

    if (self.resolveCallbacks.push(callback) === 1) {
      var index = 0;
      var providers = self.providers.slice(0);

      function resolveNext(err, creds) {
        if ((!err && creds) || index === providers.length) {
          AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
            callback(err, creds);
          });
          self.resolveCallbacks.length = 0;
          return;
        }

        var provider = providers[index++];
        if (typeof provider === 'function') {
          creds = provider.call();
        } else {
          creds = provider;
        }

        if (creds.get) {
          creds.get(function (getErr) {
            resolveNext(getErr, getErr ? null : creds);
          });
        } else {
          resolveNext(null, creds);
        }
      }

      resolveNext();
    }

    return self;
  }
});

/**
 * The default set of providers used by a vanilla CredentialProviderChain.
 *
 * In the browser:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = []
 * ```
 *
 * In Node.js:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = [
 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
 *   function () { return new AWS.SharedIniFileCredentials(); },
 *   function () { return new AWS.ECSCredentials(); },
 *   function () { return new AWS.ProcessCredentials(); },
 *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
 *   function () { return new AWS.EC2MetadataCredentials() }
 * ]
 * ```
 */
AWS.CredentialProviderChain.defaultProviders = [];

/**
 * @api private
 */
AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};

/**
 * @api private
 */
AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js":
/*!**************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ../metadata_service */ "./node_modules/aws-sdk/lib/metadata_service.js");

/**
 * Represents credentials received from the metadata service on an EC2 instance.
 *
 * By default, this class will connect to the metadata service using
 * {AWS.MetadataService} and attempt to load any available credentials. If it
 * can connect, and credentials are available, these will be used with zero
 * configuration.
 *
 * This credentials class will by default timeout after 1 second of inactivity
 * and retry 3 times.
 * If your requests to the EC2 metadata service are timing out, you can increase
 * these values by configuring them directly:
 *
 * ```javascript
 * AWS.config.credentials = new AWS.EC2MetadataCredentials({
 *   httpOptions: { timeout: 5000 }, // 5 second timeout
 *   maxRetries: 10, // retry 10 times
 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
 * });
 *
 * If your requests are timing out in connecting to the metadata service, such
 * as when testing on a development machine, you can use the connectTimeout
 * option, specified in milliseconds, which also defaults to 1 second.
 * ```
 *
 * @see AWS.Config.retryDelayOptions
 *
 * @!macro nobrowser
 */
AWS.EC2MetadataCredentials = AWS.util.inherit(AWS.Credentials, {
  constructor: function EC2MetadataCredentials(options) {
    AWS.Credentials.call(this);

    options = options ? AWS.util.copy(options) : {};
    options = AWS.util.merge(
      {maxRetries: this.defaultMaxRetries}, options);
    if (!options.httpOptions) options.httpOptions = {};
    options.httpOptions = AWS.util.merge(
      {timeout: this.defaultTimeout,
        connectTimeout: this.defaultConnectTimeout},
       options.httpOptions);

    this.metadataService = new AWS.MetadataService(options);
    this.metadata = {};
  },

  /**
   * @api private
   */
  defaultTimeout: 1000,

   /**
   * @api private
   */
  defaultConnectTimeout: 1000,

  /**
   * @api private
   */
  defaultMaxRetries: 3,

  /**
   * Loads the credentials from the instance metadata service
   *
   * @callback callback function(err)
   *   Called when the instance metadata service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.metadataService.loadCredentials(function(err, creds) {
      if (!err) {
        var currentTime = AWS.util.date.getDate();
        var expireTime = new Date(creds.Expiration);
        if (expireTime < currentTime) {
          err = AWS.util.error(
            new Error('EC2 Instance Metadata Serivce provided expired credentials'),
            { code: 'EC2MetadataCredentialsProviderFailure' }
          );
        } else {
          self.expired = false;
          self.metadata = creds;
          self.accessKeyId = creds.AccessKeyId;
          self.secretAccessKey = creds.SecretAccessKey;
          self.sessionToken = creds.Token;
          self.expireTime = expireTime;
        }
      }
      callback(err);
    });
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/ecs_credentials.js":
/*!*****************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/ecs_credentials.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Represents credentials received from relative URI specified in the ECS container.
 *
 * This class will request refreshable credentials from the relative URI
 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or the
 * AWS_CONTAINER_CREDENTIALS_FULL_URI environment variable. If valid credentials
 * are returned in the response, these will be used with zero configuration.
 *
 * This credentials class will by default timeout after 1 second of inactivity
 * and retry 3 times.
 * If your requests to the relative URI are timing out, you can increase
 * the value by configuring them directly:
 *
 * ```javascript
 * AWS.config.credentials = new AWS.ECSCredentials({
 *   httpOptions: { timeout: 5000 }, // 5 second timeout
 *   maxRetries: 10, // retry 10 times
 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
 * });
 * ```
 *
 * @see AWS.Config.retryDelayOptions
 *
 * @!macro nobrowser
 */
AWS.ECSCredentials = AWS.RemoteCredentials;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/environment_credentials.js":
/*!*************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/environment_credentials.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Represents credentials from the environment.
 *
 * By default, this class will look for the matching environment variables
 * prefixed by a given {envPrefix}. The un-prefixed environment variable names
 * for each credential value is listed below:
 *
 * ```javascript
 * accessKeyId: ACCESS_KEY_ID
 * secretAccessKey: SECRET_ACCESS_KEY
 * sessionToken: SESSION_TOKEN
 * ```
 *
 * With the default prefix of 'AWS', the environment variables would be:
 *
 *     AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
 *
 * @!attribute envPrefix
 *   @readonly
 *   @return [String] the prefix for the environment variable names excluding
 *     the separating underscore ('_').
 */
AWS.EnvironmentCredentials = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new EnvironmentCredentials class with a given variable
   * prefix {envPrefix}. For example, to load credentials using the 'AWS'
   * prefix:
   *
   * ```javascript
   * var creds = new AWS.EnvironmentCredentials('AWS');
   * creds.accessKeyId == 'AKID' // from AWS_ACCESS_KEY_ID env var
   * ```
   *
   * @param envPrefix [String] the prefix to use (e.g., 'AWS') for environment
   *   variables. Do not include the separating underscore.
   */
  constructor: function EnvironmentCredentials(envPrefix) {
    AWS.Credentials.call(this);
    this.envPrefix = envPrefix;
    this.get(function() {});
  },

  /**
   * Loads credentials from the environment using the prefixed
   * environment variables.
   *
   * @callback callback function(err)
   *   Called after the (prefixed) ACCESS_KEY_ID, SECRET_ACCESS_KEY, and
   *   SESSION_TOKEN environment variables are read. When this callback is
   *   called with no error, it means that the credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    if (!callback) callback = AWS.util.fn.callback;

    if (!process || !process.env) {
      callback(AWS.util.error(
        new Error('No process info or environment variables available'),
        { code: 'EnvironmentCredentialsProviderFailure' }
      ));
      return;
    }

    var keys = ['ACCESS_KEY_ID', 'SECRET_ACCESS_KEY', 'SESSION_TOKEN'];
    var values = [];

    for (var i = 0; i < keys.length; i++) {
      var prefix = '';
      if (this.envPrefix) prefix = this.envPrefix + '_';
      values[i] = process.env[prefix + keys[i]];
      if (!values[i] && keys[i] !== 'SESSION_TOKEN') {
        callback(AWS.util.error(
          new Error('Variable ' + prefix + keys[i] + ' not set.'),
        { code: 'EnvironmentCredentialsProviderFailure' }
        ));
        return;
      }
    }

    this.expired = false;
    AWS.Credentials.apply(this, values);
    callback();
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/file_system_credentials.js":
/*!*************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/file_system_credentials.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Represents credentials from a JSON file on disk.
 * If the credentials expire, the SDK can {refresh} the credentials
 * from the file.
 *
 * The format of the file should be similar to the options passed to
 * {AWS.Config}:
 *
 * ```javascript
 * {accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'optional'}
 * ```
 *
 * @example Loading credentials from disk
 *   var creds = new AWS.FileSystemCredentials('./configuration.json');
 *   creds.accessKeyId == 'AKID'
 *
 * @!attribute filename
 *   @readonly
 *   @return [String] the path to the JSON file on disk containing the
 *     credentials.
 * @!macro nobrowser
 */
AWS.FileSystemCredentials = AWS.util.inherit(AWS.Credentials, {

  /**
   * @overload AWS.FileSystemCredentials(filename)
   *   Creates a new FileSystemCredentials object from a filename
   *
   *   @param filename [String] the path on disk to the JSON file to load.
   */
  constructor: function FileSystemCredentials(filename) {
    AWS.Credentials.call(this);
    this.filename = filename;
    this.get(function() {});
  },

  /**
   * Loads the credentials from the {filename} on disk.
   *
   * @callback callback function(err)
   *   Called after the JSON file on disk is read and parsed. When this callback
   *   is called with no error, it means that the credentials information
   *   has been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    if (!callback) callback = AWS.util.fn.callback;
    try {
      var creds = JSON.parse(AWS.util.readFileSync(this.filename));
      AWS.Credentials.call(this, creds);
      if (!this.accessKeyId || !this.secretAccessKey) {
        throw AWS.util.error(
          new Error('Credentials not set in ' + this.filename),
        { code: 'FileSystemCredentialsProviderFailure' }
        );
      }
      this.expired = false;
      callback();
    } catch (err) {
      callback(err);
    }
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/process_credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/process_credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var proc = __webpack_require__(/*! child_process */ "child_process");
var iniLoader = AWS.util.iniLoader;

/**
 * Represents credentials loaded from shared credentials file
 * (defaulting to ~/.aws/credentials or defined by the
 * `AWS_SHARED_CREDENTIALS_FILE` environment variable).
 *
 * ## Using process credentials
 *
 * The credentials file can specify a credential provider that executes
 * a given process and attempts to read its stdout to recieve a JSON payload
 * containing the credentials:
 *
 *     [default]
 *     credential_process = /usr/bin/credential_proc
 *
 * Automatically handles refreshing credentials if an Expiration time is
 * provided in the credentials payload. Credentials supplied in the same profile
 * will take precedence over the credential_process.
 *
 * Sourcing credentials from an external process can potentially be dangerous,
 * so proceed with caution. Other credential providers should be preferred if
 * at all possible. If using this option, you should make sure that the shared
 * credentials file is as locked down as possible using security best practices
 * for your operating system.
 *
 * ## Using custom profiles
 *
 * The SDK supports loading credentials for separate profiles. This can be done
 * in two ways:
 *
 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
 *    loading the SDK.
 * 2. Directly load the AWS.ProcessCredentials provider:
 *
 * ```javascript
 * var creds = new AWS.ProcessCredentials({profile: 'myprofile'});
 * AWS.config.credentials = creds;
 * ```
 *
 * @!macro nobrowser
 */
AWS.ProcessCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new ProcessCredentials object.
   *
   * @param options [map] a set of options
   * @option options profile [String] (AWS_PROFILE env var or 'default')
   *   the name of the profile to load.
   * @option options filename [String] ('~/.aws/credentials' or defined by
   *   AWS_SHARED_CREDENTIALS_FILE process env var)
   *   the filename to use when loading credentials.
   * @option options callback [Function] (err) Credentials are eagerly loaded
   *   by the constructor. When the callback is called with no error, the
   *   credentials have been loaded successfully.
   */
  constructor: function ProcessCredentials(options) {
    AWS.Credentials.call(this);

    options = options || {};

    this.filename = options.filename;
    this.profile = options.profile || process.env.AWS_PROFILE || AWS.util.defaultProfile;
    this.get(options.callback || AWS.util.fn.noop);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    try {
      var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader, this.filename);
      var profile = profiles[this.profile] || {};

      if (Object.keys(profile).length === 0) {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' not found'),
          { code: 'ProcessCredentialsProviderFailure' }
        );
      }

      if (profile['credential_process']) {
        this.loadViaCredentialProcess(profile, function(err, data) {
          if (err) {
            callback(err, null);
          } else {
            self.expired = false;
            self.accessKeyId = data.AccessKeyId;
            self.secretAccessKey = data.SecretAccessKey;
            self.sessionToken = data.SessionToken;
            if (data.Expiration) {
              self.expireTime = new Date(data.Expiration);
            }
            callback(null);
          }
        });
      } else {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' did not include credential process'),
          { code: 'ProcessCredentialsProviderFailure' }
        );
      }
    } catch (err) {
      callback(err);
    }
  },

  /**
  * Executes the credential_process and retrieves
  * credentials from the output
  * @api private
  * @param profile [map] credentials profile
  * @throws ProcessCredentialsProviderFailure
  */
  loadViaCredentialProcess: function loadViaCredentialProcess(profile, callback) {
    proc.exec(profile['credential_process'], { env: process.env }, function(err, stdOut, stdErr) {
      if (err) {
        callback(AWS.util.error(
          new Error('credential_process returned error'),
          { code: 'ProcessCredentialsProviderFailure'}
        ), null);
      } else {
        try {
          var credData = JSON.parse(stdOut);
          if (credData.Expiration) {
            var currentTime = AWS.util.date.getDate();
            var expireTime = new Date(credData.Expiration);
            if (expireTime < currentTime) {
              throw Error('credential_process returned expired credentials');
            }
          }

          if (credData.Version !== 1) {
            throw Error('credential_process does not return Version == 1');
          }
          callback(null, credData);
        } catch (err) {
          callback(AWS.util.error(
            new Error(err.message),
            { code: 'ProcessCredentialsProviderFailure'}
          ), null);
        }
      }
    });
  },

  /**
   * Loads the credentials from the credential process
   *
   * @callback callback function(err)
   *   Called after the credential process has been executed. When this
   *   callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    iniLoader.clearCachedFiles();
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/remote_credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/remote_credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js"),
  ENV_RELATIVE_URI = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',
  ENV_FULL_URI = 'AWS_CONTAINER_CREDENTIALS_FULL_URI',
  ENV_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN',
  FULL_URI_UNRESTRICTED_PROTOCOLS = ['https:'],
  FULL_URI_ALLOWED_PROTOCOLS = ['http:', 'https:'],
  FULL_URI_ALLOWED_HOSTNAMES = ['localhost', '127.0.0.1'],
  RELATIVE_URI_HOST = '169.254.170.2';

/**
 * Represents credentials received from specified URI.
 *
 * This class will request refreshable credentials from the relative URI
 * specified by the AWS_CONTAINER_CREDENTIALS_RELATIVE_URI or the
 * AWS_CONTAINER_CREDENTIALS_FULL_URI environment variable. If valid credentials
 * are returned in the response, these will be used with zero configuration.
 *
 * This credentials class will by default timeout after 1 second of inactivity
 * and retry 3 times.
 * If your requests to the relative URI are timing out, you can increase
 * the value by configuring them directly:
 *
 * ```javascript
 * AWS.config.credentials = new AWS.RemoteCredentials({
 *   httpOptions: { timeout: 5000 }, // 5 second timeout
 *   maxRetries: 10, // retry 10 times
 *   retryDelayOptions: { base: 200 } // see AWS.Config for information
 * });
 * ```
 *
 * @see AWS.Config.retryDelayOptions
 *
 * @!macro nobrowser
 */
AWS.RemoteCredentials = AWS.util.inherit(AWS.Credentials, {
  constructor: function RemoteCredentials(options) {
    AWS.Credentials.call(this);
    options = options ? AWS.util.copy(options) : {};
    if (!options.httpOptions) options.httpOptions = {};
    options.httpOptions = AWS.util.merge(
      this.httpOptions, options.httpOptions);
    AWS.util.update(this, options);
  },

  /**
   * @api private
   */
  httpOptions: { timeout: 1000 },

  /**
   * @api private
   */
  maxRetries: 3,

  /**
   * @api private
   */
  isConfiguredForEcsCredentials: function isConfiguredForEcsCredentials() {
    return Boolean(
        process &&
        process.env &&
        (process.env[ENV_RELATIVE_URI] || process.env[ENV_FULL_URI])
    );
  },

  /**
   * @api private
   */
  getECSFullUri: function getECSFullUri() {
    if (process && process.env) {
      var relative = process.env[ENV_RELATIVE_URI],
          full = process.env[ENV_FULL_URI];
      if (relative) {
        return 'http://' + RELATIVE_URI_HOST + relative;
      } else if (full) {
        var parsed = AWS.util.urlParse(full);
        if (FULL_URI_ALLOWED_PROTOCOLS.indexOf(parsed.protocol) < 0) {
          throw AWS.util.error(
            new Error('Unsupported protocol:  AWS.RemoteCredentials supports '
              + FULL_URI_ALLOWED_PROTOCOLS.join(',') + ' only; '
              + parsed.protocol + ' requested.'),
            { code: 'ECSCredentialsProviderFailure' }
          );
        }

        if (FULL_URI_UNRESTRICTED_PROTOCOLS.indexOf(parsed.protocol) < 0 &&
            FULL_URI_ALLOWED_HOSTNAMES.indexOf(parsed.hostname) < 0) {
          throw AWS.util.error(
            new Error('Unsupported hostname: AWS.RemoteCredentials only supports '
              + FULL_URI_ALLOWED_HOSTNAMES.join(',') + ' for ' + parsed.protocol + '; '
              + parsed.protocol + '//' + parsed.hostname + ' requested.'),
            { code: 'ECSCredentialsProviderFailure' }
          );
        }

        return full;
      } else {
        throw AWS.util.error(
          new Error('Variable ' + ENV_RELATIVE_URI + ' or ' + ENV_FULL_URI +
            ' must be set to use AWS.RemoteCredentials.'),
          { code: 'ECSCredentialsProviderFailure' }
        );
      }
    } else {
      throw AWS.util.error(
        new Error('No process info available'),
        { code: 'ECSCredentialsProviderFailure' }
      );
    }
  },

  /**
   * @api private
   */
  getECSAuthToken: function getECSAuthToken() {
    if (process && process.env && process.env[ENV_FULL_URI]) {
      return process.env[ENV_AUTH_TOKEN];
    }
  },

  /**
   * @api private
   */
  credsFormatIsValid: function credsFormatIsValid(credData) {
    return (!!credData.accessKeyId && !!credData.secretAccessKey &&
      !!credData.sessionToken && !!credData.expireTime);
  },

  /**
   * @api private
   */
  formatCreds: function formatCreds(credData) {
    if (!!credData.credentials) {
      credData = credData.credentials;
    }

    return {
      expired: false,
      accessKeyId: credData.accessKeyId || credData.AccessKeyId,
      secretAccessKey: credData.secretAccessKey || credData.SecretAccessKey,
      sessionToken: credData.sessionToken || credData.Token,
      expireTime: new Date(credData.expiration || credData.Expiration)
    };
  },

  /**
   * @api private
   */
  request: function request(url, callback) {
    var httpRequest = new AWS.HttpRequest(url);
    httpRequest.method = 'GET';
    httpRequest.headers.Accept = 'application/json';
    var token = this.getECSAuthToken();
    if (token) {
      httpRequest.headers.Authorization = token;
    }
    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
  },

  /**
   * Loads the credentials from the relative URI specified by container
   *
   * @callback callback function(err)
   *   Called when the request to the relative URI responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, `sessionToken`, and `expireTime` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    var fullUri;

    try {
      fullUri = this.getECSFullUri();
    } catch (err) {
      callback(err);
      return;
    }

    this.request(fullUri, function(err, data) {
      if (!err) {
        try {
          data = JSON.parse(data);
          var creds = self.formatCreds(data);
          if (!self.credsFormatIsValid(creds)) {
            throw AWS.util.error(
              new Error('Response data is not in valid format'),
              { code: 'ECSCredentialsProviderFailure' }
            );
          }
          AWS.util.update(self, creds);
        } catch (dataError) {
          err = dataError;
        }
      }
      callback(err, creds);
    });
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/saml_credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/saml_credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");

/**
 * Represents credentials retrieved from STS SAML support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given, as well as a `PrincipalArn`
 * representing the ARN for the SAML identity provider. In addition, the
 * `SAMLAssertion` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the SAMLAssertion, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
 *     `params.SAMLAssertion` property.
 */
AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithSAML)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.SAMLCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
   *   });
   * @see AWS.STS.assumeRoleWithSAML
   */
  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");
var iniLoader = AWS.util.iniLoader;

var ASSUME_ROLE_DEFAULT_REGION = 'us-east-1';

/**
 * Represents credentials loaded from shared credentials file
 * (defaulting to ~/.aws/credentials or defined by the
 * `AWS_SHARED_CREDENTIALS_FILE` environment variable).
 *
 * ## Using the shared credentials file
 *
 * This provider is checked by default in the Node.js environment. To use the
 * credentials file provider, simply add your access and secret keys to the
 * ~/.aws/credentials file in the following format:
 *
 *     [default]
 *     aws_access_key_id = AKID...
 *     aws_secret_access_key = YOUR_SECRET_KEY
 *
 * ## Using custom profiles
 *
 * The SDK supports loading credentials for separate profiles. This can be done
 * in two ways:
 *
 * 1. Set the `AWS_PROFILE` environment variable in your process prior to
 *    loading the SDK.
 * 2. Directly load the AWS.SharedIniFileCredentials provider:
 *
 * ```javascript
 * var creds = new AWS.SharedIniFileCredentials({profile: 'myprofile'});
 * AWS.config.credentials = creds;
 * ```
 *
 * @!macro nobrowser
 */
AWS.SharedIniFileCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new SharedIniFileCredentials object.
   *
   * @param options [map] a set of options
   * @option options profile [String] (AWS_PROFILE env var or 'default')
   *   the name of the profile to load.
   * @option options filename [String] ('~/.aws/credentials' or defined by
   *   AWS_SHARED_CREDENTIALS_FILE process env var)
   *   the filename to use when loading credentials.
   * @option options disableAssumeRole [Boolean] (false) True to disable
   *   support for profiles that assume an IAM role. If true, and an assume
   *   role profile is selected, an error is raised.
   * @option options preferStaticCredentials [Boolean] (false) True to
   *   prefer static credentials to role_arn if both are present.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   STS Assume Role TokenCode, if mfa_serial is provided for profile in ini
   *   file. Function is called with value of mfa_serial and callback, and
   *   should provide the TokenCode or an error to the callback in the format
   *   callback(err, token)
   * @option options callback [Function] (err) Credentials are eagerly loaded
   *   by the constructor. When the callback is called with no error, the
   *   credentials have been loaded successfully.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; The number of milliseconds a request can
   *     take before automatically being terminated.
   *     Defaults to two minutes (120000).
   */
  constructor: function SharedIniFileCredentials(options) {
    AWS.Credentials.call(this);

    options = options || {};

    this.filename = options.filename;
    this.profile = options.profile || process.env.AWS_PROFILE || AWS.util.defaultProfile;
    this.disableAssumeRole = Boolean(options.disableAssumeRole);
    this.preferStaticCredentials = Boolean(options.preferStaticCredentials);
    this.tokenCodeFn = options.tokenCodeFn || null;
    this.httpOptions = options.httpOptions || null;
    this.get(options.callback || AWS.util.fn.noop);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    try {
      var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader, this.filename);
      var profile = profiles[this.profile] || {};

      if (Object.keys(profile).length === 0) {
        throw AWS.util.error(
          new Error('Profile ' + this.profile + ' not found'),
          { code: 'SharedIniFileCredentialsProviderFailure' }
        );
      }

      /*
      In the CLI, the presence of both a role_arn and static credentials have
      different meanings depending on how many profiles have been visited. For
      the first profile processed, role_arn takes precedence over any static
      credentials, but for all subsequent profiles, static credentials are
      used if present, and only in their absence will the profile's
      source_profile and role_arn keys be used to load another set of
      credentials. This var is intended to yield compatible behaviour in this
      sdk.
      */
      var preferStaticCredentialsToRoleArn = Boolean(
        this.preferStaticCredentials
        && profile['aws_access_key_id']
        && profile['aws_secret_access_key']
      );

      if (profile['role_arn'] && !preferStaticCredentialsToRoleArn) {
        this.loadRoleProfile(profiles, profile, function(err, data) {
          if (err) {
            callback(err);
          } else {
            self.expired = false;
            self.accessKeyId = data.Credentials.AccessKeyId;
            self.secretAccessKey = data.Credentials.SecretAccessKey;
            self.sessionToken = data.Credentials.SessionToken;
            self.expireTime = data.Credentials.Expiration;
            callback(null);
          }
        });
        return;
      }

      this.accessKeyId = profile['aws_access_key_id'];
      this.secretAccessKey = profile['aws_secret_access_key'];
      this.sessionToken = profile['aws_session_token'];

      if (!this.accessKeyId || !this.secretAccessKey) {
        throw AWS.util.error(
          new Error('Credentials not set for profile ' + this.profile),
          { code: 'SharedIniFileCredentialsProviderFailure' }
        );
      }
      this.expired = false;
      callback(null);
    } catch (err) {
      callback(err);
    }
  },

  /**
   * Loads the credentials from the shared credentials file
   *
   * @callback callback function(err)
   *   Called after the shared INI file on disk is read and parsed. When this
   *   callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    iniLoader.clearCachedFiles();
    this.coalesceRefresh(
      callback || AWS.util.fn.callback,
      this.disableAssumeRole
    );
  },

  /**
   * @api private
   */
  loadRoleProfile: function loadRoleProfile(creds, roleProfile, callback) {
    if (this.disableAssumeRole) {
      throw AWS.util.error(
        new Error('Role assumption profiles are disabled. ' +
                  'Failed to load profile ' + this.profile +
                  ' from ' + creds.filename),
        { code: 'SharedIniFileCredentialsProviderFailure' }
      );
    }

    var self = this;
    var roleArn = roleProfile['role_arn'];
    var roleSessionName = roleProfile['role_session_name'];
    var externalId = roleProfile['external_id'];
    var mfaSerial = roleProfile['mfa_serial'];
    var sourceProfileName = roleProfile['source_profile'];

    // From experimentation, the following behavior mimics the AWS CLI:
    //
    // 1. Use region from the profile if present.
    // 2. Otherwise fall back to N. Virginia (global endpoint).
    //
    // It is necessary to do the fallback explicitly, because if
    // 'AWS_STS_REGIONAL_ENDPOINTS=regional', the underlying STS client will
    // otherwise throw an error if region is left 'undefined'.
    //
    // Experimentation shows that the AWS CLI (tested at version 1.18.136)
    // ignores the following potential sources of a region for the purposes of
    // this AssumeRole call:
    //
    // - The [default] profile
    // - The AWS_REGION environment variable
    //
    // Ignoring the [default] profile for the purposes of AssumeRole is arguably
    // a bug in the CLI since it does use the [default] region for service
    // calls... but right now we're matching behavior of the other tool.
    var profileRegion = roleProfile['region'] || ASSUME_ROLE_DEFAULT_REGION;

    if (!sourceProfileName) {
      throw AWS.util.error(
        new Error('source_profile is not set using profile ' + this.profile),
        { code: 'SharedIniFileCredentialsProviderFailure' }
      );
    }

    var sourceProfileExistanceTest = creds[sourceProfileName];

    if (typeof sourceProfileExistanceTest !== 'object') {
      throw AWS.util.error(
        new Error('source_profile ' + sourceProfileName + ' using profile '
          + this.profile + ' does not exist'),
        { code: 'SharedIniFileCredentialsProviderFailure' }
      );
    }

    var sourceCredentials = new AWS.SharedIniFileCredentials(
      AWS.util.merge(this.options || {}, {
        profile: sourceProfileName,
        preferStaticCredentials: true
      })
    );

    this.roleArn = roleArn;
    var sts = new STS({
      credentials: sourceCredentials,
      region: profileRegion,
      httpOptions: this.httpOptions
    });

    var roleParams = {
      RoleArn: roleArn,
      RoleSessionName: roleSessionName || 'aws-sdk-js-' + Date.now()
    };

    if (externalId) {
      roleParams.ExternalId = externalId;
    }

    if (mfaSerial && self.tokenCodeFn) {
      roleParams.SerialNumber = mfaSerial;
      self.tokenCodeFn(mfaSerial, function(err, token) {
        if (err) {
          var message;
          if (err instanceof Error) {
            message = err.message;
          } else {
            message = err;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: 'SharedIniFileCredentialsProviderFailure' }
            ));
          return;
        }

        roleParams.TokenCode = token;
        sts.assumeRole(roleParams, callback);
      });
      return;
    }
    sts.assumeRole(roleParams, callback);
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/temporary_credentials.js":
/*!***********************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/temporary_credentials.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * @note AWS.TemporaryCredentials is deprecated, but remains available for
 *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the
 *   preferred class for temporary credentials.
 *
 * To setup temporary credentials, configure a set of master credentials
 * using the standard credentials providers (environment, EC2 instance metadata,
 * or from the filesystem), then set the global credentials to a new
 * temporary credentials object:
 *
 * ```javascript
 * // Note that environment credentials are loaded by default,
 * // the following line is shown for clarity:
 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
 *
 * // Now set temporary credentials seeded from the master credentials
 * AWS.config.credentials = new AWS.TemporaryCredentials();
 *
 * // subsequent requests will now use temporary credentials from AWS STS.
 * new AWS.S3().listBucket(function(err, data) { ... });
 * ```
 *
 * @!attribute masterCredentials
 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @note In order to create temporary credentials, you first need to have
   *   "master" credentials configured in {AWS.Config.credentials}. These
   *   master credentials are necessary to retrieve the temporary credentials,
   *   as well as refresh the credentials when they expire.
   * @param params [map] a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role.
   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
   *  used to get and refresh temporary credentials from AWS STS.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.TemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.TemporaryCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function TemporaryCredentials(params, masterCredentials) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials(masterCredentials);
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh (callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load (callback) {
    var self = this;
    self.createClients();
    self.masterCredentials.get(function () {
      self.service.config.credentials = self.masterCredentials;
      var operation = self.params.RoleArn ?
        self.service.assumeRole : self.service.getSessionToken;
      operation.call(self.service, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  loadMasterCredentials: function loadMasterCredentials (masterCredentials) {
    this.masterCredentials = masterCredentials || AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }

    if (typeof this.masterCredentials.get !== 'function') {
      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
    }
  },

  /**
   * @api private
   */
  createClients: function () {
    this.service = this.service || new STS({params: this.params});
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var fs = __webpack_require__(/*! fs */ "fs");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");
var iniLoader = AWS.util.iniLoader;

/**
 * Represents OIDC credentials from a file on disk
 * If the credentials expire, the SDK can {refresh} the credentials
 * from the file.
 *
 * ## Using the web identity token file
 *
 * This provider is checked by default in the Node.js environment. To use
 * the provider simply add your OIDC token to a file (ASCII encoding) and
 * share the filename in either AWS_WEB_IDENTITY_TOKEN_FILE environment
 * variable or web_identity_token_file shared config variable
 *
 * The file contains encoded OIDC token and the characters are
 * ASCII encoded. OIDC tokens are JSON Web Tokens (JWT).
 * JWT's are 3 base64 encoded strings joined by the '.' character.
 *
 * This class will read filename from AWS_WEB_IDENTITY_TOKEN_FILE
 * environment variable or web_identity_token_file shared config variable,
 * and get the OIDC token from filename.
 * It will also read IAM role to be assumed from AWS_ROLE_ARN
 * environment variable or role_arn shared config variable.
 * This provider gets credetials using the {AWS.STS.assumeRoleWithWebIdentity}
 * service operation
 *
 * @!macro nobrowser
 */
AWS.TokenFileWebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {

  /**
   * @example Creating a new credentials object
   *  AWS.config.credentials = new AWS.TokenFileWebIdentityCredentials(
   *   // optionally provide configuration to apply to the underlying AWS.STS service client
   *   // if configuration is not provided, then configuration will be pulled from AWS.config
   *   {
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.Config
   */
  constructor: function TokenFileWebIdentityCredentials(clientConfig) {
    AWS.Credentials.call(this);
    this.data = null;
    this.clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Returns params from environment variables
   *
   * @api private
   */
  getParamsFromEnv: function getParamsFromEnv() {
    var ENV_TOKEN_FILE = 'AWS_WEB_IDENTITY_TOKEN_FILE',
        ENV_ROLE_ARN = 'AWS_ROLE_ARN';
    if (process.env[ENV_TOKEN_FILE] && process.env[ENV_ROLE_ARN]) {
      return [{
        envTokenFile: process.env[ENV_TOKEN_FILE],
        roleArn: process.env[ENV_ROLE_ARN],
        roleSessionName: process.env['AWS_ROLE_SESSION_NAME']
      }];
    }
  },

  /**
   * Returns params from shared config variables
   *
   * @api private
   */
  getParamsFromSharedConfig: function getParamsFromSharedConfig() {
    var profiles = AWS.util.getProfilesFromSharedConfig(iniLoader);
    var profileName = process.env.AWS_PROFILE || AWS.util.defaultProfile;
    var profile = profiles[profileName] || {};

    if (Object.keys(profile).length === 0) {
      throw AWS.util.error(
        new Error('Profile ' + profileName + ' not found'),
        { code: 'TokenFileWebIdentityCredentialsProviderFailure' }
      );
    }

    var paramsArray = [];

    while (!profile['web_identity_token_file'] && profile['source_profile']) {
      paramsArray.unshift({
        roleArn: profile['role_arn'],
        roleSessionName: profile['role_session_name']
      });
      var sourceProfile = profile['source_profile'];
      profile = profiles[sourceProfile];
    }

    paramsArray.unshift({
      envTokenFile: profile['web_identity_token_file'],
      roleArn: profile['role_arn'],
      roleSessionName: profile['role_session_name']
    });

    return paramsArray;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
  */
  assumeRoleChaining: function assumeRoleChaining(paramsArray, callback) {
    var self = this;
    if (paramsArray.length === 0) {
      self.service.credentialsFrom(self.data, self);
      callback();
    } else {
      var params = paramsArray.shift();
      self.service.config.credentials = self.service.credentialsFrom(self.data, self);
      self.service.assumeRole(
        {
          RoleArn: params.roleArn,
          RoleSessionName: params.roleSessionName || 'token-file-web-identity'
        },
        function (err, data) {
          self.data = null;
          if (err) {
            callback(err);
          } else {
            self.data = data;
            self.assumeRoleChaining(paramsArray, callback);
          }
        }
      );
    }
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    try {
      var paramsArray = self.getParamsFromEnv();
      if (!paramsArray) {
        paramsArray = self.getParamsFromSharedConfig();
      }
      if (paramsArray) {
        var params = paramsArray.shift();
        var oidcToken = fs.readFileSync(params.envTokenFile, {encoding: 'ascii'});
        if (!self.service) {
          self.createClients();
        }
        self.service.assumeRoleWithWebIdentity(
          {
            WebIdentityToken: oidcToken,
            RoleArn: params.roleArn,
            RoleSessionName: params.roleSessionName || 'token-file-web-identity'
          },
          function (err, data) {
            self.data = null;
            if (err) {
              callback(err);
            } else {
              self.data = data;
              self.assumeRoleChaining(paramsArray, callback);
            }
          }
        );
      }
    } catch (err) {
      callback(err);
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this.clientConfig);
      this.service = new STS(stsConfig);

      // Retry in case of IDPCommunicationErrorException or InvalidIdentityToken
      this.service.retryableError = function(error) {
        if (error.code === 'IDPCommunicationErrorException' || error.code === 'InvalidIdentityToken') {
          return true;
        } else {
          return AWS.Service.prototype.retryableError.call(this, error);
        }
      };
    }
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/credentials/web_identity_credentials.js":
/*!**************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/credentials/web_identity_credentials.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var STS = __webpack_require__(/*! ../../clients/sts */ "./node_modules/aws-sdk/clients/sts.js");

/**
 * Represents credentials retrieved from STS Web Identity Federation support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given. In addition, the
 * `WebIdentityToken` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn` and `WebIdentityToken` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 */
AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithWebIdentity)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
   *     RoleSessionName: 'web' // optional name, defaults to web-identity
   *   }, {
   *     // optionally provide configuration to apply to the underlying AWS.STS service client
   *     // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.Config
   */
  constructor: function WebIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this._clientConfig);
      stsConfig.params = this.params;
      this.service = new STS(stsConfig);
    }
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/discover_endpoint.js":
/*!*******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/discover_endpoint.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/aws-sdk/lib/util.js");
var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];

/**
 * Generate key (except resources and operation part) to index the endpoints in the cache
 * If input shape has endpointdiscoveryid trait then use
 *   accessKey + operation + resources + region + service as cache key
 * If input shape doesn't have endpointdiscoveryid trait then use
 *   accessKey + region + service as cache key
 * @return [map<String,String>] object with keys to index endpoints.
 * @api private
 */
function getCacheKey(request) {
  var service = request.service;
  var api = service.api || {};
  var operations = api.operations;
  var identifiers = {};
  if (service.config.region) {
    identifiers.region = service.config.region;
  }
  if (api.serviceId) {
    identifiers.serviceId = api.serviceId;
  }
  if (service.config.credentials.accessKeyId) {
    identifiers.accessKeyId = service.config.credentials.accessKeyId;
  }
  return identifiers;
}

/**
 * Recursive helper for marshallCustomIdentifiers().
 * Looks for required string input members that have 'endpointdiscoveryid' trait.
 * @api private
 */
function marshallCustomIdentifiersHelper(result, params, shape) {
  if (!shape || params === undefined || params === null) return;
  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
    util.arrayEach(shape.required, function(name) {
      var memberShape = shape.members[name];
      if (memberShape.endpointDiscoveryId === true) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        result[locationName] = String(params[name]);
      } else {
        marshallCustomIdentifiersHelper(result, params[name], memberShape);
      }
    });
  }
}

/**
 * Get custom identifiers for cache key.
 * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
 * @param [object] request object
 * @param [object] input shape of the given operation's api
 * @api private
 */
function marshallCustomIdentifiers(request, shape) {
  var identifiers = {};
  marshallCustomIdentifiersHelper(identifiers, request.params, shape);
  return identifiers;
}

/**
 * Call endpoint discovery operation when it's optional.
 * When endpoint is available in cache then use the cached endpoints. If endpoints
 * are unavailable then use regional endpoints and call endpoint discovery operation
 * asynchronously. This is turned off by default.
 * @param [object] request object
 * @api private
 */
function optionalDiscoverEndpoint(request) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var endpoints = AWS.endpointCache.get(cacheKey);
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //or endpoint operation just failed in 1 minute
    return;
  } else if (endpoints && endpoints.length > 0) {
    //found endpoint record from cache
    request.httpRequest.updateEndpoint(endpoints[0].Address);
  } else {
    //endpoint record not in cache or outdated. make discovery operation
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    addApiVersionHeader(endpointRequest);
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);
    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKey, [{
      Address: '',
      CachePeriodInMinutes: 1
    }]);
    endpointRequest.send(function(err, data) {
      if (data && data.Endpoints) {
        AWS.endpointCache.put(cacheKey, data.Endpoints);
      } else if (err) {
        AWS.endpointCache.put(cacheKey, [{
          Address: '',
          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute
        }]);
      }
    });
  }
}

var requestQueue = {};

/**
 * Call endpoint discovery operation when it's required.
 * When endpoint is available in cache then use cached ones. If endpoints are
 * unavailable then SDK should call endpoint operation then use returned new
 * endpoint for the api call. SDK will automatically attempt to do endpoint
 * discovery. This is turned off by default
 * @param [object] request object
 * @api private
 */
function requiredDiscoverEndpoint(request, done) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //push request object to a pending queue
    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
    requestQueue[cacheKeyStr].push({request: request, callback: done});
    return;
  } else if (endpoints && endpoints.length > 0) {
    request.httpRequest.updateEndpoint(endpoints[0].Address);
    done();
  } else {
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    addApiVersionHeader(endpointRequest);

    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKeyStr, [{
      Address: '',
      CachePeriodInMinutes: 60 //long-live cache
    }]);
    endpointRequest.send(function(err, data) {
      if (err) {
        request.response.error = util.error(err, { retryable: false });
        AWS.endpointCache.remove(cacheKey);

        //fail all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.response.error = util.error(err, { retryable: false });
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      } else if (data) {
        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);

        //update the endpoint for all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      }
      done();
    });
  }
}

/**
 * add api version header to endpoint operation
 * @api private
 */
function addApiVersionHeader(endpointRequest) {
  var api = endpointRequest.service.api;
  var apiVersion = api.apiVersion;
  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
  }
}

/**
 * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
 * endpoint from cache.
 * @api private
 */
function invalidateCachedEndpoints(response) {
  var error = response.error;
  var httpResponse = response.httpResponse;
  if (error &&
    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)
  ) {
    var request = response.request;
    var operations = request.service.api.operations || {};
    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
    var identifiers = marshallCustomIdentifiers(request, inputShape);
    var cacheKey = getCacheKey(request);
    if (Object.keys(identifiers).length > 0) {
      cacheKey = util.update(cacheKey, identifiers);
      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
    }
    AWS.endpointCache.remove(cacheKey);
  }
}

/**
 * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
 * @param [object] client Service client object.
 * @api private
 */
function hasCustomEndpoint(client) {
  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
    throw util.error(new Error(), {
      code: 'ConfigurationException',
      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
    });
  };
  var svcConfig = AWS.config[client.serviceIdentifier] || {};
  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));
}

/**
 * @api private
 */
function isFalsy(value) {
  return ['false', '0'].indexOf(value) >= 0;
}

/**
 * If endpoint discovery should perform for this request when no operation requires endpoint
 * discovery for the given service.
 * SDK performs config resolution in order like below:
 * 1. If set in client configuration.
 * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.
 * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.
 * @param [object] request request object.
 * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this
 *  function returns undefined
 * @api private
 */
function resolveEndpointDiscoveryConfig(request) {
  var service = request.service || {};
  if (service.config.endpointDiscoveryEnabled !== undefined) {
    return service.config.endpointDiscoveryEnabled;
  }

  //shared ini file is only available in Node
  //not to check env in browser
  if (util.isBrowser()) return undefined;

  // If any of recognized endpoint discovery config env is set
  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
    var env = endpointDiscoveryEnabledEnvs[i];
    if (Object.prototype.hasOwnProperty.call(process.env, env)) {
      if (process.env[env] === '' || process.env[env] === undefined) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'environmental variable ' + env + ' cannot be set to nothing'
        });
      }
      return !isFalsy(process.env[env]);
    }
  }

  var configFile = {};
  try {
    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || AWS.util.defaultProfile
  ] || {};
  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
      throw util.error(new Error(), {
        code: 'ConfigurationException',
        message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
      });
    }
    return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
  }
  return undefined;
}

/**
 * attach endpoint discovery logic to request object
 * @param [object] request
 * @api private
 */
function discoverEndpoint(request, done) {
  var service = request.service || {};
  if (hasCustomEndpoint(service) || request.isPresigned()) return done();

  var operations = service.api.operations || {};
  var operationModel = operations[request.operation];
  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
  var isEnabled = resolveEndpointDiscoveryConfig(request);
  var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
  if (isEnabled || hasRequiredEndpointDiscovery) {
    // Once a customer enables endpoint discovery, the SDK should start appending
    // the string endpoint-discovery to the user-agent on all requests.
    request.httpRequest.appendToUserAgent('endpoint-discovery');
  }
  switch (isEndpointDiscoveryRequired) {
    case 'OPTIONAL':
      if (isEnabled || hasRequiredEndpointDiscovery) {
        // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery
        // by default for all operations of that service, including operations where endpoint discovery is optional.
        optionalDiscoverEndpoint(request);
        request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      }
      done();
      break;
    case 'REQUIRED':
      if (isEnabled === false) {
        // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,
        // then the SDK must return a clear and actionable exception.
        request.response.error = util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation +
                    '() requires it. Please check your configurations.'
        });
        done();
        break;
      }
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      requiredDiscoverEndpoint(request, done);
      break;
    case 'NULL':
    default:
      done();
      break;
  }
}

module.exports = {
  discoverEndpoint: discoverEndpoint,
  requiredDiscoverEndpoint: requiredDiscoverEndpoint,
  optionalDiscoverEndpoint: optionalDiscoverEndpoint,
  marshallCustomIdentifiers: marshallCustomIdentifiers,
  getCacheKey: getCacheKey,
  invalidateCachedEndpoint: invalidateCachedEndpoints,
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/dynamodb/converter.js":
/*!********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/dynamodb/converter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var util = AWS.util;
var typeOf = (__webpack_require__(/*! ./types */ "./node_modules/aws-sdk/lib/dynamodb/types.js").typeOf);
var DynamoDBSet = __webpack_require__(/*! ./set */ "./node_modules/aws-sdk/lib/dynamodb/set.js");
var NumberValue = __webpack_require__(/*! ./numberValue */ "./node_modules/aws-sdk/lib/dynamodb/numberValue.js");

AWS.DynamoDB.Converter = {
  /**
   * Convert a JavaScript value to its equivalent DynamoDB AttributeValue type
   *
   * @param data [any] The data to convert to a DynamoDB AttributeValue
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   * @return [map] An object in the Amazon DynamoDB AttributeValue format
   *
   * @see AWS.DynamoDB.Converter.marshall AWS.DynamoDB.Converter.marshall to
   *    convert entire records (rather than individual attributes)
   */
  input: function convertInput(data, options) {
    options = options || {};
    var type = typeOf(data);
    if (type === 'Object') {
      return formatMap(data, options);
    } else if (type === 'Array') {
      return formatList(data, options);
    } else if (type === 'Set') {
      return formatSet(data, options);
    } else if (type === 'String') {
      if (data.length === 0 && options.convertEmptyValues) {
        return convertInput(null);
      }
      return { S: data };
    } else if (type === 'Number' || type === 'NumberValue') {
      return { N: data.toString() };
    } else if (type === 'Binary') {
      if (data.length === 0 && options.convertEmptyValues) {
        return convertInput(null);
      }
      return { B: data };
    } else if (type === 'Boolean') {
      return { BOOL: data };
    } else if (type === 'null') {
      return { NULL: true };
    } else if (type !== 'undefined' && type !== 'Function') {
      // this value has a custom constructor
      return formatMap(data, options);
    }
  },

  /**
   * Convert a JavaScript object into a DynamoDB record.
   *
   * @param data [any] The data to convert to a DynamoDB record
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   *
   * @return [map] An object in the DynamoDB record format.
   *
   * @example Convert a JavaScript object into a DynamoDB record
   *  var marshalled = AWS.DynamoDB.Converter.marshall({
   *    string: 'foo',
   *    list: ['fizz', 'buzz', 'pop'],
   *    map: {
   *      nestedMap: {
   *        key: 'value',
   *      }
   *    },
   *    number: 123,
   *    nullValue: null,
   *    boolValue: true,
   *    stringSet: new DynamoDBSet(['foo', 'bar', 'baz'])
   *  });
   */
  marshall: function marshallItem(data, options) {
    return AWS.DynamoDB.Converter.input(data, options).M;
  },

  /**
   * Convert a DynamoDB AttributeValue object to its equivalent JavaScript type.
   *
   * @param data [map] An object in the Amazon DynamoDB AttributeValue format
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   *
   * @return [Object|Array|String|Number|Boolean|null]
   *
   * @see AWS.DynamoDB.Converter.unmarshall AWS.DynamoDB.Converter.unmarshall to
   *    convert entire records (rather than individual attributes)
   */
  output: function convertOutput(data, options) {
    options = options || {};
    var list, map, i;
    for (var type in data) {
      var values = data[type];
      if (type === 'M') {
        map = {};
        for (var key in values) {
          map[key] = convertOutput(values[key], options);
        }
        return map;
      } else if (type === 'L') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(convertOutput(values[i], options));
        }
        return list;
      } else if (type === 'SS') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(values[i] + '');
        }
        return new DynamoDBSet(list);
      } else if (type === 'NS') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(convertNumber(values[i], options.wrapNumbers));
        }
        return new DynamoDBSet(list);
      } else if (type === 'BS') {
        list = [];
        for (i = 0; i < values.length; i++) {
          list.push(AWS.util.buffer.toBuffer(values[i]));
        }
        return new DynamoDBSet(list);
      } else if (type === 'S') {
        return values + '';
      } else if (type === 'N') {
        return convertNumber(values, options.wrapNumbers);
      } else if (type === 'B') {
        return util.buffer.toBuffer(values);
      } else if (type === 'BOOL') {
        return (values === 'true' || values === 'TRUE' || values === true);
      } else if (type === 'NULL') {
        return null;
      }
    }
  },

  /**
   * Convert a DynamoDB record into a JavaScript object.
   *
   * @param data [any] The DynamoDB record
   * @param options [map]
   * @option options convertEmptyValues [Boolean] Whether to automatically
   *                                              convert empty strings, blobs,
   *                                              and sets to `null`
   * @option options wrapNumbers [Boolean]  Whether to return numbers as a
   *                                        NumberValue object instead of
   *                                        converting them to native JavaScript
   *                                        numbers. This allows for the safe
   *                                        round-trip transport of numbers of
   *                                        arbitrary size.
   *
   * @return [map] An object whose properties have been converted from
   *    DynamoDB's AttributeValue format into their corresponding native
   *    JavaScript types.
   *
   * @example Convert a record received from a DynamoDB stream
   *  var unmarshalled = AWS.DynamoDB.Converter.unmarshall({
   *    string: {S: 'foo'},
   *    list: {L: [{S: 'fizz'}, {S: 'buzz'}, {S: 'pop'}]},
   *    map: {
   *      M: {
   *        nestedMap: {
   *          M: {
   *            key: {S: 'value'}
   *          }
   *        }
   *      }
   *    },
   *    number: {N: '123'},
   *    nullValue: {NULL: true},
   *    boolValue: {BOOL: true}
   *  });
   */
  unmarshall: function unmarshall(data, options) {
    return AWS.DynamoDB.Converter.output({M: data}, options);
  }
};

/**
 * @api private
 * @param data [Array]
 * @param options [map]
 */
function formatList(data, options) {
  var list = {L: []};
  for (var i = 0; i < data.length; i++) {
    list['L'].push(AWS.DynamoDB.Converter.input(data[i], options));
  }
  return list;
}

/**
 * @api private
 * @param value [String]
 * @param wrapNumbers [Boolean]
 */
function convertNumber(value, wrapNumbers) {
  return wrapNumbers ? new NumberValue(value) : Number(value);
}

/**
 * @api private
 * @param data [map]
 * @param options [map]
 */
function formatMap(data, options) {
  var map = {M: {}};
  for (var key in data) {
    var formatted = AWS.DynamoDB.Converter.input(data[key], options);
    if (formatted !== void 0) {
      map['M'][key] = formatted;
    }
  }
  return map;
}

/**
 * @api private
 */
function formatSet(data, options) {
  options = options || {};
  var values = data.values;
  if (options.convertEmptyValues) {
    values = filterEmptySetValues(data);
    if (values.length === 0) {
      return AWS.DynamoDB.Converter.input(null);
    }
  }

  var map = {};
  switch (data.type) {
    case 'String': map['SS'] = values; break;
    case 'Binary': map['BS'] = values; break;
    case 'Number': map['NS'] = values.map(function (value) {
      return value.toString();
    });
  }
  return map;
}

/**
 * @api private
 */
function filterEmptySetValues(set) {
    var nonEmptyValues = [];
    var potentiallyEmptyTypes = {
        String: true,
        Binary: true,
        Number: false
    };
    if (potentiallyEmptyTypes[set.type]) {
        for (var i = 0; i < set.values.length; i++) {
            if (set.values[i].length === 0) {
                continue;
            }
            nonEmptyValues.push(set.values[i]);
        }

        return nonEmptyValues;
    }

    return set.values;
}

/**
 * @api private
 */
module.exports = AWS.DynamoDB.Converter;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/dynamodb/document_client.js":
/*!**************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/dynamodb/document_client.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var Translator = __webpack_require__(/*! ./translator */ "./node_modules/aws-sdk/lib/dynamodb/translator.js");
var DynamoDBSet = __webpack_require__(/*! ./set */ "./node_modules/aws-sdk/lib/dynamodb/set.js");

/**
 * The document client simplifies working with items in Amazon DynamoDB
 * by abstracting away the notion of attribute values. This abstraction
 * annotates native JavaScript types supplied as input parameters, as well
 * as converts annotated response data to native JavaScript types.
 *
 * ## Marshalling Input and Unmarshalling Response Data
 *
 * The document client affords developers the use of native JavaScript types
 * instead of `AttributeValue`s to simplify the JavaScript development
 * experience with Amazon DynamoDB. JavaScript objects passed in as parameters
 * are marshalled into `AttributeValue` shapes required by Amazon DynamoDB.
 * Responses from DynamoDB are unmarshalled into plain JavaScript objects
 * by the `DocumentClient`. The `DocumentClient`, does not accept
 * `AttributeValue`s in favor of native JavaScript types.
 *
 * |                             JavaScript Type                            | DynamoDB AttributeValue |
 * |:----------------------------------------------------------------------:|-------------------------|
 * | String                                                                 | S                       |
 * | Number                                                                 | N                       |
 * | Boolean                                                                | BOOL                    |
 * | null                                                                   | NULL                    |
 * | Array                                                                  | L                       |
 * | Object                                                                 | M                       |
 * | Buffer, File, Blob, ArrayBuffer, DataView, and JavaScript typed arrays | B                       |
 *
 * ## Support for Sets
 *
 * The `DocumentClient` offers a convenient way to create sets from
 * JavaScript Arrays. The type of set is inferred from the first element
 * in the array. DynamoDB supports string, number, and binary sets. To
 * learn more about supported types see the
 * [Amazon DynamoDB Data Model Documentation](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html)
 * For more information see {AWS.DynamoDB.DocumentClient.createSet}
 *
 */
AWS.DynamoDB.DocumentClient = AWS.util.inherit({

  /**
   * Creates a DynamoDB document client with a set of configuration options.
   *
   * @option options params [map] An optional map of parameters to bind to every
   *   request sent by this service object.
   * @option options service [AWS.DynamoDB] An optional pre-configured instance
   *  of the AWS.DynamoDB service object to use for requests. The object may
   *  bound parameters used by the document client.
   * @option options convertEmptyValues [Boolean] set to true if you would like
   *  the document client to convert empty values (0-length strings, binary
   *  buffers, and sets) to be converted to NULL types when persisting to
   *  DynamoDB.
   * @option options wrapNumbers [Boolean] Set to true to return numbers as a
   *  NumberValue object instead of converting them to native JavaScript numbers.
   *  This allows for the safe round-trip transport of numbers of arbitrary size.
   * @see AWS.DynamoDB.constructor
   *
   */
  constructor: function DocumentClient(options) {
    var self = this;
    self.options = options || {};
    self.configure(self.options);
  },

  /**
   * @api private
   */
  configure: function configure(options) {
    var self = this;
    self.service = options.service;
    self.bindServiceObject(options);
    self.attrValue = options.attrValue =
      self.service.api.operations.putItem.input.members.Item.value.shape;
  },

  /**
   * @api private
   */
  bindServiceObject: function bindServiceObject(options) {
    var self = this;
    options = options || {};

    if (!self.service) {
      self.service = new AWS.DynamoDB(options);
    } else {
      var config = AWS.util.copy(self.service.config);
      self.service = new self.service.constructor.__super__(config);
      self.service.config.params =
        AWS.util.merge(self.service.config.params || {}, options.params);
    }
  },

  /**
   * @api private
   */
  makeServiceRequest: function(operation, params, callback) {
    var self = this;
    var request = self.service[operation](params);
    self.setupRequest(request);
    self.setupResponse(request);
    if (typeof callback === 'function') {
      request.send(callback);
    }
    return request;
  },

  /**
   * @api private
   */
  serviceClientOperationsMap: {
    batchGet: 'batchGetItem',
    batchWrite: 'batchWriteItem',
    delete: 'deleteItem',
    get: 'getItem',
    put: 'putItem',
    query: 'query',
    scan: 'scan',
    update: 'updateItem',
    transactGet: 'transactGetItems',
    transactWrite: 'transactWriteItems'
  },

  /**
   * Returns the attributes of one or more items from one or more tables
   * by delegating to `AWS.DynamoDB.batchGetItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.batchGetItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.batchGetItem
   * @example Get items from multiple tables
   *  var params = {
   *    RequestItems: {
   *      'Table-1': {
   *        Keys: [
   *          {
   *             HashKey: 'haskey',
   *             NumberRangeKey: 1
   *          }
   *        ]
   *      },
   *      'Table-2': {
   *        Keys: [
   *          { foo: 'bar' },
   *        ]
   *      }
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.batchGet(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  batchGet: function(params, callback) {
    var operation = this.serviceClientOperationsMap['batchGet'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Puts or deletes multiple items in one or more tables by delegating
   * to `AWS.DynamoDB.batchWriteItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.batchWriteItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.batchWriteItem
   * @example Write to and delete from a table
   *  var params = {
   *    RequestItems: {
   *      'Table-1': [
   *        {
   *          DeleteRequest: {
   *            Key: { HashKey: 'someKey' }
   *          }
   *        },
   *        {
   *          PutRequest: {
   *            Item: {
   *              HashKey: 'anotherKey',
   *              NumAttribute: 1,
   *              BoolAttribute: true,
   *              ListAttribute: [1, 'two', false],
   *              MapAttribute: { foo: 'bar' }
   *            }
   *          }
   *        }
   *      ]
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.batchWrite(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  batchWrite: function(params, callback) {
    var operation = this.serviceClientOperationsMap['batchWrite'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Deletes a single item in a table by primary key by delegating to
   * `AWS.DynamoDB.deleteItem()`
   *
   * Supply the same parameters as {AWS.DynamoDB.deleteItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.deleteItem
   * @example Delete an item from a table
   *  var params = {
   *    TableName : 'Table',
   *    Key: {
   *      HashKey: 'hashkey',
   *      NumberRangeKey: 1
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.delete(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  delete: function(params, callback) {
    var operation = this.serviceClientOperationsMap['delete'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Returns a set of attributes for the item with the given primary key
   * by delegating to `AWS.DynamoDB.getItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.getItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.getItem
   * @example Get an item from a table
   *  var params = {
   *    TableName : 'Table',
   *    Key: {
   *      HashKey: 'hashkey'
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.get(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  get: function(params, callback) {
    var operation = this.serviceClientOperationsMap['get'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Creates a new item, or replaces an old item with a new item by
   * delegating to `AWS.DynamoDB.putItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.putItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.putItem
   * @example Create a new item in a table
   *  var params = {
   *    TableName : 'Table',
   *    Item: {
   *       HashKey: 'haskey',
   *       NumAttribute: 1,
   *       BoolAttribute: true,
   *       ListAttribute: [1, 'two', false],
   *       MapAttribute: { foo: 'bar'},
   *       NullAttribute: null
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.put(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  put: function(params, callback) {
    var operation = this.serviceClientOperationsMap['put'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Edits an existing item's attributes, or adds a new item to the table if
   * it does not already exist by delegating to `AWS.DynamoDB.updateItem()`.
   *
   * Supply the same parameters as {AWS.DynamoDB.updateItem} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.updateItem
   * @example Update an item with expressions
   *  var params = {
   *    TableName: 'Table',
   *    Key: { HashKey : 'hashkey' },
   *    UpdateExpression: 'set #a = :x + :y',
   *    ConditionExpression: '#a < :MAX',
   *    ExpressionAttributeNames: {'#a' : 'Sum'},
   *    ExpressionAttributeValues: {
   *      ':x' : 20,
   *      ':y' : 45,
   *      ':MAX' : 100,
   *    }
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.update(params, function(err, data) {
   *     if (err) console.log(err);
   *     else console.log(data);
   *  });
   *
   */
  update: function(params, callback) {
    var operation = this.serviceClientOperationsMap['update'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Returns one or more items and item attributes by accessing every item
   * in a table or a secondary index.
   *
   * Supply the same parameters as {AWS.DynamoDB.scan} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.scan
   * @example Scan the table with a filter expression
   *  var params = {
   *    TableName : 'Table',
   *    FilterExpression : 'Year = :this_year',
   *    ExpressionAttributeValues : {':this_year' : 2015}
   *  };
   *
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  documentClient.scan(params, function(err, data) {
   *     if (err) console.log(err);
   *     else console.log(data);
   *  });
   *
   */
  scan: function(params, callback) {
    var operation = this.serviceClientOperationsMap['scan'];
    return this.makeServiceRequest(operation, params, callback);
  },

   /**
    * Directly access items from a table by primary key or a secondary index.
    *
    * Supply the same parameters as {AWS.DynamoDB.query} with
    * `AttributeValue`s substituted by native JavaScript types.
    *
    * @see AWS.DynamoDB.query
    * @example Query an index
    *  var params = {
    *    TableName: 'Table',
    *    IndexName: 'Index',
    *    KeyConditionExpression: 'HashKey = :hkey and RangeKey > :rkey',
    *    ExpressionAttributeValues: {
    *      ':hkey': 'key',
    *      ':rkey': 2015
    *    }
    *  };
    *
    *  var documentClient = new AWS.DynamoDB.DocumentClient();
    *
    *  documentClient.query(params, function(err, data) {
    *     if (err) console.log(err);
    *     else console.log(data);
    *  });
    *
    */
  query: function(params, callback) {
    var operation = this.serviceClientOperationsMap['query'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Synchronous write operation that groups up to 25 action requests.
   *
   * Supply the same parameters as {AWS.DynamoDB.transactWriteItems} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.transactWriteItems
   * @example Get items from multiple tables
   *  var params = {
   *    TransactItems: [{
   *      Put: {
   *        TableName : 'Table0',
   *        Item: {
   *          HashKey: 'haskey',
   *          NumAttribute: 1,
   *          BoolAttribute: true,
   *          ListAttribute: [1, 'two', false],
   *          MapAttribute: { foo: 'bar'},
   *          NullAttribute: null
   *        }
   *      }
   *    }, {
   *      Update: {
   *        TableName: 'Table1',
   *        Key: { HashKey : 'hashkey' },
   *        UpdateExpression: 'set #a = :x + :y',
   *        ConditionExpression: '#a < :MAX',
   *        ExpressionAttributeNames: {'#a' : 'Sum'},
   *        ExpressionAttributeValues: {
   *          ':x' : 20,
   *          ':y' : 45,
   *          ':MAX' : 100,
   *        }
   *      }
   *    }]
   *  };
   *
   *  documentClient.transactWrite(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   */
  transactWrite: function(params, callback) {
    var operation = this.serviceClientOperationsMap['transactWrite'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Atomically retrieves multiple items from one or more tables (but not from indexes)
   * in a single account and region.
   *
   * Supply the same parameters as {AWS.DynamoDB.transactGetItems} with
   * `AttributeValue`s substituted by native JavaScript types.
   *
   * @see AWS.DynamoDB.transactGetItems
   * @example Get items from multiple tables
   *  var params = {
   *    TransactItems: [{
   *      Get: {
   *        TableName : 'Table0',
   *        Key: {
   *          HashKey: 'hashkey0'
   *        }
   *      }
   *    }, {
   *      Get: {
   *        TableName : 'Table1',
   *        Key: {
   *          HashKey: 'hashkey1'
   *        }
   *      }
   *    }]
   *  };
   *
   *  documentClient.transactGet(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   */
  transactGet: function(params, callback) {
    var operation = this.serviceClientOperationsMap['transactGet'];
    return this.makeServiceRequest(operation, params, callback);
  },

  /**
   * Creates a set of elements inferring the type of set from
   * the type of the first element. Amazon DynamoDB currently supports
   * the number sets, string sets, and binary sets. For more information
   * about DynamoDB data types see the documentation on the
   * [Amazon DynamoDB Data Model](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModel.DataTypes).
   *
   * @param list [Array] Collection to represent your DynamoDB Set
   * @param options [map]
   *  * **validate** [Boolean] set to true if you want to validate the type
   *    of each element in the set. Defaults to `false`.
   * @example Creating a number set
   *  var documentClient = new AWS.DynamoDB.DocumentClient();
   *
   *  var params = {
   *    Item: {
   *      hashkey: 'hashkey'
   *      numbers: documentClient.createSet([1, 2, 3]);
   *    }
   *  };
   *
   *  documentClient.put(params, function(err, data) {
   *    if (err) console.log(err);
   *    else console.log(data);
   *  });
   *
   */
  createSet: function(list, options) {
    options = options || {};
    return new DynamoDBSet(list, options);
  },

  /**
   * @api private
   */
  getTranslator: function() {
    return new Translator(this.options);
  },

  /**
   * @api private
   */
  setupRequest: function setupRequest(request) {
    var self = this;
    var translator = self.getTranslator();
    var operation = request.operation;
    var inputShape = request.service.api.operations[operation].input;
    request._events.validate.unshift(function(req) {
      req.rawParams = AWS.util.copy(req.params);
      req.params = translator.translateInput(req.rawParams, inputShape);
    });
  },

  /**
   * @api private
   */
  setupResponse: function setupResponse(request) {
    var self = this;
    var translator = self.getTranslator();
    var outputShape = self.service.api.operations[request.operation].output;
    request.on('extractData', function(response) {
      response.data = translator.translateOutput(response.data, outputShape);
    });

    var response = request.response;
    response.nextPage = function(cb) {
      var resp = this;
      var req = resp.request;
      var config;
      var service = req.service;
      var operation = req.operation;
      try {
        config = service.paginationConfig(operation, true);
      } catch (e) { resp.error = e; }

      if (!resp.hasNextPage()) {
        if (cb) cb(resp.error, null);
        else if (resp.error) throw resp.error;
        return null;
      }

      var params = AWS.util.copy(req.rawParams);
      if (!resp.nextPageTokens) {
        return cb ? cb(null, null) : null;
      } else {
        var inputTokens = config.inputToken;
        if (typeof inputTokens === 'string') inputTokens = [inputTokens];
        for (var i = 0; i < inputTokens.length; i++) {
          params[inputTokens[i]] = resp.nextPageTokens[i];
        }
        return self[operation](params, cb);
      }
    };
  }

});

/**
 * @api private
 */
module.exports = AWS.DynamoDB.DocumentClient;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/dynamodb/numberValue.js":
/*!**********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/dynamodb/numberValue.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);

/**
 * An object recognizable as a numeric value that stores the underlying number
 * as a string.
 *
 * Intended to be a deserialization target for the DynamoDB Document Client when
 * the `wrapNumbers` flag is set. This allows for numeric values that lose
 * precision when converted to JavaScript's `number` type.
 */
var DynamoDBNumberValue = util.inherit({
  constructor: function NumberValue(value) {
    this.wrapperName = 'NumberValue';
    this.value = value.toString();
  },

  /**
   * Render the underlying value as a number when converting to JSON.
   */
  toJSON: function () {
    return this.toNumber();
  },

  /**
   * Convert the underlying value to a JavaScript number.
   */
  toNumber: function () {
    return Number(this.value);
  },

  /**
   * Return a string representing the unaltered value provided to the
   * constructor.
   */
  toString: function () {
    return this.value;
  }
});

/**
 * @api private
 */
module.exports = DynamoDBNumberValue;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/dynamodb/set.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/lib/dynamodb/set.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);
var typeOf = (__webpack_require__(/*! ./types */ "./node_modules/aws-sdk/lib/dynamodb/types.js").typeOf);

/**
 * @api private
 */
var memberTypeToSetType = {
  'String': 'String',
  'Number': 'Number',
  'NumberValue': 'Number',
  'Binary': 'Binary'
};

/**
 * @api private
 */
var DynamoDBSet = util.inherit({

  constructor: function Set(list, options) {
    options = options || {};
    this.wrapperName = 'Set';
    this.initialize(list, options.validate);
  },

  initialize: function(list, validate) {
    var self = this;
    self.values = [].concat(list);
    self.detectType();
    if (validate) {
      self.validate();
    }
  },

  detectType: function() {
    this.type = memberTypeToSetType[typeOf(this.values[0])];
    if (!this.type) {
      throw util.error(new Error(), {
        code: 'InvalidSetType',
        message: 'Sets can contain string, number, or binary values'
      });
    }
  },

  validate: function() {
    var self = this;
    var length = self.values.length;
    var values = self.values;
    for (var i = 0; i < length; i++) {
      if (memberTypeToSetType[typeOf(values[i])] !== self.type) {
        throw util.error(new Error(), {
          code: 'InvalidType',
          message: self.type + ' Set contains ' + typeOf(values[i]) + ' value'
        });
      }
    }
  },

  /**
   * Render the underlying values only when converting to JSON.
   */
  toJSON: function() {
    var self = this;
    return self.values;
  }

});

/**
 * @api private
 */
module.exports = DynamoDBSet;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/dynamodb/translator.js":
/*!*********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/dynamodb/translator.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);
var convert = __webpack_require__(/*! ./converter */ "./node_modules/aws-sdk/lib/dynamodb/converter.js");

var Translator = function(options) {
  options = options || {};
  this.attrValue = options.attrValue;
  this.convertEmptyValues = Boolean(options.convertEmptyValues);
  this.wrapNumbers = Boolean(options.wrapNumbers);
};

Translator.prototype.translateInput = function(value, shape) {
  this.mode = 'input';
  return this.translate(value, shape);
};

Translator.prototype.translateOutput = function(value, shape) {
  this.mode = 'output';
  return this.translate(value, shape);
};

Translator.prototype.translate = function(value, shape) {
  var self = this;
  if (!shape || value === undefined) return undefined;

  if (shape.shape === self.attrValue) {
    return convert[self.mode](value, {
      convertEmptyValues: self.convertEmptyValues,
      wrapNumbers: self.wrapNumbers,
    });
  }
  switch (shape.type) {
    case 'structure': return self.translateStructure(value, shape);
    case 'map': return self.translateMap(value, shape);
    case 'list': return self.translateList(value, shape);
    default: return self.translateScalar(value, shape);
  }
};

Translator.prototype.translateStructure = function(structure, shape) {
  var self = this;
  if (structure == null) return undefined;

  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      var result = self.translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
};

Translator.prototype.translateList = function(list, shape) {
  var self = this;
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = self.translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
};

Translator.prototype.translateMap = function(map, shape) {
  var self = this;
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = self.translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
};

Translator.prototype.translateScalar = function(value, shape) {
  return shape.toType(value);
};

/**
 * @api private
 */
module.exports = Translator;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/dynamodb/types.js":
/*!****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/dynamodb/types.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);

function typeOf(data) {
  if (data === null && typeof data === 'object') {
    return 'null';
  } else if (data !== undefined && isBinary(data)) {
    return 'Binary';
  } else if (data !== undefined && data.constructor) {
    return data.wrapperName || util.typeName(data.constructor);
  } else if (data !== undefined && typeof data === 'object') {
    // this object is the result of Object.create(null), hence the absence of a
    // defined constructor
    return 'Object';
  } else {
    return 'undefined';
  }
}

function isBinary(data) {
  var types = [
    'Buffer', 'File', 'Blob', 'ArrayBuffer', 'DataView',
    'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
    'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array',
    'Float32Array', 'Float64Array'
  ];
  if (util.isNode()) {
    var Stream = util.stream.Stream;
    if (util.Buffer.isBuffer(data) || data instanceof Stream) {
      return true;
    }
  }

  for (var i = 0; i < types.length; i++) {
    if (data !== undefined && data.constructor) {
      if (util.isType(data, types[i])) return true;
      if (util.typeName(data.constructor) === types[i]) return true;
    }
  }

  return false;
}

/**
 * @api private
 */
module.exports = {
  typeOf: typeOf,
  isBinary: isBinary
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eventMessageChunker = (__webpack_require__(/*! ../event-stream/event-message-chunker */ "./node_modules/aws-sdk/lib/event-stream/event-message-chunker.js").eventMessageChunker);
var parseEvent = (__webpack_require__(/*! ./parse-event */ "./node_modules/aws-sdk/lib/event-stream/parse-event.js").parseEvent);

function createEventStream(body, parser, model) {
    var eventMessages = eventMessageChunker(body);

    var events = [];

    for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
    }

    return events;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);
var Transform = (__webpack_require__(/*! stream */ "stream").Transform);
var allocBuffer = util.buffer.alloc;

/** @type {Transform} */
function EventMessageChunkerStream(options) {
    Transform.call(this, options);

    this.currentMessageTotalLength = 0;
    this.currentMessagePendingLength = 0;
    /** @type {Buffer} */
    this.currentMessage = null;

    /** @type {Buffer} */
    this.messageLengthBuffer = null;
}

EventMessageChunkerStream.prototype = Object.create(Transform.prototype);

/**
 *
 * @param {Buffer} chunk
 * @param {string} encoding
 * @param {*} callback
 */
EventMessageChunkerStream.prototype._transform = function(chunk, encoding, callback) {
    var chunkLength = chunk.length;
    var currentOffset = 0;

    while (currentOffset < chunkLength) {
        // create new message if necessary
        if (!this.currentMessage) {
            // working on a new message, determine total length
            var bytesRemaining = chunkLength - currentOffset;
            // prevent edge case where total length spans 2 chunks
            if (!this.messageLengthBuffer) {
                this.messageLengthBuffer = allocBuffer(4);
            }
            var numBytesForTotal = Math.min(
                4 - this.currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer
                bytesRemaining // bytes left in chunk
            );

            chunk.copy(
                this.messageLengthBuffer,
                this.currentMessagePendingLength,
                currentOffset,
                currentOffset + numBytesForTotal
            );

            this.currentMessagePendingLength += numBytesForTotal;
            currentOffset += numBytesForTotal;

            if (this.currentMessagePendingLength < 4) {
                // not enough information to create the current message
                break;
            }
            this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));
            this.messageLengthBuffer = null;
        }

        // write data into current message
        var numBytesToWrite = Math.min(
            this.currentMessageTotalLength - this.currentMessagePendingLength, // number of bytes left to complete message
            chunkLength - currentOffset // number of bytes left in the original chunk
        );
        chunk.copy(
            this.currentMessage, // target buffer
            this.currentMessagePendingLength, // target offset
            currentOffset, // chunk offset
            currentOffset + numBytesToWrite // chunk end to write
        );
        this.currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;

        // check if a message is ready to be pushed
        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {
            // push out the message
            this.push(this.currentMessage);
            // cleanup
            this.currentMessage = null;
            this.currentMessageTotalLength = 0;
            this.currentMessagePendingLength = 0;
        }
    }

    callback();
};

EventMessageChunkerStream.prototype._flush = function(callback) {
    if (this.currentMessageTotalLength) {
        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {
            callback(null, this.currentMessage);
        } else {
            callback(new Error('Truncated event message received.'));
        }
    } else {
        callback();
    }
};

/**
 * @param {number} size Size of the message to be allocated.
 * @api private
 */
EventMessageChunkerStream.prototype.allocateMessage = function(size) {
    if (typeof size !== 'number') {
        throw new Error('Attempted to allocate an event message where size was not a number: ' + size);
    }
    this.currentMessageTotalLength = size;
    this.currentMessagePendingLength = 4;
    this.currentMessage = allocBuffer(size);
    this.currentMessage.writeUInt32BE(size, 0);
};

/**
 * @api private
 */
module.exports = {
    EventMessageChunkerStream: EventMessageChunkerStream
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/event-message-chunker.js":
/*!************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/event-message-chunker.js ***!
  \************************************************************************/
/***/ ((module) => {

/**
 * Takes in a buffer of event messages and splits them into individual messages.
 * @param {Buffer} buffer
 * @api private
 */
function eventMessageChunker(buffer) {
    /** @type Buffer[] */
    var messages = [];
    var offset = 0;

    while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);

        // create new buffer for individual message (shares memory with original)
        var message = buffer.slice(offset, totalLength + offset);
        // increment offset to it starts at the next message
        offset += totalLength;

        messages.push(message);
    }

    return messages;
}

/**
 * @api private
 */
module.exports = {
    eventMessageChunker: eventMessageChunker
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js":
/*!************************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Transform = (__webpack_require__(/*! stream */ "stream").Transform);
var parseEvent = (__webpack_require__(/*! ./parse-event */ "./node_modules/aws-sdk/lib/event-stream/parse-event.js").parseEvent);

/** @type {Transform} */
function EventUnmarshallerStream(options) {
    options = options || {};
    // set output to object mode
    options.readableObjectMode = true;
    Transform.call(this, options);
    this._readableState.objectMode = true;

    this.parser = options.parser;
    this.eventStreamModel = options.eventStreamModel;
}

EventUnmarshallerStream.prototype = Object.create(Transform.prototype);

/**
 *
 * @param {Buffer} chunk
 * @param {string} encoding
 * @param {*} callback
 */
EventUnmarshallerStream.prototype._transform = function(chunk, encoding, callback) {
    try {
        var event = parseEvent(this.parser, chunk, this.eventStreamModel);
        this.push(event);
        return callback();
    } catch (err) {
        callback(err);
    }
};

/**
 * @api private
 */
module.exports = {
    EventUnmarshallerStream: EventUnmarshallerStream
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/int64.js":
/*!********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/int64.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);
var toBuffer = util.buffer.toBuffer;

/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 * @param {Buffer} bytes
 *
 * @api private
 */
function Int64(bytes) {
    if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
    }
    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);

    this.bytes = bytes;
}

/**
 * @param {number} number
 * @returns {Int64}
 *
 * @api private
 */
Int64.fromNumber = function(number) {
    if (number > 9223372036854775807 || number < -9223372036854775808) {
        throw new Error(
            number + ' is too large (or, if negative, too small) to represent as an Int64'
        );
    }

    var bytes = new Uint8Array(8);
    for (
        var i = 7, remaining = Math.abs(Math.round(number));
        i > -1 && remaining > 0;
        i--, remaining /= 256
    ) {
        bytes[i] = remaining;
    }

    if (number < 0) {
        negate(bytes);
    }

    return new Int64(bytes);
};

/**
 * @returns {number}
 *
 * @api private
 */
Int64.prototype.valueOf = function() {
    var bytes = this.bytes.slice(0);
    var negative = bytes[0] & 128;
    if (negative) {
        negate(bytes);
    }

    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
};

Int64.prototype.toString = function() {
    return String(this.valueOf());
};

/**
 * @param {Buffer} bytes
 *
 * @api private
 */
function negate(bytes) {
    for (var i = 0; i < 8; i++) {
        bytes[i] ^= 0xFF;
    }
    for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
            break;
        }
    }
}

/**
 * @api private
 */
module.exports = {
    Int64: Int64
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/parse-event.js":
/*!**************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/parse-event.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parseMessage = (__webpack_require__(/*! ./parse-message */ "./node_modules/aws-sdk/lib/event-stream/parse-message.js").parseMessage);

/**
 *
 * @param {*} parser
 * @param {Buffer} message
 * @param {*} shape
 * @api private
 */
function parseEvent(parser, message, shape) {
    var parsedMessage = parseMessage(message);

    // check if message is an event or error
    var messageType = parsedMessage.headers[':message-type'];
    if (messageType) {
        if (messageType.value === 'error') {
            throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
            // not sure how to parse non-events/non-errors, ignore for now
            return;
        }
    }

    // determine event type
    var eventType = parsedMessage.headers[':event-type'];
    // check that the event type is modeled
    var eventModel = shape.members[eventType.value];
    if (!eventModel) {
        return;
    }

    var result = {};
    // check if an event payload exists
    var eventPayloadMemberName = eventModel.eventPayloadMemberName;
    if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        // if the shape is binary, return the byte array
        if (payloadShape.type === 'binary') {
            result[eventPayloadMemberName] = parsedMessage.body;
        } else {
            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
    }

    // read event headers
    var eventHeaderNames = eventModel.eventHeaderMemberNames;
    for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
            // parse the header!
            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
    }

    var output = {};
    output[eventType.value] = result;
    return output;
}

function parseError(message) {
    var errorCode = message.headers[':error-code'];
    var errorMessage = message.headers[':error-message'];
    var error = new Error(errorMessage.value || errorMessage);
    error.code = error.name = errorCode.value || errorCode;
    return error;
}

/**
 * @api private
 */
module.exports = {
    parseEvent: parseEvent
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/parse-message.js":
/*!****************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/parse-message.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Int64 = (__webpack_require__(/*! ./int64 */ "./node_modules/aws-sdk/lib/event-stream/int64.js").Int64);

var splitMessage = (__webpack_require__(/*! ./split-message */ "./node_modules/aws-sdk/lib/event-stream/split-message.js").splitMessage);

var BOOLEAN_TAG = 'boolean';
var BYTE_TAG = 'byte';
var SHORT_TAG = 'short';
var INT_TAG = 'integer';
var LONG_TAG = 'long';
var BINARY_TAG = 'binary';
var STRING_TAG = 'string';
var TIMESTAMP_TAG = 'timestamp';
var UUID_TAG = 'uuid';

/**
 * @api private
 *
 * @param {Buffer} headers
 */
function parseHeaders(headers) {
    var out = {};
    var position = 0;
    while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
            case 0 /* boolTrue */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: true
                };
                break;
            case 1 /* boolFalse */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: false
                };
                break;
            case 2 /* byte */:
                out[name] = {
                    type: BYTE_TAG,
                    value: headers.readInt8(position++)
                };
                break;
            case 3 /* short */:
                out[name] = {
                    type: SHORT_TAG,
                    value: headers.readInt16BE(position)
                };
                position += 2;
                break;
            case 4 /* integer */:
                out[name] = {
                    type: INT_TAG,
                    value: headers.readInt32BE(position)
                };
                position += 4;
                break;
            case 5 /* long */:
                out[name] = {
                    type: LONG_TAG,
                    value: new Int64(headers.slice(position, position + 8))
                };
                position += 8;
                break;
            case 6 /* byteArray */:
                var binaryLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: BINARY_TAG,
                    value: headers.slice(position, position + binaryLength)
                };
                position += binaryLength;
                break;
            case 7 /* string */:
                var stringLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: STRING_TAG,
                    value: headers.slice(
                        position,
                        position + stringLength
                    ).toString()
                };
                position += stringLength;
                break;
            case 8 /* timestamp */:
                out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(
                        new Int64(headers.slice(position, position + 8))
                            .valueOf()
                    )
                };
                position += 8;
                break;
            case 9 /* uuid */:
                var uuidChars = headers.slice(position, position + 16)
                    .toString('hex');
                position += 16;
                out[name] = {
                    type: UUID_TAG,
                    value: uuidChars.substr(0, 8) + '-' +
                        uuidChars.substr(8, 4) + '-' +
                        uuidChars.substr(12, 4) + '-' +
                        uuidChars.substr(16, 4) + '-' +
                        uuidChars.substr(20)
                };
                break;
            default:
                throw new Error('Unrecognized header type tag');
        }
    }
    return out;
}

function parseMessage(message) {
    var parsed = splitMessage(message);
    return { headers: parseHeaders(parsed.headers), body: parsed.body };
}

/**
 * @api private
 */
module.exports = {
    parseMessage: parseMessage
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/split-message.js":
/*!****************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/split-message.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);
var toBuffer = util.buffer.toBuffer;

// All prelude components are unsigned, 32-bit integers
var PRELUDE_MEMBER_LENGTH = 4;
// The prelude consists of two components
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
// Checksums are always CRC32 hashes.
var CHECKSUM_LENGTH = 4;
// Messages must include a full prelude, a prelude checksum, and a message checksum
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

/**
 * @api private
 *
 * @param {Buffer} message
 */
function splitMessage(message) {
    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

    if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
    }

    if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
    }

    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

    if (
        expectedPreludeChecksum !== util.crypto.crc32(
            message.slice(0, PRELUDE_LENGTH)
        )
    ) {
        throw new Error(
            'The prelude checksum specified in the message (' +
            expectedPreludeChecksum +
            ') does not match the calculated CRC32 checksum.'
        );
    }

    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

    if (
        expectedMessageChecksum !== util.crypto.crc32(
            message.slice(0, message.length - CHECKSUM_LENGTH)
        )
    ) {
        throw new Error(
            'The message checksum did not match the expected value of ' +
                expectedMessageChecksum
        );
    }

    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);

    return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
    };
}

/**
 * @api private
 */
module.exports = {
    splitMessage: splitMessage
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js":
/*!********************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * What is necessary to create an event stream in node?
 *  - http response stream
 *  - parser
 *  - event stream model
 */

var EventMessageChunkerStream = (__webpack_require__(/*! ../event-stream/event-message-chunker-stream */ "./node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js").EventMessageChunkerStream);
var EventUnmarshallerStream = (__webpack_require__(/*! ../event-stream/event-message-unmarshaller-stream */ "./node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js").EventUnmarshallerStream);

function createEventStream(stream, parser, model) {
    var eventStream = new EventUnmarshallerStream({
        parser: parser,
        eventStreamModel: model
    });

    var eventMessageChunker = new EventMessageChunkerStream();

    stream.pipe(
        eventMessageChunker
    ).pipe(eventStream);

    stream.on('error', function(err) {
        eventMessageChunker.emit('error', err);
    });

    eventMessageChunker.on('error', function(err) {
        eventStream.emit('error', err);
    });

    return eventStream;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/event_listeners.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/event_listeners.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var SequentialExecutor = __webpack_require__(/*! ./sequential_executor */ "./node_modules/aws-sdk/lib/sequential_executor.js");
var DISCOVER_ENDPOINT = (__webpack_require__(/*! ./discover_endpoint */ "./node_modules/aws-sdk/lib/discover_endpoint.js").discoverEndpoint);
/**
 * The namespace used to register global event listeners for request building
 * and sending.
 */
AWS.EventListeners = {
  /**
   * @!attribute VALIDATE_CREDENTIALS
   *   A request listener that validates whether the request is being
   *   sent with credentials.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating credentials
   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_REGION
   *   A request listener that validates whether the region is set
   *   for a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating region configuration
   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_PARAMETERS
   *   A request listener that validates input parameters in a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating parameters
   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
   *     request.removeListener('validate', listener);
   *   @example Disable parameter validation globally
   *     AWS.EventListeners.Core.removeListener('validate',
   *       AWS.EventListeners.Core.VALIDATE_REGION);
   *   @readonly
   *   @return [Function]
   * @!attribute SEND
   *   A request listener that initiates the HTTP connection for a
   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
   *   @example Replacing the HTTP handler
   *     var listener = AWS.EventListeners.Core.SEND;
   *     request.removeListener('send', listener);
   *     request.on('send', function(response) {
   *       customHandler.send(response);
   *     });
   *   @return [Function]
   *   @readonly
   * @!attribute HTTP_DATA
   *   A request listener that reads data from the HTTP connection in order
   *   to build the response data.
   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
   *   Remove this handler if you are overriding the 'httpData' event and
   *   do not want extra data processing and buffering overhead.
   *   @example Disabling default data processing
   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
   *     request.removeListener('httpData', listener);
   *   @return [Function]
   *   @readonly
   */
  Core: {} /* doc hack */
};

/**
 * @api private
 */
function getOperationAuthtype(req) {
  if (!req.service.api.operations) {
    return '';
  }
  var operation = req.service.api.operations[req.operation];
  return operation ? operation.authtype : '';
}

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.isGlobalEndpoint) {
        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!req.service.config.region) {
          req.response.error = AWS.util.error(new Error(),
            {code: 'ConfigError', message: 'Missing region in config'});
        } else if (!dnsHostRegex.test(req.service.config.region)) {
          req.response.error = AWS.util.error(new Error(),
            {code: 'ConfigError', message: 'Invalid region in config'});
        }
      }
    });

    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var idempotentMembers = operation.idempotentMembers;
      if (!idempotentMembers.length) {
        return;
      }
      // creates a copy of params so user's param object isn't mutated
      var params = AWS.util.copy(req.params);
      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
        if (!params[idempotentMembers[i]]) {
          // add the member
          params[idempotentMembers[i]] = AWS.util.uuid.v4();
        }
      }
      req.params = params;
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    add('COMPUTE_CHECKSUM', 'afterBuild', function COMPUTE_CHECKSUM(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var body = req.httpRequest.body;
      var isNonStreamingPayload = body && (AWS.util.Buffer.isBuffer(body) || typeof body === 'string');
      var headers = req.httpRequest.headers;
      if (
        operation.httpChecksumRequired &&
        req.service.config.computeChecksums &&
        isNonStreamingPayload &&
        !headers['Content-MD5']
      ) {
        var md5 = AWS.util.crypto.md5(body, 'base64');
        headers['Content-MD5'] = md5;
      }
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        if (authtype.indexOf('unsigned-body') >= 0) {
          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
          return done();
        }
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      var authtype = getOperationAuthtype(req);
      var payloadMember = AWS.util.getRequestPayloadShape(req);
      if (req.httpRequest.headers['Content-Length'] === undefined) {
        try {
          var length = AWS.util.string.byteLength(req.httpRequest.body);
          req.httpRequest.headers['Content-Length'] = length;
        } catch (err) {
          if (payloadMember && payloadMember.isStreaming) {
            if (payloadMember.requiresLength) {
              //streaming payload requires length(s3, glacier)
              throw err;
            } else if (authtype.indexOf('unsigned-body') >= 0) {
              //unbounded streaming payload(lex, mediastore)
              req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
              return;
            } else {
              throw err;
            }
          }
          throw err;
        }
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    var addToHead = true;
    addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      var operations = req.service.api.operations || {};
      var operation = operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

      service.config.getCredentials(function (err, credentials) {
        if (err) {
          req.response.error = err;
          return done();
        }

        try {
          var date = service.getSkewCorrectedDate();
          var SignerClass = service.getSignerClass(req);
          var signer = new SignerClass(req.httpRequest,
            service.getSigningName(req),
            {
              signatureCache: service.config.signatureCache,
              operation: operation,
              signatureVersion: service.api.signatureVersion
            });
          signer.setServiceClientId(service._clientId);

          // clear old authorization headers
          delete req.httpRequest.headers['Authorization'];
          delete req.httpRequest.headers['Date'];
          delete req.httpRequest.headers['X-Amz-Date'];

          // add new authorization
          signer.addAuthorization(credentials, date);
          req.signedAt = date;
        } catch (e) {
          req.response.error = e;
        }
        done();
      });
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;
        var stream = resp.request.httpRequest.stream;
        var service = resp.request.service;
        var api = service.api;
        var operationName = resp.request.operation;
        var operation = api.operations[operationName] || {};

        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
          resp.request.emit(
            'httpHeaders',
            [statusCode, headers, resp, statusMessage]
          );

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              // if we detect event streams, we're going to have to
              // return the stream immediately
              if (operation.hasEventOutput && service.successfulResponse(resp)) {
                // skip reading the IncomingStream
                resp.request.emit('httpDone');
                done();
                return;
              }

              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          if (!stream || !stream.didCallback) {
            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
              // don't concatenate response chunks when streaming event stream data when response is successful
              return;
            }
            resp.request.emit('httpDone');
            done();
          }
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        if (err.code !== 'RequestAbortedError') {
          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
          err = AWS.util.error(err, {
            code: errCode,
            region: resp.request.httpRequest.region,
            hostname: resp.request.httpRequest.endpoint.hostname,
            retryable: true
          });
        }
        resp.error = err;
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }
      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.statusMessage = statusMessage;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = AWS.util.buffer.toBuffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      var service = resp.request.service;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (service.config.correctClockSkew
            && service.isClockSkewed(serverTime)) {
          service.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      // convert buffers array into single buffer
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      // delay < 0 is a signal from customBackoff to skip retries
      if (willRetry && delay >= 0) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      function isDNSError(err) {
        return err.errno === 'ENOTFOUND' ||
          typeof err.errno === 'number' &&
          typeof AWS.util.getSystemErrorName === 'function' &&
          ['EAI_NONAME', 'EAI_NODATA'].indexOf(AWS.util.getSystemErrorName(err.errno) >= 0);
      }
      if (err.code === 'NetworkingError' && isDNSError(err)) {
        var message = 'Inaccessible host: `' + err.hostname + '\' at port `' + err.port +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;
      function filterSensitiveLog(inputShape, shape) {
        if (!shape) {
          return shape;
        }
        if (inputShape.isSensitive) {
          return '***SensitiveInformation***';
        }
        switch (inputShape.type) {
          case 'structure':
            var struct = {};
            AWS.util.each(shape, function(subShapeName, subShape) {
              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
              } else {
                struct[subShapeName] = subShape;
              }
            });
            return struct;
          case 'list':
            var list = [];
            AWS.util.arrayEach(shape, function(subShape, index) {
              list.push(filterSensitiveLog(inputShape.member, subShape));
            });
            return list;
          case 'map':
            var map = {};
            AWS.util.each(shape, function(key, value) {
              map[key] = filterSensitiveLog(inputShape.value, value);
            });
            return map;
          default:
            return shape;
        }
      }

      function buildMessage() {
        var time = resp.request.service.getSkewCorrectedDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var censoredParams = req.params;
        if (
          req.service.api.operations &&
              req.service.api.operations[req.operation] &&
              req.service.api.operations[req.operation].input
        ) {
          var inputShape = req.service.api.operations[req.operation].input;
          censoredParams = filterSensitiveLog(inputShape, req.params);
        }
        var params = (__webpack_require__(/*! util */ "util").inspect)(censoredParams, true, null);
        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/json */ "./node_modules/aws-sdk/lib/protocol/json.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/rest */ "./node_modules/aws-sdk/lib/protocol/rest.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/rest_json */ "./node_modules/aws-sdk/lib/protocol/rest_json.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/rest_xml */ "./node_modules/aws-sdk/lib/protocol/rest_xml.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(/*! ./protocol/query */ "./node_modules/aws-sdk/lib/protocol/query.js");
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/http.js":
/*!******************************************!*\
  !*** ./node_modules/aws-sdk/lib/http.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * The endpoint that a service will talk to, for example,
 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
 * you need to override an endpoint for a service, you can
 * set the endpoint on a service by passing the endpoint
 * object with the `endpoint` option key:
 *
 * ```javascript
 * var ep = new AWS.Endpoint('awsproxy.example.com');
 * var s3 = new AWS.S3({endpoint: ep});
 * s3.service.endpoint.hostname == 'awsproxy.example.com'
 * ```
 *
 * Note that if you do not specify a protocol, the protocol will
 * be selected based on your current {AWS.config} configuration.
 *
 * @!attribute protocol
 *   @return [String] the protocol (http or https) of the endpoint
 *     URL
 * @!attribute hostname
 *   @return [String] the host portion of the endpoint, e.g.,
 *     example.com
 * @!attribute host
 *   @return [String] the host portion of the endpoint including
 *     the port, e.g., example.com:80
 * @!attribute port
 *   @return [Integer] the port of the endpoint
 * @!attribute href
 *   @return [String] the full URL of the endpoint
 */
AWS.Endpoint = inherit({

  /**
   * @overload Endpoint(endpoint)
   *   Constructs a new endpoint given an endpoint URL. If the
   *   URL omits a protocol (http or https), the default protocol
   *   set in the global {AWS.config} will be used.
   *   @param endpoint [String] the URL to construct an endpoint from
   */
  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    // Ensure the port property is set as an integer
    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});

/**
 * The low level HTTP request object, encapsulating all HTTP header
 * and body data sent by a service request.
 *
 * @!attribute method
 *   @return [String] the HTTP method of the request
 * @!attribute path
 *   @return [String] the path portion of the URI, e.g.,
 *     "/list/?start=5&num=10"
 * @!attribute headers
 *   @return [map<String,String>]
 *     a map of header keys and their respective values
 * @!attribute body
 *   @return [String] the request body payload
 * @!attribute endpoint
 *   @return [AWS.Endpoint] the endpoint for the request
 * @!attribute region
 *   @api private
 *   @return [String] the region, for signing purposes only.
 */
AWS.HttpRequest = inherit({

  /**
   * @api private
   */
  constructor: function HttpRequest(endpoint, region) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this._userAgent = '';
    this.setUserAgent();
  },

  /**
   * @api private
   */
  setUserAgent: function setUserAgent() {
    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
  },

  getUserAgentHeaderName: function getUserAgentHeaderName() {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    return prefix + 'User-Agent';
  },

  /**
   * @api private
   */
  appendToUserAgent: function appendToUserAgent(agentPartial) {
    if (typeof agentPartial === 'string' && agentPartial) {
      this._userAgent += ' ' + agentPartial;
    }
    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
  },

  /**
   * @api private
   */
  getUserAgent: function getUserAgent() {
    return this._userAgent;
  },

  /**
   * @return [String] the part of the {path} excluding the
   *   query string
   */
  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },

  /**
   * @return [String] the query string portion of the {path}
   */
  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  },

  /**
   * @api private
   * update httpRequest endpoint with endpoint string
   */
  updateEndpoint: function updateEndpoint(endpointStr) {
    var newEndpoint = new AWS.Endpoint(endpointStr);
    this.endpoint = newEndpoint;
    this.path = newEndpoint.path || '/';
    if (this.headers['Host']) {
      this.headers['Host'] = newEndpoint.host;
    }
  }
});

/**
 * The low level HTTP response object, encapsulating all HTTP header
 * and body data returned from the request.
 *
 * @!attribute statusCode
 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
 * @!attribute headers
 *   @return [map<String,String>]
 *      a map of response header keys and their respective values
 * @!attribute body
 *   @return [String] the response body payload
 * @!attribute [r] streaming
 *   @return [Boolean] whether this response is being streamed at a low-level.
 *     Defaults to `false` (buffered reads). Do not modify this manually, use
 *     {createUnbufferedStream} to convert the stream to unbuffered mode
 *     instead.
 */
AWS.HttpResponse = inherit({

  /**
   * @api private
   */
  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },

  /**
   * Disables buffering on the HTTP response and returns the stream for reading.
   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
   *   Use this object to directly read data off of the stream.
   * @note This object is only available after the {AWS.Request~httpHeaders}
   *   event has fired. This method must be called prior to
   *   {AWS.Request~httpData}.
   * @example Taking control of a stream
   *   request.on('httpHeaders', function(statusCode, headers) {
   *     if (statusCode < 300) {
   *       if (headers.etag === 'xyz') {
   *         // pipe the stream, disabling buffering
   *         var stream = this.response.httpResponse.createUnbufferedStream();
   *         stream.pipe(process.stdout);
   *       } else { // abort this request and set a better error message
   *         this.abort();
   *         this.response.error = new Error('Invalid ETag');
   *       }
   *     }
   *   }).send(console.log);
   */
  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});

/**
 * @api private
 */
AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/http/node.js":
/*!***********************************************!*\
  !*** ./node_modules/aws-sdk/lib/http/node.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var Stream = AWS.util.stream.Stream;
var TransformStream = AWS.util.stream.Transform;
var ReadableStream = AWS.util.stream.Readable;
__webpack_require__(/*! ../http */ "./node_modules/aws-sdk/lib/http.js");
var CONNECTION_REUSE_ENV_NAME = 'AWS_NODEJS_CONNECTION_REUSE_ENABLED';

/**
 * @api private
 */
AWS.NodeHttpClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var pathPrefix = '';
    if (!httpOptions) httpOptions = {};
    if (httpOptions.proxy) {
      pathPrefix = endpoint.protocol + '//' + endpoint.hostname;
      if (endpoint.port !== 80 && endpoint.port !== 443) {
        pathPrefix += ':' + endpoint.port;
      }
      endpoint = new AWS.Endpoint(httpOptions.proxy);
    }

    var useSSL = endpoint.protocol === 'https:';
    var http = useSSL ? __webpack_require__(/*! https */ "https") : __webpack_require__(/*! http */ "http");
    var options = {
      host: endpoint.hostname,
      port: endpoint.port,
      method: httpRequest.method,
      headers: httpRequest.headers,
      path: pathPrefix + httpRequest.path
    };

    if (!httpOptions.agent) {
      options.agent = this.getAgent(useSSL, {
        keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === '1' ? true : false
      });
    }

    AWS.util.update(options, httpOptions);
    delete options.proxy; // proxy isn't an HTTP option
    delete options.timeout; // timeout isn't an HTTP option

    var stream = http.request(options, function (httpResp) {
      if (stream.didCallback) return;

      callback(httpResp);
      httpResp.emit(
        'headers',
        httpResp.statusCode,
        httpResp.headers,
        httpResp.statusMessage
      );
    });
    httpRequest.stream = stream; // attach stream to httpRequest
    stream.didCallback = false;

    // connection timeout support
    if (httpOptions.connectTimeout) {
      var connectTimeoutId;
      stream.on('socket', function(socket) {
        if (socket.connecting) {
          connectTimeoutId = setTimeout(function connectTimeout() {
            if (stream.didCallback) return; stream.didCallback = true;

            stream.abort();
            errCallback(AWS.util.error(
              new Error('Socket timed out without establishing a connection'),
              {code: 'TimeoutError'}
            ));
          }, httpOptions.connectTimeout);
          socket.on('connect', function() {
            clearTimeout(connectTimeoutId);
            connectTimeoutId = null;
          });
        }
      });
    }

    // timeout support
    stream.setTimeout(httpOptions.timeout || 0, function() {
      if (stream.didCallback) return; stream.didCallback = true;

      var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';
      errCallback(AWS.util.error(new Error(msg), {code: 'TimeoutError'}));
      stream.abort();
    });

    stream.on('error', function(err) {
      if (connectTimeoutId) {
        clearTimeout(connectTimeoutId);
        connectTimeoutId = null;
      }
      if (stream.didCallback) return; stream.didCallback = true;
      if ('ECONNRESET' === err.code || 'EPIPE' === err.code || 'ETIMEDOUT' === err.code) {
        errCallback(AWS.util.error(err, {code: 'TimeoutError'}));
      } else {
        errCallback(err);
      }
    });

    var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
    if (expect === '100-continue') {
      stream.once('continue', function() {
        self.writeBody(stream, httpRequest);
      });
    } else {
      this.writeBody(stream, httpRequest);
    }

    return stream;
  },

  writeBody: function writeBody(stream, httpRequest) {
    var body = httpRequest.body;
    var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);

    if (body instanceof Stream) {
      // For progress support of streaming content -
      // pipe the data through a transform stream to emit 'sendProgress' events
      var progressStream = this.progressStream(stream, totalBytes);
      if (progressStream) {
        body.pipe(progressStream).pipe(stream);
      } else {
        body.pipe(stream);
      }
    } else if (body) {
      // The provided body is a buffer/string and is already fully available in memory -
      // For performance it's best to send it as a whole by calling stream.end(body),
      // Callers expect a 'sendProgress' event which is best emitted once
      // the http request stream has been fully written and all data flushed.
      // The use of totalBytes is important over body.length for strings where
      // length is char length and not byte length.
      stream.once('finish', function() {
        stream.emit('sendProgress', {
          loaded: totalBytes,
          total: totalBytes
        });
      });
      stream.end(body);
    } else {
      // no request body
      stream.end();
    }
  },

  /**
   * Create the https.Agent or http.Agent according to the request schema.
   */
  getAgent: function getAgent(useSSL, agentOptions) {
    var http = useSSL ? __webpack_require__(/*! https */ "https") : __webpack_require__(/*! http */ "http");
    if (useSSL) {
      if (!AWS.NodeHttpClient.sslAgent) {
        AWS.NodeHttpClient.sslAgent = new http.Agent(AWS.util.merge({
          rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0' ? false : true
        }, agentOptions || {}));
        AWS.NodeHttpClient.sslAgent.setMaxListeners(0);

        // delegate maxSockets to globalAgent, set a default limit of 50 if current value is Infinity.
        // Users can bypass this default by supplying their own Agent as part of SDK configuration.
        Object.defineProperty(AWS.NodeHttpClient.sslAgent, 'maxSockets', {
          enumerable: true,
          get: function() {
            var defaultMaxSockets = 50;
            var globalAgent = http.globalAgent;
            if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {
              return globalAgent.maxSockets;
            }
            return defaultMaxSockets;
          }
        });
      }
      return AWS.NodeHttpClient.sslAgent;
    } else {
      if (!AWS.NodeHttpClient.agent) {
        AWS.NodeHttpClient.agent = new http.Agent(agentOptions);
      }
      return AWS.NodeHttpClient.agent;
    }
  },

  progressStream: function progressStream(stream, totalBytes) {
    if (typeof TransformStream === 'undefined') {
      // for node 0.8 there is no streaming progress
      return;
    }
    var loadedBytes = 0;
    var reporter = new TransformStream();
    reporter._transform = function(chunk, encoding, callback) {
      if (chunk) {
        loadedBytes += chunk.length;
        stream.emit('sendProgress', {
          loaded: loadedBytes,
          total: totalBytes
        });
      }
      callback(null, chunk);
    };
    return reporter;
  },

  emitter: null
});

/**
 * @!ignore
 */

/**
 * @api private
 */
AWS.HttpClient.prototype = AWS.NodeHttpClient.prototype;

/**
 * @api private
 */
AWS.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/json/builder.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/lib/json/builder.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (shape.isDocument) {
    return structure;
  }
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

/**
 * @api private
 */
module.exports = JsonBuilder;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/json/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-sdk/lib/json/parser.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;
  if (shape.isDocument) return structure;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

/**
 * @api private
 */
module.exports = JsonParser;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/metadata_service.js":
/*!******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/metadata_service.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ./http */ "./node_modules/aws-sdk/lib/http.js");
var inherit = AWS.util.inherit;
var getMetadataServiceEndpoint = __webpack_require__(/*! ./metadata_service/get_metadata_service_endpoint */ "./node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js");
var URL = (__webpack_require__(/*! url */ "url").URL);

/**
 * Represents a metadata service available on EC2 instances. Using the
 * {request} method, you can receieve metadata about any available resource
 * on the metadata service.
 *
 * You can disable the use of the IMDS by setting the AWS_EC2_METADATA_DISABLED
 * environment variable to a truthy value.
 *
 * @!attribute [r] httpOptions
 *   @return [map] a map of options to pass to the underlying HTTP request:
 *
 *     * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
 *       before aborting the connection. Set to 0 for no timeout.
 *
 * @!macro nobrowser
 */
AWS.MetadataService = inherit({
  /**
   * @return [String] the endpoint of the instance metadata service
   */
  endpoint: getMetadataServiceEndpoint(),

  /**
   * @!ignore
   */

  /**
   * Default HTTP options. By default, the metadata service is set to not
   * timeout on long requests. This means that on non-EC2 machines, this
   * request will never return. If you are calling this operation from an
   * environment that may not always run on EC2, set a `timeout` value so
   * the SDK will abort the request after a given number of milliseconds.
   */
  httpOptions: { timeout: 0 },

  /**
   * when enabled, metadata service will not fetch token
   */
  disableFetchToken: false,

  /**
   * Creates a new MetadataService object with a given set of options.
   *
   * @option options host [String] the hostname of the instance metadata
   *   service
   * @option options httpOptions [map] a map of options to pass to the
   *   underlying HTTP request:
   *
   *   * **timeout** (Number) &mdash; a timeout value in milliseconds to wait
   *     before aborting the connection. Set to 0 for no timeout.
   * @option options maxRetries [Integer] the maximum number of retries to
   *   perform for timeout errors
   * @option options retryDelayOptions [map] A set of options to configure the
   *   retry delay on retryable errors. See AWS.Config for details.
   */
  constructor: function MetadataService(options) {
    if (options && options.host) {
      options.endpoint = 'http://' + options.host;
      delete options.host;
    }
    AWS.util.update(this, options);
  },

  /**
   * Sends a request to the instance metadata service for a given resource.
   *
   * @param path [String] the path of the resource to get
   *
   * @param options [map] an optional map used to make request
   *
   *   * **method** (String) &mdash; HTTP request method
   *
   *   * **headers** (map<String,String>) &mdash; a map of response header keys and their respective values
   *
   * @callback callback function(err, data)
   *   Called when a response is available from the service.
   *   @param err [Error, null] if an error occurred, this value will be set
   *   @param data [String, null] if the request was successful, the body of
   *     the response
   */
  request: function request(path, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }

    if (process.env[AWS.util.imdsDisabledEnv]) {
      callback(new Error('EC2 Instance Metadata Service access disabled'));
      return;
    }

    path = path || '/';

    // Verify that host is a valid URL
    if (URL) { new URL(this.endpoint); }

    var httpRequest = new AWS.HttpRequest(this.endpoint + path);
    httpRequest.method = options.method || 'GET';
    if (options.headers) {
      httpRequest.headers = options.headers;
    }
    AWS.util.handleRequestWithRetries(httpRequest, this, callback);
  },

  /**
  * @api private
  */
  loadCredentialsCallbacks: [],

  /**
   * Fetches metadata token used for getting credentials
   *
   * @api private
   * @callback callback function(err, token)
   *   Called when token is loaded from the resource
   */
  fetchMetadataToken: function fetchMetadataToken(callback) {
    var self = this;
    var tokenFetchPath = '/latest/api/token';
    self.request(
      tokenFetchPath,
      {
        'method': 'PUT',
        'headers': {
          'x-aws-ec2-metadata-token-ttl-seconds': '21600'
        }
      },
      callback
    );
  },

  /**
   * Fetches credentials
   *
   * @api private
   * @callback cb function(err, creds)
   *   Called when credentials are loaded from the resource
   */
  fetchCredentials: function fetchCredentials(options, cb) {
    var self = this;
    var basePath = '/latest/meta-data/iam/security-credentials/';

    self.request(basePath, options, function (err, roleName) {
      if (err) {
        self.disableFetchToken = !(err.statusCode === 401);
        cb(AWS.util.error(
          err,
          {
            message: 'EC2 Metadata roleName request returned error'
          }
        ));
        return;
      }
      roleName = roleName.split('\n')[0]; // grab first (and only) role
      self.request(basePath + roleName, options, function (credErr, credData) {
        if (credErr) {
          self.disableFetchToken = !(credErr.statusCode === 401);
          cb(AWS.util.error(
            credErr,
            {
              message: 'EC2 Metadata creds request returned error'
            }
          ));
          return;
        }
        try {
          var credentials = JSON.parse(credData);
          cb(null, credentials);
        } catch (parseError) {
          cb(parseError);
        }
      });
    });
  },

  /**
   * Loads a set of credentials stored in the instance metadata service
   *
   * @api private
   * @callback callback function(err, credentials)
   *   Called when credentials are loaded from the resource
   *   @param err [Error] if an error occurred, this value will be set
   *   @param credentials [Object] the raw JSON object containing all
   *     metadata from the credentials resource
   */
  loadCredentials: function loadCredentials(callback) {
    var self = this;
    self.loadCredentialsCallbacks.push(callback);
    if (self.loadCredentialsCallbacks.length > 1) { return; }

    function callbacks(err, creds) {
      var cb;
      while ((cb = self.loadCredentialsCallbacks.shift()) !== undefined) {
        cb(err, creds);
      }
    }

    if (self.disableFetchToken) {
      self.fetchCredentials({}, callbacks);
    } else {
      self.fetchMetadataToken(function(tokenError, token) {
        if (tokenError) {
          if (tokenError.code === 'TimeoutError') {
            self.disableFetchToken = true;
          } else if (tokenError.retryable === true) {
            callbacks(AWS.util.error(
              tokenError,
              {
                message: 'EC2 Metadata token request returned error'
              }
            ));
            return;
          } else if (tokenError.statusCode === 400) {
            callbacks(AWS.util.error(
              tokenError,
              {
                message: 'EC2 Metadata token request returned 400'
              }
            ));
            return;
          }
        }
        var options = {};
        if (token) {
          options.headers = {
            'x-aws-ec2-metadata-token': token
          };
        }
        self.fetchCredentials(options, callbacks);
      });

    }
  }
});

/**
 * @api private
 */
module.exports = AWS.MetadataService;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint.js":
/*!*******************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/metadata_service/get_endpoint.js ***!
  \*******************************************************************/
/***/ ((module) => {

var getEndpoint = function() {
  return {
    IPv4: 'http://169.254.169.254',
    IPv6: 'http://[fd00:ec2::254]',
  };
};

module.exports = getEndpoint;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js ***!
  \**********************************************************************************/
/***/ ((module) => {

var ENV_ENDPOINT_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT';
var CONFIG_ENDPOINT_NAME = 'ec2_metadata_service_endpoint';

var getEndpointConfigOptions = function() {
  return {
    environmentVariableSelector: function(env) { return env[ENV_ENDPOINT_NAME]; },
    configFileSelector: function(profile) { return profile[CONFIG_ENDPOINT_NAME]; },
    default: undefined,
  };
};

module.exports = getEndpointConfigOptions;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js":
/*!************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js ***!
  \************************************************************************/
/***/ ((module) => {

var getEndpointMode = function() {
  return {
    IPv4: 'IPv4',
    IPv6: 'IPv6',
  };
};

module.exports = getEndpointMode;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EndpointMode = __webpack_require__(/*! ./get_endpoint_mode */ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js")();

var ENV_ENDPOINT_MODE_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE';
var CONFIG_ENDPOINT_MODE_NAME = 'ec2_metadata_service_endpoint_mode';

var getEndpointModeConfigOptions = function() {
  return {
    environmentVariableSelector: function(env) { return env[ENV_ENDPOINT_MODE_NAME]; },
    configFileSelector: function(profile) { return profile[CONFIG_ENDPOINT_MODE_NAME]; },
    default: EndpointMode.IPv4,
  };
};

module.exports = getEndpointModeConfigOptions;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js":
/*!************************************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

var Endpoint = __webpack_require__(/*! ./get_endpoint */ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint.js")();
var EndpointMode = __webpack_require__(/*! ./get_endpoint_mode */ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js")();

var ENDPOINT_CONFIG_OPTIONS = __webpack_require__(/*! ./get_endpoint_config_options */ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js")();
var ENDPOINT_MODE_CONFIG_OPTIONS = __webpack_require__(/*! ./get_endpoint_mode_config_options */ "./node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js")();

var getMetadataServiceEndpoint = function() {
  var endpoint = AWS.util.loadConfig(ENDPOINT_CONFIG_OPTIONS);
  if (endpoint !== undefined) return endpoint;

  var endpointMode = AWS.util.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS);
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint.IPv4;
    case EndpointMode.IPv6:
      return Endpoint.IPv6;
    default:
      throw new Error('Unsupported endpoint mode: ' + endpointMode);
  }
};

module.exports = getMetadataServiceEndpoint;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/model/api.js":
/*!***********************************************!*\
  !*** ./node_modules/aws-sdk/lib/model/api.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Collection = __webpack_require__(/*! ./collection */ "./node_modules/aws-sdk/lib/model/collection.js");
var Operation = __webpack_require__(/*! ./operation */ "./node_modules/aws-sdk/lib/model/operation.js");
var Shape = __webpack_require__(/*! ./shape */ "./node_modules/aws-sdk/lib/model/shape.js");
var Paginator = __webpack_require__(/*! ./paginator */ "./node_modules/aws-sdk/lib/model/paginator.js");
var ResourceWaiter = __webpack_require__(/*! ./resource_waiter */ "./node_modules/aws-sdk/lib/model/resource_waiter.js");
var metadata = __webpack_require__(/*! ../../apis/metadata.json */ "./node_modules/aws-sdk/apis/metadata.json");

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  var self = this;
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  var serviceIdentifier = options.serviceIdentifier;
  delete options.serviceIdentifier;

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);
  property(this, 'serviceId', api.metadata.serviceId);
  if (serviceIdentifier && metadata[serviceIdentifier]) {
      property(this, 'xmlNoDefaultLists', metadata[serviceIdentifier].xmlNoDefaultLists, false);
  }

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  function addEndpointOperation(name, operation) {
    if (operation.endpointoperation === true) {
      property(self, 'endpointOperation', util.string.lowerFirst(name));
    }
    if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
      property(
        self,
        'hasRequiredEndpointDiscovery',
        operation.endpointdiscovery.required === true
      );
    }
  }

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst, addEndpointOperation));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
}

/**
 * @api private
 */
module.exports = Api;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/model/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/model/collection.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizedProperty = (__webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js").memoizedProperty);

function memoize(name, value, factory, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return factory(name, value);
  });
}

function Collection(iterable, options, factory, nameTr, callback) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], factory, nameTr);
      if (callback) callback(id, iterable[id]);
    }
  }
}

/**
 * @api private
 */
module.exports = Collection;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/model/operation.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/model/operation.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Shape = __webpack_require__(/*! ./shape */ "./node_modules/aws-sdk/lib/model/shape.js");

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  var self = this;
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'endpoint', operation.endpoint);
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');
  property(
    this,
    'endpointDiscoveryRequired',
    operation.endpointdiscovery ?
      (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') :
    'NULL'
  );
  property(this, 'httpChecksumRequired', operation.httpChecksumRequired, false);

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }

  // idempotentMembers only tracks top-level input shapes
  memoizedProperty(this, 'idempotentMembers', function() {
    var idempotentMembers = [];
    var input = self.input;
    var members = input.members;
    if (!input.members) {
      return idempotentMembers;
    }
    for (var name in members) {
      if (!members.hasOwnProperty(name)) {
        continue;
      }
      if (members[name].isIdempotent === true) {
        idempotentMembers.push(name);
      }
    }
    return idempotentMembers;
  });

  memoizedProperty(this, 'hasEventOutput', function() {
    var output = self.output;
    return hasEventStream(output);
  });
}

function hasEventStream(topLevelShape) {
  var members = topLevelShape.members;
  var payload = topLevelShape.payload;

  if (!topLevelShape.members) {
    return false;
  }

  if (payload) {
    var payloadMember = members[payload];
    return payloadMember.isEventStream;
  }

  // check if any member is an event stream
  for (var name in members) {
    if (!members.hasOwnProperty(name)) {
      if (members[name].isEventStream === true) {
        return true;
      }
    }
  }
  return false;
}

/**
 * @api private
 */
module.exports = Operation;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/model/paginator.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/model/paginator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var property = (__webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js").property);

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

/**
 * @api private
 */
module.exports = Paginator;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/model/resource_waiter.js":
/*!***********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/model/resource_waiter.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

/**
 * @api private
 */
module.exports = ResourceWaiter;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/model/shape.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-sdk/lib/model/shape.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Collection = __webpack_require__(/*! ./collection */ "./node_modules/aws-sdk/lib/model/collection.js");

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'requiresLength', shape.requiresLength, false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', Boolean(shape.queryName), false);
  property(this, 'isLocationName', Boolean(shape.locationName), false);
  property(this, 'isIdempotent', shape.idempotencyToken === true);
  property(this, 'isJsonValue', shape.jsonvalue === true);
  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
  property(this, 'isEventStream', Boolean(shape.eventstream), false);
  property(this, 'isEvent', Boolean(shape.event), false);
  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
  property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
  property(this, 'hostLabel', Boolean(shape.hostLabel), false);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  // type conversion and parsing
  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}

/**
 * @api private
 */
Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};

/**
 * @api private
 */
Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }

    // create an inline shape with extra members
    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    // set type if not set
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    // normalize types
    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var self = this;
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
    property(this, 'isDocument', Boolean(shape.document));
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });

    if (shape.event) {
      memoizedProperty(this, 'eventPayloadMemberName', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        // iterate over members to find ones that are event payloads
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventPayload) {
            return memberNames[i];
          }
        }
      });

      memoizedProperty(this, 'eventHeaderMemberNames', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        var eventHeaderMemberNames = [];
        // iterate over members to find ones that are event headers
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventHeader) {
            eventHeaderMemberNames.push(memberNames[i]);
          }
        }
        return eventHeaderMemberNames;
      });
    }
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (self.isTimestampFormatSet && this.timestampFormat) {
    property(this, 'timestampFormat', this.timestampFormat);
  } else if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (this.location === 'querystring') {
    property(this, 'timestampFormat', 'iso8601');
  } else if (this.api) {
    switch (this.api.protocol) {
      case 'json':
      case 'rest-json':
        property(this, 'timestampFormat', 'unixTimestamp');
        break;
      case 'rest-xml':
      case 'query':
      case 'ec2':
        property(this, 'timestampFormat', 'iso8601');
        break;
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
  this.toType = function(value) {
    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
      value || '' : value;
    if (this.isJsonValue) {
      return JSON.parse(value);
    }

    return value && typeof value.toString === 'function' ?
      value.toString() : value;
  };

  this.toWireFormat = function(value) {
    return this.isJsonValue ? JSON.stringify(value) : value;
  };
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = function(value) {
    var buf = util.base64.decode(value);
    if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
  /* Node.js can create a Buffer that is not isolated.
   * i.e. buf.byteLength !== buf.buffer.byteLength
   * This means that the sensitive data is accessible to anyone with access to buf.buffer.
   * If this is the node shared Buffer, then other code within this process _could_ find this secret.
   * Copy sensitive data to an isolated Buffer and zero the sensitive data.
   * While this is safe to do here, copying this code somewhere else may produce unexpected results.
   */
      var secureBuf = util.Buffer.alloc(buf.length, buf);
      buf.fill(0);
      buf = secureBuf;
    }
    return buf;
  };
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}

/**
 * @api private
 */
Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

/**
 * @api private
 */
module.exports = Shape;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/node_loader.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-sdk/lib/node_loader.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "./node_modules/aws-sdk/lib/util.js");

var region_utils = __webpack_require__(/*! ./region/utils */ "./node_modules/aws-sdk/lib/region/utils.js");
var isFipsRegion = region_utils.isFipsRegion;
var getRealRegion = region_utils.getRealRegion;

util.isBrowser = function() { return false; };
util.isNode = function() { return true; };

// node.js specific modules
util.crypto.lib = __webpack_require__(/*! crypto */ "crypto");
util.Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);
util.domain = __webpack_require__(/*! domain */ "domain");
util.stream = __webpack_require__(/*! stream */ "stream");
util.url = __webpack_require__(/*! url */ "url");
util.querystring = __webpack_require__(/*! querystring */ "querystring");
util.environment = 'nodejs';
util.createEventStream = util.stream.Readable ?
  (__webpack_require__(/*! ./event-stream/streaming-create-event-stream */ "./node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js").createEventStream) : (__webpack_require__(/*! ./event-stream/buffered-create-event-stream */ "./node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js").createEventStream);
util.realClock = __webpack_require__(/*! ./realclock/nodeClock */ "./node_modules/aws-sdk/lib/realclock/nodeClock.js");
util.clientSideMonitoring = {
  Publisher: (__webpack_require__(/*! ./publisher */ "./node_modules/aws-sdk/lib/publisher/index.js").Publisher),
  configProvider: __webpack_require__(/*! ./publisher/configuration */ "./node_modules/aws-sdk/lib/publisher/configuration.js"),
};
util.iniLoader = (__webpack_require__(/*! ./shared-ini */ "./node_modules/aws-sdk/lib/shared-ini/index.js").iniLoader);
util.getSystemErrorName = (__webpack_require__(/*! util */ "util").getSystemErrorName);

util.loadConfig = function(options) {
  var envValue = options.environmentVariableSelector(process.env);
  if (envValue !== undefined) {
    return envValue;
  }

  var configFile = {};
  try {
    configFile = util.iniLoader ? util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || util.defaultProfile
  ] || {};
  var configValue = options.configFileSelector(sharedFileConfig);
  if (configValue !== undefined) {
    return configValue;
  }

  if (typeof options.default === 'function') {
    return options.default();
  }
  return options.default;
};

var AWS;

/**
 * @api private
 */
module.exports = AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");

__webpack_require__(/*! ./credentials */ "./node_modules/aws-sdk/lib/credentials.js");
__webpack_require__(/*! ./credentials/credential_provider_chain */ "./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js");
__webpack_require__(/*! ./credentials/temporary_credentials */ "./node_modules/aws-sdk/lib/credentials/temporary_credentials.js");
__webpack_require__(/*! ./credentials/chainable_temporary_credentials */ "./node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js");
__webpack_require__(/*! ./credentials/web_identity_credentials */ "./node_modules/aws-sdk/lib/credentials/web_identity_credentials.js");
__webpack_require__(/*! ./credentials/cognito_identity_credentials */ "./node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js");
__webpack_require__(/*! ./credentials/saml_credentials */ "./node_modules/aws-sdk/lib/credentials/saml_credentials.js");
__webpack_require__(/*! ./credentials/process_credentials */ "./node_modules/aws-sdk/lib/credentials/process_credentials.js");

// Load the xml2js XML parser
AWS.XML.Parser = __webpack_require__(/*! ./xml/node_parser */ "./node_modules/aws-sdk/lib/xml/node_parser.js");

// Load Node HTTP client
__webpack_require__(/*! ./http/node */ "./node_modules/aws-sdk/lib/http/node.js");

__webpack_require__(/*! ./shared-ini/ini-loader */ "./node_modules/aws-sdk/lib/shared-ini/ini-loader.js");

// Load custom credential providers
__webpack_require__(/*! ./credentials/token_file_web_identity_credentials */ "./node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js");
__webpack_require__(/*! ./credentials/ec2_metadata_credentials */ "./node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js");
__webpack_require__(/*! ./credentials/remote_credentials */ "./node_modules/aws-sdk/lib/credentials/remote_credentials.js");
__webpack_require__(/*! ./credentials/ecs_credentials */ "./node_modules/aws-sdk/lib/credentials/ecs_credentials.js");
__webpack_require__(/*! ./credentials/environment_credentials */ "./node_modules/aws-sdk/lib/credentials/environment_credentials.js");
__webpack_require__(/*! ./credentials/file_system_credentials */ "./node_modules/aws-sdk/lib/credentials/file_system_credentials.js");
__webpack_require__(/*! ./credentials/shared_ini_file_credentials */ "./node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js");
__webpack_require__(/*! ./credentials/process_credentials */ "./node_modules/aws-sdk/lib/credentials/process_credentials.js");

// Setup default chain providers
// If this changes, please update documentation for
// AWS.CredentialProviderChain.defaultProviders in
// credentials/credential_provider_chain.js
AWS.CredentialProviderChain.defaultProviders = [
  function () { return new AWS.EnvironmentCredentials('AWS'); },
  function () { return new AWS.EnvironmentCredentials('AMAZON'); },
  function () { return new AWS.SharedIniFileCredentials(); },
  function () { return new AWS.ECSCredentials(); },
  function () { return new AWS.ProcessCredentials(); },
  function () { return new AWS.TokenFileWebIdentityCredentials(); },
  function () { return new AWS.EC2MetadataCredentials(); }
];

var getRegion = function() {
  var env = process.env;
  var region = env.AWS_REGION || env.AMAZON_REGION;
  if (env[AWS.util.configOptInEnv]) {
    var toCheck = [
      {filename: env[AWS.util.sharedCredentialsFileEnv]},
      {isConfig: true, filename: env[AWS.util.sharedConfigFileEnv]}
    ];
    var iniLoader = AWS.util.iniLoader;
    while (!region && toCheck.length) {
      var configFile = {};
      var fileInfo = toCheck.shift();
      try {
        configFile = iniLoader.loadFrom(fileInfo);
      } catch (err) {
        if (fileInfo.isConfig) throw err;
      }
      var profile = configFile[env.AWS_PROFILE || AWS.util.defaultProfile];
      region = profile && profile.region;
    }
  }
  return region;
};

var getBooleanValue = function(value) {
  return value === 'true' ? true: value === 'false' ? false: undefined;
};

var USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: function(env) {
    return getBooleanValue(env['AWS_USE_FIPS_ENDPOINT']);
  },
  configFileSelector: function(profile) {
    return getBooleanValue(profile['use_fips_endpoint']);
  },
  default: false,
};

var USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: function(env) {
    return getBooleanValue(env['AWS_USE_DUALSTACK_ENDPOINT']);
  },
  configFileSelector: function(profile) {
    return getBooleanValue(profile['use_dualstack_endpoint']);
  },
  default: false,
};

// Update configuration keys
AWS.util.update(AWS.Config.prototype.keys, {
  credentials: function () {
    var credentials = null;
    new AWS.CredentialProviderChain([
      function () { return new AWS.EnvironmentCredentials('AWS'); },
      function () { return new AWS.EnvironmentCredentials('AMAZON'); },
      function () { return new AWS.SharedIniFileCredentials({ disableAssumeRole: true }); }
    ]).resolve(function(err, creds) {
      if (!err) credentials = creds;
    });
    return credentials;
  },
  credentialProvider: function() {
    return new AWS.CredentialProviderChain();
  },
  logger: function () {
    return process.env.AWSJS_DEBUG ? console : null;
  },
  region: function() {
    var region = getRegion();
    return region ? getRealRegion(region): undefined;
  },
  useFipsEndpoint: function() {
    var region = getRegion();
    return isFipsRegion(region)
      ? true
      : util.loadConfig(USE_FIPS_ENDPOINT_CONFIG_OPTIONS);
  },
  useDualstackEndpoint: function() {
    return util.loadConfig(USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS);
  }
});

// Reset configuration
AWS.config = new AWS.Config();


/***/ }),

/***/ "./node_modules/aws-sdk/lib/param_validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/param_validator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * @api private
 */
AWS.ParamValidator = AWS.util.inherit({
  /**
   * Create a new validator object.
   *
   * @param validation [Boolean|map] whether input parameters should be
   *     validated against the operation description before sending the
   *     request. Pass a map to enable any of the following specific
   *     validation features:
   *
   *     * **min** [Boolean] &mdash; Validates that a value meets the min
   *       constraint. This is enabled by default when paramValidation is set
   *       to `true`.
   *     * **max** [Boolean] &mdash; Validates that a value meets the max
   *       constraint.
   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *       regular expression.
   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
   *       of the allowable enum values.
   */
  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    this.validateType(params, context, ['object'], 'structure');

    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    // validate hash members
    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else if (paramValue !== undefined && paramValue !== null) {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      // validate array members
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      // Build up a count of map members to validate range traits.
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        // Validate any map key trait constraints
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']');
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    var validTypes = ['string'];
    if (shape.isJsonValue) {
      validTypes = validTypes.concat(['number', 'object', 'boolean']);
    }
    if (value !== null && this.validateType(value, context, validTypes)) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
      this.validateUri(shape, value, context);
    }
  },

  validateUri: function validateUri(shape, value, context) {
    if (shape['location'] === 'uri') {
      if (value.length === 0) {
        this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,'
          + ' but found "' + value +'" for ' + context);
      }
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      // Fail if the string value is not present in the enum list
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    // We will not log an error for null or undefined, but we will return
    // false so that callers know that the expected type was not strictly met.
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    } else {
      if (typeof Blob !== void 0 && value instanceof Blob) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/protocol/helpers.js":
/*!******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/protocol/helpers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util =  __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Prepend prefix defined by API model to endpoint that's already
 * constructed. This feature does not apply to operations using
 * endpoint discovery and can be disabled.
 * @api private
 */
function populateHostPrefix(request)  {
  var enabled = request.service.config.hostPrefixEnabled;
  if (!enabled) return request;
  var operationModel = request.service.api.operations[request.operation];
  //don't marshal host prefix when operation has endpoint discovery traits
  if (hasEndpointDiscover(request)) return request;
  if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
    var hostPrefixNotation = operationModel.endpoint.hostPrefix;
    var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
    prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
    validateHostname(request.httpRequest.endpoint.hostname);
  }
  return request;
}

/**
 * @api private
 */
function hasEndpointDiscover(request) {
  var api = request.service.api;
  var operationModel = api.operations[request.operation];
  var isEndpointOperation = api.endpointOperation && (api.endpointOperation === util.string.lowerFirst(operationModel.name));
  return (operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true);
}

/**
 * @api private
 */
function expandHostPrefix(hostPrefixNotation, params, shape) {
  util.each(shape.members, function(name, member) {
    if (member.hostLabel === true) {
      if (typeof params[name] !== 'string' || params[name] === '') {
        throw util.error(new Error(), {
          message: 'Parameter ' + name + ' should be a non-empty string.',
          code: 'InvalidParameter'
        });
      }
      var regex = new RegExp('\\{' + name + '\\}', 'g');
      hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
    }
  });
  return hostPrefixNotation;
}

/**
 * @api private
 */
function prependEndpointPrefix(endpoint, prefix) {
  if (endpoint.host) {
    endpoint.host = prefix + endpoint.host;
  }
  if (endpoint.hostname) {
    endpoint.hostname = prefix + endpoint.hostname;
  }
}

/**
 * @api private
 */
function validateHostname(hostname) {
  var labels = hostname.split('.');
  //Reference: https://tools.ietf.org/html/rfc1123#section-2
  var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
  util.arrayEach(labels, function(label) {
    if (!label.length || label.length < 1 || label.length > 63) {
      throw util.error(new Error(), {
        code: 'ValidationError',
        message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
      });
    }
    if (!hostPattern.test(label)) {
      throw AWS.util.error(new Error(),
        {code: 'ValidationError', message: label + ' is not hostname compatible.'});
    }
  });
}

module.exports = {
  populateHostPrefix: populateHostPrefix
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/protocol/json.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-sdk/lib/protocol/json.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var JsonBuilder = __webpack_require__(/*! ../json/builder */ "./node_modules/aws-sdk/lib/json/builder.js");
var JsonParser = __webpack_require__(/*! ../json/parser */ "./node_modules/aws-sdk/lib/json/parser.js");
var populateHostPrefix = (__webpack_require__(/*! ./helpers */ "./node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix);

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;

  populateHostPrefix(req);
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    try {
      var e = JSON.parse(httpResponse.body.toString());
      var code = e.__type || e.code || e.Code;
      if (code) {
        error.code = code.split('#').pop();
      }
      if (error.code === 'RequestEntityTooLarge') {
        error.message = 'Request body must be less than 1 MB';
      } else {
        error.message = (e.message || e.Message || null);
      }
    } catch (e) {
      error.statusCode = httpResponse.statusCode;
      error.message = httpResponse.statusMessage;
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/protocol/query.js":
/*!****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/protocol/query.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var QueryParamSerializer = __webpack_require__(/*! ../query/query_param_serializer */ "./node_modules/aws-sdk/lib/query/query_param_serializer.js");
var Shape = __webpack_require__(/*! ../model/shape */ "./node_modules/aws-sdk/lib/model/shape.js");
var populateHostPrefix = (__webpack_require__(/*! ./helpers */ "./node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix);

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  // convert the request parameters into a list of query params,
  // e.g. Deeply.NestedParam.0.Name=value
  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);

  populateHostPrefix(req);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    try {
      data = new AWS.XML.Parser().parse(body);
    } catch (e) {
      data = {
        Code: resp.httpResponse.statusCode,
        Message: resp.httpResponse.statusMessage
      };
    }
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  // TODO: Refactor XML Parser to parse RequestId from response.
  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/protocol/rest.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-sdk/lib/protocol/rest.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var populateHostPrefix = (__webpack_require__(/*! ./helpers */ "./node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix);

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function generateURI(endpointPath, operationPath, input, params) {
  var uri = [endpointPath, operationPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(member.member.toWireFormat(val).toString());
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  return uri;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      if (member.isJsonValue) {
        value = util.base64.encode(value);
      }
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
  populateHostPrefix(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  // normalize headers names to lower-cased keys for matching
  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        var value = member.isJsonValue ?
          util.base64.decode(headers[header]) :
          headers[header];
        data[name] = member.toType(value);
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData,
  generateURI: generateURI
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/protocol/rest_json.js":
/*!********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/protocol/rest_json.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var Rest = __webpack_require__(/*! ./rest */ "./node_modules/aws-sdk/lib/protocol/rest.js");
var Json = __webpack_require__(/*! ./json */ "./node_modules/aws-sdk/lib/protocol/json.js");
var JsonBuilder = __webpack_require__(/*! ../json/builder */ "./node_modules/aws-sdk/lib/json/builder.js");
var JsonParser = __webpack_require__(/*! ../json/parser */ "./node_modules/aws-sdk/lib/json/parser.js");

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params || {}, payloadShape);
      applyContentTypeHeader(req);
    } else if (params !== undefined) {
      // non-JSON payload
      req.httpRequest.body = params;
      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
        applyContentTypeHeader(req, true);
      }
    }
  } else {
    req.httpRequest.body = builder.build(req.params, input);
    applyContentTypeHeader(req);
  }
}

function applyContentTypeHeader(req, isBinary) {
  if (!req.httpRequest.headers['Content-Type']) {
    var type = isBinary ? 'binary/octet-stream' : 'application/json';
    req.httpRequest.headers['Content-Type'] = type;
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD/DELETE
  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var rules = req.service.api.operations[req.operation].output || {};
  var parser;
  var hasEventOutput = operation.hasEventOutput;

  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.isEventStream) {
      parser = new JsonParser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else {
      resp.data[rules.payload] = payloadMember.toType(body);
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/protocol/rest_xml.js":
/*!*******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/protocol/rest_xml.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var Rest = __webpack_require__(/*! ./rest */ "./node_modules/aws-sdk/lib/protocol/rest.js");

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD
  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data;
  try {
    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  } catch (e) {
    data = {
      Code: resp.httpResponse.statusCode,
      Message: resp.httpResponse.statusMessage
    };
  }

  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var hasEventOutput = operation.hasEventOutput;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.isEventStream) {
      parser = new AWS.XML.Parser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else {
      resp.data[payload] = payloadMember.toType(body);
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/publisher/configuration.js":
/*!*************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/publisher/configuration.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * Resolve client-side monitoring configuration from either environmental variables
 * or shared config file. Configurations from environmental variables have higher priority
 * than those from shared config file. The resolver will try to read the shared config file
 * no matter whether the AWS_SDK_LOAD_CONFIG variable is set.
 * @api private
 */
function resolveMonitoringConfig() {
  var config = {
    port: undefined,
    clientId: undefined,
    enabled: undefined,
    host: undefined
  };
  if (fromEnvironment(config) || fromConfigFile(config)) return toJSType(config);
  return toJSType(config);
}

/**
 * Resolve configurations from environmental variables.
 * @param {object} client side monitoring config object needs to be resolved
 * @returns {boolean} whether resolving configurations is done
 * @api private
 */
function fromEnvironment(config) {
  config.port = config.port || process.env.AWS_CSM_PORT;
  config.enabled = config.enabled || process.env.AWS_CSM_ENABLED;
  config.clientId = config.clientId || process.env.AWS_CSM_CLIENT_ID;
  config.host = config.host || process.env.AWS_CSM_HOST;
  return config.port && config.enabled && config.clientId && config.host ||
    ['false', '0'].indexOf(config.enabled) >= 0; //no need to read shared config file if explicitely disabled
}

/**
 * Resolve cofigurations from shared config file with specified role name
 * @param {object} client side monitoring config object needs to be resolved
 * @returns {boolean} whether resolving configurations is done
 * @api private
 */
function fromConfigFile(config) {
  var sharedFileConfig;
  try {
    var configFile = AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    });
    var sharedFileConfig = configFile[
      process.env.AWS_PROFILE || AWS.util.defaultProfile
    ];
  } catch (err) {
    return false;
  }
  if (!sharedFileConfig) return config;
  config.port = config.port || sharedFileConfig.csm_port;
  config.enabled = config.enabled || sharedFileConfig.csm_enabled;
  config.clientId = config.clientId || sharedFileConfig.csm_client_id;
  config.host = config.host || sharedFileConfig.csm_host;
  return config.port && config.enabled && config.clientId && config.host;
}

/**
 * Transfer the resolved configuration value to proper types: port as number, enabled
 * as boolean and clientId as string. The 'enabled' flag is valued to false when set
 * to 'false' or '0'.
 * @param {object} resolved client side monitoring config
 * @api private
 */
function toJSType(config) {
    //config.XXX is either undefined or string
  var falsyNotations = ['false', '0', undefined];
  if (!config.enabled || falsyNotations.indexOf(config.enabled.toLowerCase()) >= 0) {
    config.enabled = false;
  } else {
    config.enabled = true;
  }
  config.port = config.port ? parseInt(config.port, 10) : undefined;
  return config;
}

module.exports = resolveMonitoringConfig;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/publisher/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/publisher/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = (__webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js").util);
var dgram = __webpack_require__(/*! dgram */ "dgram");
var stringToBuffer = util.buffer.toBuffer;

var MAX_MESSAGE_SIZE = 1024 * 8; // 8 KB

/**
 * Publishes metrics via udp.
 * @param {object} options Paramters for Publisher constructor
 * @param {number} [options.port = 31000] Port number
 * @param {string} [options.clientId = ''] Client Identifier
 * @param {boolean} [options.enabled = false] enable sending metrics datagram
 * @api private
 */
function Publisher(options) {
    // handle configuration
    options = options || {};
    this.enabled = options.enabled || false;
    this.port = options.port || 31000;
    this.clientId = options.clientId || '';
    this.address = options.host || '127.0.0.1';
    if (this.clientId.length > 255) {
        // ClientId has a max length of 255
        this.clientId = this.clientId.substr(0, 255);
    }
    this.messagesInFlight = 0;
}

Publisher.prototype.fieldsToTrim = {
    UserAgent: 256,
    SdkException: 128,
    SdkExceptionMessage: 512,
    AwsException: 128,
    AwsExceptionMessage: 512,
    FinalSdkException: 128,
    FinalSdkExceptionMessage: 512,
    FinalAwsException: 128,
    FinalAwsExceptionMessage: 512

};

/**
 * Trims fields that have a specified max length.
 * @param {object} event ApiCall or ApiCallAttempt event.
 * @returns {object}
 * @api private
 */
Publisher.prototype.trimFields = function(event) {
    var trimmableFields = Object.keys(this.fieldsToTrim);
    for (var i = 0, iLen = trimmableFields.length; i < iLen; i++) {
        var field = trimmableFields[i];
        if (event.hasOwnProperty(field)) {
            var maxLength = this.fieldsToTrim[field];
            var value = event[field];
            if (value && value.length > maxLength) {
                event[field] = value.substr(0, maxLength);
            }
        }
    }
    return event;
};

/**
 * Handles ApiCall and ApiCallAttempt events.
 * @param {Object} event apiCall or apiCallAttempt event.
 * @api private
 */
Publisher.prototype.eventHandler = function(event) {
    // set the clientId
    event.ClientId = this.clientId;

    this.trimFields(event);

    var message = stringToBuffer(JSON.stringify(event));
    if (!this.enabled || message.length > MAX_MESSAGE_SIZE) {
        // drop the message if publisher not enabled or it is too large
        return;
    }

    this.publishDatagram(message);
};

/**
 * Publishes message to an agent.
 * @param {Buffer} message JSON message to send to agent.
 * @api private
 */
Publisher.prototype.publishDatagram = function(message) {
    var self = this;
    var client = this.getClient();

    this.messagesInFlight++;
    this.client.send(message, 0, message.length, this.port, this.address, function(err, bytes) {
        if (--self.messagesInFlight <= 0) {
            // destroy existing client so the event loop isn't kept open
            self.destroyClient();
        }
    });
};

/**
 * Returns an existing udp socket, or creates one if it doesn't already exist.
 * @api private
 */
Publisher.prototype.getClient = function() {
    if (!this.client) {
        this.client = dgram.createSocket('udp4');
    }
    return this.client;
};

/**
 * Destroys the udp socket.
 * @api private
 */
Publisher.prototype.destroyClient = function() {
    if (this.client) {
        this.client.close();
        this.client = void 0;
    }
};

module.exports = {
    Publisher: Publisher
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/query/query_param_serializer.js":
/*!******************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/query/query_param_serializer.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      // Do nothing for EC2
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

/**
 * @api private
 */
module.exports = QueryParamSerializer;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/realclock/nodeClock.js":
/*!*********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/realclock/nodeClock.js ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = {
  //provide realtime clock for performance measurement
  now: function now() {
    var second = process.hrtime();
    return second[0] * 1000 + (second[1] / 1000000);
  }
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/region/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/lib/region/utils.js ***!
  \**************************************************/
/***/ ((module) => {

function isFipsRegion(region) {
  return typeof region === 'string' && (region.startsWith('fips-') || region.endsWith('-fips'));
}

function isGlobalRegion(region) {
  return typeof region === 'string' && ['aws-global', 'aws-us-gov-global'].includes(region);
}

function getRealRegion(region) {
  return ['fips-aws-global', 'aws-fips', 'aws-global'].includes(region)
      ? 'us-east-1'
      : ['fips-aws-us-gov-global', 'aws-us-gov-global'].includes(region)
      ? 'us-gov-west-1'
      : region.replace(/fips-(dkr-|prod-)?|-fips/, '');
}

module.exports = {
  isFipsRegion: isFipsRegion,
  isGlobalRegion: isGlobalRegion,
  getRealRegion: getRealRegion
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/region_config.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-sdk/lib/region_config.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "./node_modules/aws-sdk/lib/util.js");
var regionConfig = __webpack_require__(/*! ./region_config_data.json */ "./node_modules/aws-sdk/lib/region_config_data.json");

function generateRegionPrefix(region) {
  if (!region) return null;
  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  var useFipsEndpoint = service.config.useFipsEndpoint;
  var useDualstackEndpoint = service.config.useDualstackEndpoint;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    var rules = useFipsEndpoint
      ? useDualstackEndpoint
        ? regionConfig.dualstackFipsRules
        : regionConfig.fipsRules
      : useDualstackEndpoint
      ? regionConfig.dualstackRules
      : regionConfig.rules;

    if (Object.prototype.hasOwnProperty.call(rules, key)) {
      var config = rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      // set global endpoint
      service.isGlobalEndpoint = !!config.globalEndpoint;
      if (config.signingRegion) {
        service.signingRegion = config.signingRegion;
      }

      // signature version
      if (!config.signatureVersion) config.signatureVersion = 'v4';

      // merge config
      applyConfig(service, config);
      return;
    }
  }
}

function getEndpointSuffix(region) {
  var regionRegexes = {
    '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
    '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
    '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
  };
  var defaultSuffix = 'amazonaws.com';
  var regexes = Object.keys(regionRegexes);
  for (var i = 0; i < regexes.length; i++) {
    var regionPattern = RegExp(regexes[i]);
    var dnsSuffix = regionRegexes[regexes[i]];
    if (regionPattern.test(region)) return dnsSuffix;
  }
  return defaultSuffix;
}

/**
 * @api private
 */
module.exports = {
  configureEndpoint: configureEndpoint,
  getEndpointSuffix: getEndpointSuffix,
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/request.js":
/*!*********************************************!*\
  !*** ./node_modules/aws-sdk/lib/request.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var AcceptorStateMachine = __webpack_require__(/*! ./state_machine */ "./node_modules/aws-sdk/lib/state_machine.js");
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = __webpack_require__(/*! jmespath */ "./node_modules/jmespath/jmespath.js");

/**
 * @api private
 */
var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();

/**
 * ## Asynchronous Requests
 *
 * All requests made through the SDK are asynchronous and use a
 * callback interface. Each service method that kicks off a request
 * returns an `AWS.Request` object that you can use to register
 * callbacks.
 *
 * For example, the following service method returns the request
 * object as "request", which can be used to register callbacks:
 *
 * ```javascript
 * // request is an AWS.Request object
 * var request = ec2.describeInstances();
 *
 * // register callbacks on request to retrieve response data
 * request.on('success', function(response) {
 *   console.log(response.data);
 * });
 * ```
 *
 * When a request is ready to be sent, the {send} method should
 * be called:
 *
 * ```javascript
 * request.send();
 * ```
 *
 * Since registered callbacks may or may not be idempotent, requests should only
 * be sent once. To perform the same operation multiple times, you will need to
 * create multiple request objects, each with its own registered callbacks.
 *
 * ## Removing Default Listeners for Events
 *
 * Request objects are built with default listeners for the various events,
 * depending on the service type. In some cases, you may want to remove
 * some built-in listeners to customize behaviour. Doing this requires
 * access to the built-in listener functions, which are exposed through
 * the {AWS.EventListeners.Core} namespace. For instance, you may
 * want to customize the HTTP handler used when sending a request. In this
 * case, you can remove the built-in listener associated with the 'send'
 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
 *
 * ## Multiple Callbacks and Chaining
 *
 * You can register multiple callbacks on any request object. The
 * callbacks can be registered for different events, or all for the
 * same event. In addition, you can chain callback registration, for
 * example:
 *
 * ```javascript
 * request.
 *   on('success', function(response) {
 *     console.log("Success!");
 *   }).
 *   on('error', function(error, response) {
 *     console.log("Error!");
 *   }).
 *   on('complete', function(response) {
 *     console.log("Always!");
 *   }).
 *   send();
 * ```
 *
 * The above example will print either "Success! Always!", or "Error! Always!",
 * depending on whether the request succeeded or not.
 *
 * @!attribute httpRequest
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpRequest] the raw HTTP request object
 *     containing request headers and body information
 *     sent by the service.
 *
 * @!attribute startTime
 *   @readonly
 *   @!group Operation Properties
 *   @return [Date] the time that the request started
 *
 * @!group Request Building Events
 *
 * @!event validate(request)
 *   Triggered when a request is being validated. Listeners
 *   should throw an error if the request should not be sent.
 *   @param request [Request] the request object being sent
 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
 *   @see AWS.EventListeners.Core.VALIDATE_REGION
 *   @example Ensuring that a certain parameter is set before sending a request
 *     var req = s3.putObject(params);
 *     req.on('validate', function() {
 *       if (!req.params.Body.match(/^Hello\s/)) {
 *         throw new Error('Body must start with "Hello "');
 *       }
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event build(request)
 *   Triggered when the request payload is being built. Listeners
 *   should fill the necessary information to send the request
 *   over HTTP.
 *   @param (see AWS.Request~validate)
 *   @example Add a custom HTTP header to a request
 *     var req = s3.putObject(params);
 *     req.on('build', function() {
 *       req.httpRequest.headers['Custom-Header'] = 'value';
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event sign(request)
 *   Triggered when the request is being signed. Listeners should
 *   add the correct authentication headers and/or adjust the body,
 *   depending on the authentication mechanism being used.
 *   @param (see AWS.Request~validate)
 *
 * @!group Request Sending Events
 *
 * @!event send(response)
 *   Triggered when the request is ready to be sent. Listeners
 *   should call the underlying transport layer to initiate
 *   the sending of the request.
 *   @param response [Response] the response object
 *   @context [Request] the request object that was sent
 *   @see AWS.EventListeners.Core.SEND
 *
 * @!event retry(response)
 *   Triggered when a request failed and might need to be retried or redirected.
 *   If the response is retryable, the listener should set the
 *   `response.error.retryable` property to `true`, and optionally set
 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
 *   In the case of a redirect, `response.error.redirect` should be set to
 *   `true` with `retryDelay` set to an optional delay on the next request.
 *
 *   If a listener decides that a request should not be retried,
 *   it should set both `retryable` and `redirect` to false.
 *
 *   Note that a retryable error will be retried at most
 *   {AWS.Config.maxRetries} times (based on the service object's config).
 *   Similarly, a request that is redirected will only redirect at most
 *   {AWS.Config.maxRedirects} times.
 *
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @example Adding a custom retry for a 404 response
 *     request.on('retry', function(response) {
 *       // this resource is not yet available, wait 10 seconds to get it again
 *       if (response.httpResponse.statusCode === 404 && response.error) {
 *         response.error.retryable = true;   // retry this error
 *         response.error.retryDelay = 10000; // wait 10 seconds
 *       }
 *     });
 *
 * @!group Data Parsing Events
 *
 * @!event extractError(response)
 *   Triggered on all non-2xx requests so that listeners can extract
 *   error details from the response body. Listeners to this event
 *   should set the `response.error` property.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event extractData(response)
 *   Triggered in successful requests to allow listeners to
 *   de-serialize the response body into `response.data`.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group Completion Events
 *
 * @!event success(response)
 *   Triggered when the request completed successfully.
 *   `response.data` will contain the response data and
 *   `response.error` will be null.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event error(error, response)
 *   Triggered when an error occurs at any point during the
 *   request. `response.error` will contain details about the error
 *   that occurred. `response.data` will be null.
 *   @param error [Error] the error object containing details about
 *     the error that occurred.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event complete(response)
 *   Triggered whenever a request cycle completes. `response.error`
 *   should be checked, since the request may have failed.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group HTTP Events
 *
 * @!event httpHeaders(statusCode, headers, response, statusMessage)
 *   Triggered when headers are sent by the remote server
 *   @param statusCode [Integer] the HTTP response code
 *   @param headers [map<String,String>] the response headers
 *   @param (see AWS.Request~send)
 *   @param statusMessage [String] A status message corresponding to the HTTP
 *                                 response code
 *   @context (see AWS.Request~send)
 *
 * @!event httpData(chunk, response)
 *   Triggered when data is sent by the remote server
 *   @param chunk [Buffer] the buffer data containing the next data chunk
 *     from the server
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @see AWS.EventListeners.Core.HTTP_DATA
 *
 * @!event httpUploadProgress(progress, response)
 *   Triggered when the HTTP request has uploaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpDownloadProgress(progress, response)
 *   Triggered when the HTTP request has downloaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpError(error, response)
 *   Triggered when the HTTP request failed
 *   @param error [Error] the error object that was thrown
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event httpDone(response)
 *   Triggered when the server is finished sending data
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @see AWS.Response
 */
AWS.Request = inherit({

  /**
   * Creates a request for an operation on a given service with
   * a set of input parameters.
   *
   * @param service [AWS.Service] the service to perform the operation on
   * @param operation [String] the operation to perform on the service
   * @param params [Object] parameters to send to the operation.
   *   See the operation's documentation for the format of the
   *   parameters.
   */
  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    if (service.signingRegion) {
      region = service.signingRegion;
    } else if (service.isGlobalEndpoint) {
      region = 'us-east-1';
    }

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region);
    this.httpRequest.appendToUserAgent(customUserAgent);
    this.startTime = service.getSkewCorrectedDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },

  /**
   * @!group Sending a Request
   */

  /**
   * @overload send(callback = null)
   *   Sends the request object.
   *
   *   @callback callback function(err, data)
   *     If a callback is supplied, it is called when a response is returned
   *     from the service.
   *     @context [AWS.Request] the request object being sent.
   *     @param err [Error] the error object returned from the request.
   *       Set to `null` if the request is successful.
   *     @param data [Object] the de-serialized data returned from
   *       the request. Set to `null` if a request error occurs.
   *   @example Sending a request with a callback
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.send(function(err, data) { console.log(err, data); });
   *   @example Sending a request with no callback (using event handlers)
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.on('complete', function(response) { ... }); // register a callback
   *     request.send();
   */
  send: function send(callback) {
    if (callback) {
      // append to user agent
      this.httpRequest.appendToUserAgent('callback');
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },

  /**
   * @!method  promise()
   *   Sends the request and returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [Object] the de-serialized data returned from the request.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param error [Error] the error object returned from the request.
   *   @return [Promise] A promise that represents the state of the request.
   *   @example Sending a request using promises.
   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     var result = request.promise();
   *     result.then(function(data) { ... }, function(error) { ... });
   */

  /**
   * @api private
   */
  build: function build(callback) {
    return this.runTo('send', callback);
  },

  /**
   * @api private
   */
  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },

  /**
   * Aborts a request, emitting the error and complete events.
   *
   * @!macro nobrowser
   * @example Aborting a request after sending
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
   *   };
   *   var request = s3.putObject(params);
   *   request.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(request.abort.bind(request), 1000);
   *
   *   // prints "Error: RequestAbortedError Request aborted by user"
   * @return [AWS.Request] the same request object, for chaining.
   * @since v1.4.0
   */
  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },

  /**
   * Iterates over each page of results given a pageable request, calling
   * the provided callback with each page of data. After all pages have been
   * retrieved, the callback is called with `null` data.
   *
   * @note This operation can generate multiple requests to a service.
   * @example Iterating over multiple pages of objects in an S3 bucket
   *   var pages = 1;
   *   s3.listObjects().eachPage(function(err, data) {
   *     if (err) return;
   *     console.log("Page", pages++);
   *     console.log(data);
   *   });
   * @example Iterating over multiple pages with an asynchronous callback
   *   s3.listObjects(params).eachPage(function(err, data, done) {
   *     doSomethingAsyncAndOrExpensive(function() {
   *       // The next page of results isn't fetched until done is called
   *       done();
   *     });
   *   });
   * @callback callback function(err, data, [doneCallback])
   *   Called with each page of resulting data from the request. If the
   *   optional `doneCallback` is provided in the function, it must be called
   *   when the callback is complete.
   *
   *   @param err [Error] an error object, if an error occurred.
   *   @param data [Object] a single page of response data. If there is no
   *     more data, this object will be `null`.
   *   @param doneCallback [Function] an optional done callback. If this
   *     argument is defined in the function declaration, it should be called
   *     when the next page is ready to be retrieved. This is useful for
   *     controlling serial pagination across asynchronous operations.
   *   @return [Boolean] if the callback returns `false`, pagination will
   *     stop.
   *
   * @see AWS.Request.eachItem
   * @see AWS.Response.nextPage
   * @since v1.4.0
   */
  eachPage: function eachPage(callback) {
    // Make all callbacks async-ish
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },

  /**
   * Enumerates over individual items of a request, paging the responses if
   * necessary.
   *
   * @api experimental
   * @since v1.4.0
   */
  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },

  /**
   * @return [Boolean] whether the operation can return multiple pages of
   *   response data.
   * @see AWS.Response.eachPage
   * @since v1.4.0
   */
  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },

  /**
   * Sends the request and converts the request object into a readable stream
   * that can be read from or piped into a writable stream.
   *
   * @note The data read from a readable stream contains only
   *   the raw HTTP body contents.
   * @example Manually reading from a stream
   *   request.createReadStream().on('data', function(data) {
   *     console.log("Got data:", data.toString());
   *   });
   * @example Piping a request body into a file
   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
   *   s3.service.getObject(params).createReadStream().pipe(out);
   * @return [Stream] the readable stream object that can be piped
   *   or read from (by registering 'data' event listeners).
   * @!macro nobrowser
   */
  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      process.nextTick(function() { req.send(); });
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end');
          }
        };

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            stream.on('error', function(err) {
              shouldCheckContentLength = false;
              httpStream.unpipe(lengthAccumulator);
              lengthAccumulator.emit('end');
              lengthAccumulator.end();
            });
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    return stream;
  },

  /**
   * @param [Array,Response] args This should be the response object,
   *   or an array of args to send to the event.
   * @api private
   */
  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },

  /**
   * @api private
   */
  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },

  /**
   * @api private
   */
  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },

  /**
   * @api private
   */
  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },

  /**
   * @api private
   */
  toUnauthenticated: function toUnauthenticated() {
    this._unAuthenticated = true;
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },

  /**
   * @api private
   */
  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },

  /**
   * @api private
   */
  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    // don't need these headers on a GET request
    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },

  /**
   * @api private
   */
  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});

/**
 * @api private
 */
AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    // append to user agent
    this.httpRequest.appendToUserAgent('promise');
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          // define $response property so that it is not enumerable
          // this prevents circular reference errors when stringifying the JSON object
          resolve(Object.defineProperty(
            resp.data || {},
            '$response',
            {value: resp}
          ));
        }
      });
      self.runTo();
    });
  };
};

/**
 * @api private
 */
AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);


/***/ }),

/***/ "./node_modules/aws-sdk/lib/resource_waiter.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/resource_waiter.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not use this file except in compliance with the License. A copy of
 * the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;
var jmespath = __webpack_require__(/*! jmespath */ "./node_modules/jmespath/jmespath.js");

/**
 * @api private
 */
function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}

/**
 * @api private
 */
AWS.ResourceWaiter = inherit({
  /**
   * Waits for a given state on a service object
   * @param service [Service] the service object to wait on
   * @param state [String] the state (defined in waiter configuration) to wait
   *   for.
   * @example Create a waiter for running EC2 instances
   *   var ec2 = new AWS.EC2;
   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
   */
  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      try {
        var result = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      // if expected is not string, can be boolean indicating presence of error
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),

  /**
   * @return [AWS.Request]
   */
  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    if (params && params.$waiter) {
      params = AWS.util.copy(params);
      if (typeof params.$waiter.delay === 'number') {
        this.config.delay = params.$waiter.delay;
      }
      if (typeof params.$waiter.maxAttempts === 'number') {
        this.config.maxAttempts = params.$waiter.maxAttempts;
      }
      delete params.$waiter;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },

  /**
   * Loads waiter configuration from API configuration
   *
   * @api private
   */
  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = AWS.util.copy(this.service.api.waiters[state]);
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/response.js":
/*!**********************************************!*\
  !*** ./node_modules/aws-sdk/lib/response.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;
var jmespath = __webpack_require__(/*! jmespath */ "./node_modules/jmespath/jmespath.js");

/**
 * This class encapsulates the response information
 * from a service request operation sent through {AWS.Request}.
 * The response object has two main properties for getting information
 * back from a request:
 *
 * ## The `data` property
 *
 * The `response.data` property contains the serialized object data
 * retrieved from the service request. For instance, for an
 * Amazon DynamoDB `listTables` method call, the response data might
 * look like:
 *
 * ```
 * > resp.data
 * { TableNames:
 *    [ 'table1', 'table2', ... ] }
 * ```
 *
 * The `data` property can be null if an error occurs (see below).
 *
 * ## The `error` property
 *
 * In the event of a service error (or transfer error), the
 * `response.error` property will be filled with the given
 * error data in the form:
 *
 * ```
 * { code: 'SHORT_UNIQUE_ERROR_CODE',
 *   message: 'Some human readable error message' }
 * ```
 *
 * In the case of an error, the `data` property will be `null`.
 * Note that if you handle events that can be in a failure state,
 * you should always check whether `response.error` is set
 * before attempting to access the `response.data` property.
 *
 * @!attribute data
 *   @readonly
 *   @!group Data Properties
 *   @note Inside of a {AWS.Request~httpData} event, this
 *     property contains a single raw packet instead of the
 *     full de-serialized service response.
 *   @return [Object] the de-serialized response data
 *     from the service.
 *
 * @!attribute error
 *   An structure containing information about a service
 *   or networking error.
 *   @readonly
 *   @!group Data Properties
 *   @note This attribute is only filled if a service or
 *     networking error occurs.
 *   @return [Error]
 *     * code [String] a unique short code representing the
 *       error that was emitted.
 *     * message [String] a longer human readable error message
 *     * retryable [Boolean] whether the error message is
 *       retryable.
 *     * statusCode [Numeric] in the case of a request that reached the service,
 *       this value contains the response status code.
 *     * time [Date] the date time object when the error occurred.
 *     * hostname [String] set when a networking error occurs to easily
 *       identify the endpoint of the request.
 *     * region [String] set when a networking error occurs to easily
 *       identify the region of the request.
 *
 * @!attribute requestId
 *   @readonly
 *   @!group Data Properties
 *   @return [String] the unique request ID associated with the response.
 *     Log this value when debugging requests for AWS support.
 *
 * @!attribute retryCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of retries that were
 *     attempted before the request was completed.
 *
 * @!attribute redirectCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of redirects that were
 *     followed before the request was completed.
 *
 * @!attribute httpResponse
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpResponse] the raw HTTP response object
 *     containing the response headers and body information
 *     from the server.
 *
 * @see AWS.Request
 */
AWS.Response = inherit({

  /**
   * @api private
   */
  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },

  /**
   * Creates a new request for the next page of response data, calling the
   * callback with the page data if a callback is provided.
   *
   * @callback callback function(err, data)
   *   Called when a page of data is returned from the next request.
   *
   *   @param err [Error] an error object, if an error occurred in the request
   *   @param data [Object] the next page of data, or null, if there are no
   *     more pages left.
   * @return [AWS.Request] the request object for the next page of data
   * @return [null] if no callback is provided and there are no pages left
   *   to retrieve.
   * @since v1.4.0
   */
  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },

  /**
   * @return [Boolean] whether more pages of data can be returned by further
   *   requests
   * @since v1.4.0
   */
  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },

  /**
   * @api private
   */
  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/sequential_executor.js":
/*!*********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/sequential_executor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * @api private
 * @!method on(eventName, callback)
 *   Registers an event listener callback for the event given by `eventName`.
 *   Parameters passed to the callback function depend on the individual event
 *   being triggered. See the event documentation for those parameters.
 *
 *   @param eventName [String] the event name to register the listener for
 *   @param callback [Function] the listener callback function
 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
 *     Default to be false.
 *   @return [AWS.SequentialExecutor] the same object for chaining
 */
AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },

  /**
   * @api private
   */
  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener, toHead) {
    if (this._events[eventName]) {
      toHead ?
        this._events[eventName].unshift(listener) :
        this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },

  onAsync: function onAsync(eventName, listener, toHead) {
    listener._isAsync = true;
    return this.on(eventName, listener, toHead);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },

  /**
   * @api private
   */
  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },

  /**
   * @api private
   */
  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },

  /**
   * Adds or copies a set of listeners from another list of
   * listeners or SequentialExecutor object.
   *
   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
   *   a list of events and callbacks, or an event emitter object
   *   containing listeners to add to this emitter object.
   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
   * @example Adding listeners from a map of listeners
   *   emitter.addListeners({
   *     event1: [function() { ... }, function() { ... }],
   *     event2: [function() { ... }]
   *   });
   *   emitter.emit('event1'); // emitter has event1
   *   emitter.emit('event2'); // emitter has event2
   * @example Adding listeners from another emitter object
   *   var emitter1 = new AWS.SequentialExecutor();
   *   emitter1.on('event1', function() { ... });
   *   emitter1.on('event2', function() { ... });
   *   var emitter2 = new AWS.SequentialExecutor();
   *   emitter2.addListeners(emitter1);
   *   emitter2.emit('event1'); // emitter2 has event1
   *   emitter2.emit('event2'); // emitter2 has event2
   */
  addListeners: function addListeners(listeners) {
    var self = this;

    // extract listeners if parameter is an SequentialExecutor object
    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },

  /**
   * Registers an event with {on} and saves the callback handle function
   * as a property on the emitter object using a given `name`.
   *
   * @param name [String] the property name to set on this object containing
   *   the callback function handle so that the listener can be removed in
   *   the future.
   * @param (see on)
   * @return (see on)
   * @example Adding a named listener DATA_CALLBACK
   *   var listener = function() { doSomething(); };
   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
   *
   *   // the following prints: true
   *   console.log(emitter.DATA_CALLBACK == listener);
   */
  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
    this[name] = callback;
    this.addListener(eventName, callback, toHead);
    return this;
  },

  /**
   * @api private
   */
  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback, toHead);
  },

  /**
   * Helper method to add a set of named listeners using
   * {addNamedListener}. The callback contains a parameter
   * with a handle to the `addNamedListener` method.
   *
   * @callback callback function(add)
   *   The callback function is called immediately in order to provide
   *   the `add` function to the block. This simplifies the addition of
   *   a large group of named listeners.
   *   @param add [Function] the {addNamedListener} function to call
   *     when registering listeners.
   * @example Adding a set of named listeners
   *   emitter.addNamedListeners(function(add) {
   *     add('DATA_CALLBACK', 'data', function() { ... });
   *     add('OTHER', 'otherEvent', function() { ... });
   *     add('LAST', 'lastEvent', function() { ... });
   *   });
   *
   *   // these properties are now set:
   *   emitter.DATA_CALLBACK;
   *   emitter.OTHER;
   *   emitter.LAST;
   */
  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});

/**
 * {on} is the prefered method.
 * @api private
 */
AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

/**
 * @api private
 */
module.exports = AWS.SequentialExecutor;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/service.js":
/*!*********************************************!*\
  !*** ./node_modules/aws-sdk/lib/service.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
var Api = __webpack_require__(/*! ./model/api */ "./node_modules/aws-sdk/lib/model/api.js");
var regionConfig = __webpack_require__(/*! ./region_config */ "./node_modules/aws-sdk/lib/region_config.js");

var inherit = AWS.util.inherit;
var clientCount = 0;
var region_utils = __webpack_require__(/*! ./region/utils */ "./node_modules/aws-sdk/lib/region/utils.js");

/**
 * The service class representing an AWS service.
 *
 * @class_abstract This class is an abstract class.
 *
 * @!attribute apiVersions
 *   @return [Array<String>] the list of API versions supported by this service.
 *   @readonly
 */
AWS.Service = inherit({
  /**
   * Create a new service object with a configuration object
   *
   * @param config [map] a map of configuration options
   */
  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }

    if (config) {
      if (config.region) {
        var region = config.region;
        if (region_utils.isFipsRegion(region)) {
          config.region = region_utils.getRealRegion(region);
          config.useFipsEndpoint = true;
        }
        if (region_utils.isGlobalRegion(region)) {
          config.region = region_utils.getRealRegion(region);
        }
      }
      if (typeof config.useDualstack === 'boolean'
        && typeof config.useDualstackEndpoint !== 'boolean') {
        config.useDualstackEndpoint = config.useDualstack;
      }
    }

    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },

  /**
   * @api private
   */
  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];
    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig.configureEndpoint(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
    //enable attaching listeners to service client
    AWS.SequentialExecutor.call(this);
    AWS.Service.addDefaultMonitoringListeners(this);
    if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
      var publisher = this.publisher;
      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
    }
  },

  /**
   * @api private
   */
  validateService: function validateService() {
  },

  /**
   * @api private
   */
  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },

  /**
   * @api private
   */
  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },

  /**
   * @api private
   */
  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      // versions that end in "*" are not available on disk and can be
      // skipped, so do not choose these as selectedVersions
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },

  /**
   * @api private
   */
  api: {},

  /**
   * @api private
   */
  defaultRetryCount: 3,

  /**
   * @api private
   */
  customizeRequests: function customizeRequests(callback) {
    if (!callback) {
      this.customRequestHandler = null;
    } else if (typeof callback === 'function') {
      this.customRequestHandler = callback;
    } else {
      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
    }
  },

  /**
   * Calls an operation on a service with the given input parameters.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);
    this.attachMonitoringEmitter(request);
    if (callback) request.send(callback);
    return request;
  },

  /**
   * Calls an operation on a service with the given input parameters, without
   * any authentication data. This method is useful for "public" API operations.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },

  /**
   * Waits for a given state
   *
   * @param state [String] the state on the service to wait for
   * @param params [map] a map of parameters to pass with each request
   * @option params $waiter [map] a map of configuration options for the waiter
   * @option params $waiter.delay [Number] The number of seconds to wait between
   *                                       requests
   * @option params $waiter.maxAttempts [Number] The maximum number of requests
   *                                             to send while waiting
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },

  /**
   * @api private
   */
  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    // disable parameter validation
    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
    // call prototype's customRequestHandler
    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
      this.constructor.prototype.customRequestHandler(request);
    }
    // call instance's customRequestHandler
    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
      this.customRequestHandler(request);
    }
  },

  /**
   * Event recording metrics for a whole API call.
   * @returns {object} a subset of api call metrics
   * @api private
   */
  apiCallEvent: function apiCallEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCall',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Region: request.httpRequest.region,
      MaxRetriesExceeded: 0,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
    }
    if (response.error) {
      var error = response.error;
      var statusCode = response.httpResponse.statusCode;
      if (statusCode > 299) {
        if (error.code) monitoringEvent.FinalAwsException = error.code;
        if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
      } else {
        if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
        if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
      }
    }
    return monitoringEvent;
  },

  /**
   * Event recording metrics for an API call attempt.
   * @returns {object} a subset of api call attempt metrics
   * @api private
   */
  apiAttemptEvent: function apiAttemptEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCallAttempt',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Fqdn: request.httpRequest.endpoint.hostname,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
    }
    if (
      !request._unAuthenticated &&
      request.service.config.credentials &&
      request.service.config.credentials.accessKeyId
    ) {
      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
    }
    if (!response.httpResponse.headers) return monitoringEvent;
    if (request.httpRequest.headers['x-amz-security-token']) {
      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
    }
    if (response.httpResponse.headers['x-amzn-requestid']) {
      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
    }
    if (response.httpResponse.headers['x-amz-request-id']) {
      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
    }
    if (response.httpResponse.headers['x-amz-id-2']) {
      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
    }
    return monitoringEvent;
  },

  /**
   * Add metrics of failed request.
   * @api private
   */
  attemptFailEvent: function attemptFailEvent(request) {
    var monitoringEvent = this.apiAttemptEvent(request);
    var response = request.response;
    var error = response.error;
    if (response.httpResponse.statusCode > 299 ) {
      if (error.code) monitoringEvent.AwsException = error.code;
      if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
    } else {
      if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
      if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
    }
    return monitoringEvent;
  },

  /**
   * Attach listeners to request object to fetch metrics of each request
   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
   * @api private
   */
  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
    var attemptTimestamp; //timestamp marking the beginning of a request attempt
    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
    var attemptLatency; //latency from request sent out to http response reaching SDK
    var callStartRealTime; //Start time of API call. Used to calculating API call latency
    var attemptCount = 0; //request.retryCount is not reliable here
    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
    var callTimestamp; //timestamp when the request is created
    var self = this;
    var addToHead = true;

    request.on('validate', function () {
      callStartRealTime = AWS.util.realClock.now();
      callTimestamp = Date.now();
    }, addToHead);
    request.on('sign', function () {
      attemptStartRealTime = AWS.util.realClock.now();
      attemptTimestamp = Date.now();
      region = request.httpRequest.region;
      attemptCount++;
    }, addToHead);
    request.on('validateResponse', function() {
      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
    });
    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
      var apiAttemptEvent = self.apiAttemptEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
      var apiAttemptEvent = self.attemptFailEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      //attemptLatency may not be available if fail before response
      attemptLatency = attemptLatency ||
        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
      var apiCallEvent = self.apiCallEvent(request);
      apiCallEvent.AttemptCount = attemptCount;
      if (apiCallEvent.AttemptCount <= 0) return;
      apiCallEvent.Timestamp = callTimestamp;
      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
      apiCallEvent.Latency = latency >= 0 ? latency : 0;
      var response = request.response;
      if (
        response.error &&
        response.error.retryable &&
        typeof response.retryCount === 'number' &&
        typeof response.maxRetries === 'number' &&
        (response.retryCount >= response.maxRetries)
      ) {
        apiCallEvent.MaxRetriesExceeded = 1;
      }
      self.emit('apiCall', [apiCallEvent]);
    });
  },

  /**
   * Override this method to setup any custom request listeners for each
   * new request to the service.
   *
   * @method_abstract This is an abstract method.
   */
  setupRequestListeners: function setupRequestListeners(request) {
  },

  /**
   * Gets the signing name for a given request
   * @api private
   */
  getSigningName: function getSigningName() {
    return this.api.signingName || this.api.endpointPrefix;
  },

  /**
   * Gets the signer class for a given request
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var version;
    // get operation authtype if present
    var operation = null;
    var authtype = '';
    if (request) {
      var operations = request.service.api.operations || {};
      operation = operations[request.operation] || null;
      authtype = operation ? operation.authtype : '';
    }
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
      version = 'v4';
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },

  /**
   * @api private
   */
  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },

  /**
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },

  /**
   * How many times a failed request should be retried before giving up.
   * the defaultRetryCount can be overriden by service classes.
   *
   * @api private
   */
  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
  },

  /**
   * @api private
   */
  retryableError: function retryableError(error) {
    if (this.timeoutError(error)) return true;
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },

  /**
   * @api private
   */
  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },

  /**
   * @api private
   */
  timeoutError: function timeoutError(error) {
    return error.code === 'TimeoutError';
  },

  /**
   * @api private
   */
  expiredCredentialsError: function expiredCredentialsError(error) {
    // TODO : this only handles *one* of the expired credential codes
    return (error.code === 'ExpiredTokenException');
  },

  /**
   * @api private
   */
  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },

  /**
   * @api private
   */
  getSkewCorrectedDate: function getSkewCorrectedDate() {
    return new Date(Date.now() + this.config.systemClockOffset);
  },

  /**
   * @api private
   */
  applyClockOffset: function applyClockOffset(newServerTime) {
    if (newServerTime) {
      this.config.systemClockOffset = newServerTime - Date.now();
    }
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(newServerTime) {
    if (newServerTime) {
      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
    }
  },

  /**
   * @api private
   */
  throttledError: function throttledError(error) {
    // this logic varies between services
    if (error.statusCode === 429) return true;
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
      case 'RequestThrottledException':
      case 'TooManyRequestsException':
      case 'TransactionInProgressException': //dynamodb
      case 'EC2ThrottledException':
        return true;
      default:
        return false;
    }
  },

  /**
   * @api private
   */
  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },

  /**
   * @api private
   */
  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },

  /**
   * @api private
   */
  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {

  /**
   * Adds one method for each operation described in the api configuration
   *
   * @api private
   */
  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },

  /**
   * Defines a new Service class using a service identifier and list of versions
   * including an optional set of features (functions) to apply to the class
   * prototype.
   *
   * @param serviceIdentifier [String] the identifier for the service
   * @param versions [Array<String>] a list of versions that work with this
   *   service
   * @param features [Object] an object to attach to the prototype
   * @return [Class<Service>] the service class defined by this function.
   */
  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }
    AWS.SequentialExecutor.call(this.prototype);
    //util.clientSideMonitoring is only available in node
    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
      var Publisher = AWS.util.clientSideMonitoring.Publisher;
      var configProvider = AWS.util.clientSideMonitoring.configProvider;
      var publisherConfig = configProvider();
      this.prototype.publisher = new Publisher(publisherConfig);
      if (publisherConfig.enabled) {
        //if csm is enabled in environment, SDK should send all metrics
        AWS.Service._clientSideMonitoring = true;
      }
    }
    AWS.SequentialExecutor.call(svc.prototype);
    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
    return svc;
  },

  /**
   * @api private
   */
  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },

  /**
   * @api private
   */
  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api, {
          serviceIdentifier: superclass.serviceIdentifier
        });
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },

  /**
   * @api private
   */
  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },

  /**
   * @param attachOn attach default monitoring listeners to object
   *
   * Each monitoring event should be emitted from service client to service constructor prototype and then
   * to global service prototype like bubbling up. These default monitoring events listener will transfer
   * the monitoring events to the upper layer.
   * @api private
   */
  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
    });
    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCall', [event]);
    });
  },

  /**
   * @api private
   */
  _serviceMap: {}
});

AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

/**
 * @api private
 */
module.exports = AWS.Service;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/services/dynamodb.js":
/*!*******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/services/dynamodb.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
__webpack_require__(/*! ../dynamodb/document_client */ "./node_modules/aws-sdk/lib/dynamodb/document_client.js");

AWS.util.update(AWS.DynamoDB.prototype, {
  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    if (request.service.config.dynamoDbCrc32) {
      request.removeListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
      request.addListener('extractData', this.checkCrc32);
      request.addListener('extractData', AWS.EventListeners.Json.EXTRACT_DATA);
    }
  },

  /**
   * @api private
   */
  checkCrc32: function checkCrc32(resp) {
    if (!resp.httpResponse.streaming && !resp.request.service.crc32IsValid(resp)) {
      resp.data = null;
      resp.error = AWS.util.error(new Error(), {
        code: 'CRC32CheckFailed',
        message: 'CRC32 integrity check failed',
        retryable: true
      });
      resp.request.haltHandlersOnError();
      throw (resp.error);
    }
  },

  /**
   * @api private
   */
  crc32IsValid: function crc32IsValid(resp) {
    var crc = resp.httpResponse.headers['x-amz-crc32'];
    if (!crc) return true; // no (valid) CRC32 header
    return parseInt(crc, 10) === AWS.util.crypto.crc32(resp.httpResponse.body);
  },

  /**
   * @api private
   */
  defaultRetryCount: 10,

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    var retryDelayOptions = AWS.util.copy(this.config.retryDelayOptions);

    if (typeof retryDelayOptions.base !== 'number') {
        retryDelayOptions.base = 50; // default for dynamodb
    }
    var delay = AWS.util.calculateRetryDelay(retryCount, retryDelayOptions, err);
    return delay;
  }
});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/services/sts.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/lib/services/sts.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var resolveRegionalEndpointsFlag = __webpack_require__(/*! ../config_regional_endpoint */ "./node_modules/aws-sdk/lib/config_regional_endpoint.js");
var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';

AWS.util.update(AWS.STS.prototype, {
  /**
   * @overload credentialsFrom(data, credentials = null)
   *   Creates a credentials object from STS response data containing
   *   credentials information. Useful for quickly setting AWS credentials.
   *
   *   @note This is a low-level utility function. If you want to load temporary
   *     credentials into your process for subsequent requests to AWS resources,
   *     you should use {AWS.TemporaryCredentials} instead.
   *   @param data [map] data retrieved from a call to {getFederatedToken},
   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
   *   @param credentials [AWS.Credentials] an optional credentials object to
   *     fill instead of creating a new object. Useful when modifying an
   *     existing credentials object from a refresh call.
   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
   *     loaded from a raw STS operation response.
   *   @example Using credentialsFrom to load global AWS credentials
   *     var sts = new AWS.STS();
   *     sts.getSessionToken(function (err, data) {
   *       if (err) console.log("Error getting credentials");
   *       else {
   *         AWS.config.credentials = sts.credentialsFrom(data);
   *       }
   *     });
   *   @see AWS.TemporaryCredentials
   */
  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    request.addListener('validate', this.optInRegionalEndpoint, true);
  },

  /**
   * @api private
   */
  optInRegionalEndpoint: function optInRegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: ENV_REGIONAL_ENDPOINT_ENABLED,
      sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
      clientConfig: 'stsRegionalEndpoints'
    });
    if (
      config.stsRegionalEndpoints === 'regional' &&
      service.isGlobalEndpoint
    ) {
      //client will throw if region is not supplied; request will be signed with specified region
      if (!config.region) {
        throw AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      var regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.' + config.region + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
      req.httpRequest.region = config.region;
    }
  }

});


/***/ }),

/***/ "./node_modules/aws-sdk/lib/shared-ini/index.js":
/*!******************************************************!*\
  !*** ./node_modules/aws-sdk/lib/shared-ini/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IniLoader = (__webpack_require__(/*! ./ini-loader */ "./node_modules/aws-sdk/lib/shared-ini/ini-loader.js").IniLoader);
/**
 * Singleton object to load specified config/credentials files.
 * It will cache all the files ever loaded;
 */
module.exports.iniLoader = new IniLoader();


/***/ }),

/***/ "./node_modules/aws-sdk/lib/shared-ini/ini-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/shared-ini/ini-loader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var os = __webpack_require__(/*! os */ "os");
var path = __webpack_require__(/*! path */ "path");

function parseFile(filename, isConfig) {
    var content = AWS.util.ini.parse(AWS.util.readFileSync(filename));
    var tmpContent = {};
    Object.keys(content).forEach(function(profileName) {
      var profileContent = content[profileName];
      profileName = isConfig ? profileName.replace(/^profile\s/, '') : profileName;
      Object.defineProperty(tmpContent, profileName, {
        value: profileContent,
        enumerable: true
      });
    });
    return tmpContent;
}

/**
 * Ini file loader class the same as that used in the SDK. It loads and
 * parses config and credentials files in .ini format and cache the content
 * to assure files are only read once.
 * Note that calling operations on the instance instantiated from this class
 * won't affect the behavior of SDK since SDK uses an internal singleton of
 * this class.
 * @!macro nobrowser
 */
AWS.IniLoader = AWS.util.inherit({
  constructor: function IniLoader() {
    this.resolvedProfiles = {};
  },

  /** Remove all cached files. Used after config files are updated. */
  clearCachedFiles: function clearCachedFiles() {
    this.resolvedProfiles = {};
  },

/**
 * Load configurations from config/credentials files and cache them
 * for later use. If no file is specified it will try to load default
 * files.
 * @param options [map] information describing the file
 * @option options filename [String] ('~/.aws/credentials' or defined by
 *   AWS_SHARED_CREDENTIALS_FILE process env var or '~/.aws/config' if
 *   isConfig is set to true)
 *   path to the file to be read.
 * @option options isConfig [Boolean] (false) True to read config file.
 * @return [map<String,String>] object containing contents from file in key-value
 *   pairs.
 */
  loadFrom: function loadFrom(options) {
    options = options || {};
    var isConfig = options.isConfig === true;
    var filename = options.filename || this.getDefaultFilePath(isConfig);
    if (!this.resolvedProfiles[filename]) {
      var fileContent = this.parseFile(filename, isConfig);
      Object.defineProperty(this.resolvedProfiles, filename, { value: fileContent });
    }
    return this.resolvedProfiles[filename];
  },

  /**
   * @api private
   */
  parseFile: parseFile,

  /**
   * @api private
   */
  getDefaultFilePath: function getDefaultFilePath(isConfig) {
    return path.join(
      this.getHomeDir(),
      '.aws',
      isConfig ? 'config' : 'credentials'
    );
  },

  /**
   * @api private
   */
  getHomeDir: function getHomeDir() {
    var env = process.env;
    var home = env.HOME ||
      env.USERPROFILE ||
      (env.HOMEPATH ? ((env.HOMEDRIVE || 'C:/') + env.HOMEPATH) : null);

    if (home) {
      return home;
    }

    if (typeof os.homedir === 'function') {
      return os.homedir();
    }

    throw AWS.util.error(
      new Error('Cannot load credentials, HOME path not set')
    );
  }
});

var IniLoader = AWS.IniLoader;

module.exports = {
  IniLoader: IniLoader,
  parseFile: parseFile,
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/presign.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/presign.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp(now) + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}

/**
 * @api private
 */
function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  var auth = request.httpRequest.headers['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['Signature'] = auth.pop();
    queryParams['AWSAccessKeyId'] = auth.join(':');

    AWS.util.each(request.httpRequest.headers, function (key, value) {
      if (key === expiresHeader) key = 'Expires';
      if (key.indexOf('x-amz-meta-') === 0) {
        // Delete existing, potentially not normalized key
        delete queryParams[key];
        key = key.toLowerCase();
      }
      queryParams[key] = value;
    });
    delete request.httpRequest.headers[expiresHeader];
    delete queryParams['Authorization'];
    delete queryParams['Host'];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }

  // build URL
  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}

/**
 * @api private
 */
AWS.Signers.Presign = inherit({
  /**
   * @api private
   */
  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.Presign;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/request_signer.js":
/*!************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/request_signer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 's3v4': return AWS.Signers.V4;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
  }
  throw new Error('Unknown signing version ' + version);
};

__webpack_require__(/*! ./v2 */ "./node_modules/aws-sdk/lib/signers/v2.js");
__webpack_require__(/*! ./v3 */ "./node_modules/aws-sdk/lib/signers/v3.js");
__webpack_require__(/*! ./v3https */ "./node_modules/aws-sdk/lib/signers/v3https.js");
__webpack_require__(/*! ./v4 */ "./node_modules/aws-sdk/lib/signers/v4.js");
__webpack_require__(/*! ./s3 */ "./node_modules/aws-sdk/lib/signers/s3.js");
__webpack_require__(/*! ./presign */ "./node_modules/aws-sdk/lib/signers/presign.js");


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/s3.js":
/*!************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/s3.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
  /**
   * When building the stringToSign, these sub resource params should be
   * part of the canonical resource string with their NON-decoded values
   */
  subResources: {
    'acl': 1,
    'accelerate': 1,
    'analytics': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'inventory': 1,
    'location': 1,
    'logging': 1,
    'metrics': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  // when building the stringToSign, these querystring params should be
  // part of the canonical resource string with their NON-encoded values
  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      // presigned URLs require this header to be lowercased
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    // This is the "Date" header, but we use X-Amz-Date.
    // The S3 signing mechanism requires us to pass an empty
    // string for this Date header regardless.
    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      // collect a list of sub resources and query params that need to be signed
      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.S3;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/v2.js":
/*!************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/v2.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V2;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/v3.js":
/*!************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/v3.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V3;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/v3https.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/v3https.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var inherit = AWS.util.inherit;

__webpack_require__(/*! ./v3 */ "./node_modules/aws-sdk/lib/signers/v3.js");

/**
 * @api private
 */
AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.V3Https;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/v4.js":
/*!************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/v4.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var v4Credentials = __webpack_require__(/*! ./v4_credentials */ "./node_modules/aws-sdk/lib/signers/v4_credentials.js");
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, options) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    options = options || {};
    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
    this.operation = options.operation;
    this.signatureVersion = options.signatureVersion;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    // need to pull in any other X-Amz-* headers
    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        // Metadata should be normalized
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var signingKey = v4Credentials.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName,
      this.signatureCache
    );
    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        var value = item[1];
        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
            code: 'InvalidHeader'
          });
        }
        parts.push(key + ':' +
          this.canonicalHeaderValues(value.toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    return v4Credentials.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    var request = this.request;
    if (this.isPresigned() && (['s3', 's3-object-lambda'].indexOf(this.serviceName) > -1) && !request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (request.headers['X-Amz-Content-Sha256']) {
      return request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    expiresHeader,
    'expect',
    'x-amzn-trace-id'
  ],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V4;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/signers/v4_credentials.js":
/*!************************************************************!*\
  !*** ./node_modules/aws-sdk/lib/signers/v4_credentials.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");

/**
 * @api private
 */
var cachedSecret = {};

/**
 * @api private
 */
var cacheQueue = [];

/**
 * @api private
 */
var maxCacheEntries = 50;

/**
 * @api private
 */
var v4Identifier = 'aws4_request';

/**
 * @api private
 */
module.exports = {
  /**
   * @api private
   *
   * @param date [String]
   * @param region [String]
   * @param serviceName [String]
   * @return [String]
   */
  createScope: function createScope(date, region, serviceName) {
    return [
      date.substr(0, 8),
      region,
      serviceName,
      v4Identifier
    ].join('/');
  },

  /**
   * @api private
   *
   * @param credentials [Credentials]
   * @param date [String]
   * @param region [String]
   * @param service [String]
   * @param shouldCache [Boolean]
   * @return [String]
   */
  getSigningKey: function getSigningKey(
    credentials,
    date,
    region,
    service,
    shouldCache
  ) {
    var credsIdentifier = AWS.util.crypto
      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
    var cacheKey = [credsIdentifier, date, region, service].join('_');
    shouldCache = shouldCache !== false;
    if (shouldCache && (cacheKey in cachedSecret)) {
      return cachedSecret[cacheKey];
    }

    var kDate = AWS.util.crypto.hmac(
      'AWS4' + credentials.secretAccessKey,
      date,
      'buffer'
    );
    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
    if (shouldCache) {
      cachedSecret[cacheKey] = signingKey;
      cacheQueue.push(cacheKey);
      if (cacheQueue.length > maxCacheEntries) {
        // remove the oldest entry (not the least recently used)
        delete cachedSecret[cacheQueue.shift()];
      }
    }

    return signingKey;
  },

  /**
   * @api private
   *
   * Empties the derived signing key cache. Made available for testing purposes
   * only.
   */
  emptyCache: function emptyCache() {
    cachedSecret = {};
    cacheQueue = [];
  }
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/state_machine.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-sdk/lib/state_machine.js ***!
  \***************************************************/
/***/ ((module) => {

function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

/**
 * @api private
 */
module.exports = AcceptorStateMachine;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/util.js":
/*!******************************************!*\
  !*** ./node_modules/aws-sdk/lib/util.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint guard-for-in:0 */
var AWS;

/**
 * A set of utility methods for use with the AWS SDK.
 *
 * @!attribute abort
 *   Return this value from an iterator function {each} or {arrayEach}
 *   to break out of the iteration.
 *   @example Breaking out of an iterator function
 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
 *       if (key == 'b') return AWS.util.abort;
 *     });
 *   @see each
 *   @see arrayEach
 * @api private
 */
var util = {
  environment: 'nodejs',
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      var engine = process.platform + '/' + process.version;
      if (process.env.AWS_EXECUTION_ENV) {
        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
      }
      return engine;
    }
  },

  userAgent: function userAgent() {
    var name = util.environment;
    var agent = 'aws-sdk-' + name + '/' + (__webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js").VERSION);
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    // AWS percent-encodes some extra non-standard characters in a URI
    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return (__webpack_require__(/*! fs */ "fs").readFileSync)(path, 'utf-8');
  },

  base64: {
    encode: function encode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 encode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      var buf = util.buffer.toBuffer(string);
      return buf.toString('base64');
    },

    decode: function decode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 decode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      return util.buffer.toBuffer(string, 'base64');
    }

  },

  buffer: {
    /**
     * Buffer constructor for Node buffer and buffer pollyfill
     */
    toBuffer: function(data, encoding) {
      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ?
        util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
    },

    alloc: function(size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new Error('size passed to alloc must be a number.');
      }
      if (typeof util.Buffer.alloc === 'function') {
        return util.Buffer.alloc(size, fill, encoding);
      } else {
        var buf = new util.Buffer(size);
        if (fill !== undefined && typeof buf.fill === 'function') {
          buf.fill(fill, undefined, undefined, encoding);
        }
        return buf;
      }
    },

    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer =  util.buffer.toBuffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },

    /**
     * Concatenates a list of Buffer objects.
     */
    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = util.buffer.alloc(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = util.buffer.toBuffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return (__webpack_require__(/*! fs */ "fs").lstatSync)(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
        if (section) {
          currentSection = section[1];
          if (currentSection === '__proto__' || currentSection.split(/\s/)[1] === '__proto__') {
            throw util.error(
              new Error('Cannot load profile name \'' + currentSection + '\' from shared ini file.')
            );
          }
        } else if (currentSection) {
          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
          if (item) {
            map[currentSection] = map[currentSection] || {};
            map[currentSection][item[1]] = item[2];
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},
    callback: function (err) { if (err) throw err; },

    /**
     * Turn a synchronous function into as "async" function by making it call
     * a callback. The underlying function is called with all but the last argument,
     * which is treated as the callback. The callback is passed passed a first argument
     * of null on success to mimick standard node callbacks.
     */
    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },

  /**
   * Date and time utility functions.
   */
  date: {

    /**
     * @return [Date] the current JavaScript date object. Since all
     *   AWS services rely on this date object, you can override
     *   this function to provide a special time value to AWS service
     *   requests.
     */
    getDate: function getDate() {
      if (!AWS) AWS = __webpack_require__(/*! ./core */ "./node_modules/aws-sdk/lib/core.js");
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },

    /**
     * @return [String] the date in ISO-8601 format
     */
    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },

    /**
     * @return [String] the date in RFC 822 format
     */
    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },

    /**
     * @return [Integer] the UNIX timestamp value for the current time
     */
    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },

    /**
     * @param [String,number,Date] date
     * @return [Date]
     */
    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },

    /**
     * Given a Date or date-like value, this function formats the
     * date into a string of the requested value.
     * @param [String,number,Date] date
     * @param [String] formatter Valid formats are:
     #   * 'iso8601'
     #   * 'rfc822'
     #   * 'unixTimestamp'
     * @return [String]
     */
    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = util.buffer.toBuffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = util.buffer.toBuffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = util.buffer.toBuffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      //Identifying objects with an ArrayBuffer as buffers
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        // this might be a File/Blob
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },

  /** @!ignore */

  /* Abort constant */
  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    // jshint forin:false
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    // handle cross-"frame" objects
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = String(options && options.name || err.name || err.code || 'Error');
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },

  /**
   * @api private
   */
  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    // constructor not supplied, create pass-through ctor
    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },

  /**
   * @api private
   */
  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      // jshint forin:false
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },

  /**
   * @api private
   */
  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },

  /**
   * @api private
   */
  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },

  /**
   * @api private
   */
  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    // build enumerable attribute for each value with lazy accessor.
    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },

  /**
   * TODO Remove in major version revision
   * This backfill populates response data without the
   * top-level payload name.
   *
   * @api private
   */
  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operationName = req.operation;
    var operation = req.service.api.operations[operationName];
    var output = operation.output;
    if (output.payload && !operation.hasEventOutput) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },

  /**
   * Compute SHA-256 checksums of streams
   *
   * @api private
   */
  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = __webpack_require__(/*! fs */ "fs");
      if (typeof Stream === 'function' && body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },

  /**
   * @api private
   */
  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },

  /**
   * @api private
   */
  addPromises: function addPromises(constructors, PromiseDependency) {
    var deletePromises = false;
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },

  /**
   * @api private
   * Return a function that will return a promise whose fate is decided by the
   * callback behavior of the given method with `methodName`. The method to be
   * promisified should conform to node.js convention of accepting a callback as
   * last argument and calling that callback with error as the first argument
   * and success value on the second argument.
   */
  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      return new PromiseDependency(function(resolve, reject) {
        args.push(function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        self[methodName].apply(self, args);
      });
    };
  },

  /**
   * @api private
   */
  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = __webpack_require__(/*! ../apis/metadata.json */ "./node_modules/aws-sdk/apis/metadata.json");
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },

  /**
   * @api private
   */
  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount, err);
    }
    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },

  /**
   * @api private
   */
  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;

      // Call `calculateRetryDelay()` only when relevant, see #3401
      if (err && err.retryable && retryCount < maxRetries) {
        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
        if (delay >= 0) {
          retryCount++;
          setTimeout(sendRequest, delay + (err.retryAfter || 0));
          return;
        }
      }
      cb(err);
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              {
                statusCode: statusCode,
                retryable: statusCode >= 500 || statusCode === 429
              }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    AWS.util.defer(sendRequest);
  },

  /**
   * @api private
   */
  uuid: {
    v4: function uuidV4() {
      return (__webpack_require__(/*! uuid */ "./node_modules/uuid/index.js").v4)();
    }
  },

  /**
   * @api private
   */
  convertPayloadToString: function convertPayloadToString(resp) {
    var req = resp.request;
    var operation = req.operation;
    var rules = req.service.api.operations[operation].output || {};
    if (rules.payload && resp.data[rules.payload]) {
      resp.data[rules.payload] = resp.data[rules.payload].toString();
    }
  },

  /**
   * @api private
   */
  defer: function defer(callback) {
    if (typeof process === 'object' && typeof process.nextTick === 'function') {
      process.nextTick(callback);
    } else if (typeof setImmediate === 'function') {
      setImmediate(callback);
    } else {
      setTimeout(callback, 0);
    }
  },

  /**
   * @api private
   */
  getRequestPayloadShape: function getRequestPayloadShape(req) {
    var operations = req.service.api.operations;
    if (!operations) return undefined;
    var operation = (operations || {})[req.operation];
    if (!operation || !operation.input || !operation.input.payload) return undefined;
    return operation.input.members[operation.input.payload];
  },

  getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
    var profiles = {};
    var profilesFromConfig = {};
    if (process.env[util.configOptInEnv]) {
      var profilesFromConfig = iniLoader.loadFrom({
        isConfig: true,
        filename: process.env[util.sharedConfigFileEnv]
      });
    }
    var profilesFromCreds= {};
    try {
      var profilesFromCreds = iniLoader.loadFrom({
        filename: filename ||
          (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv])
      });
    } catch (error) {
      // if using config, assume it is fully descriptive without a credentials file:
      if (!process.env[util.configOptInEnv]) throw error;
    }
    for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
    }
    for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
    }
    return profiles;

    /**
     * Roughly the semantics of `Object.assign(target, source)`
     */
    function objectAssign(target, source) {
      for (var i = 0, keys = Object.keys(source); i < keys.length; i++) {
        target[keys[i]] = source[keys[i]];
      }
      return target;
    }
  },

  /**
   * @api private
   */
  ARN: {
    validate: function validateARN(str) {
      return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
    },
    parse: function parseARN(arn) {
      var matched = arn.split(':');
      return {
        partition: matched[1],
        service: matched[2],
        region: matched[3],
        accountId: matched[4],
        resource: matched.slice(5).join(':')
      };
    },
    build: function buildARN(arnObject) {
      if (
        arnObject.service === undefined ||
        arnObject.region === undefined ||
        arnObject.accountId === undefined ||
        arnObject.resource === undefined
      ) throw util.error(new Error('Input ARN object is invalid'));
      return 'arn:'+ (arnObject.partition || 'aws') + ':' + arnObject.service +
        ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
    }
  },

  /**
   * @api private
   */
  defaultProfile: 'default',

  /**
   * @api private
   */
  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

  /**
   * @api private
   */
  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

  /**
   * @api private
   */
  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

  /**
   * @api private
   */
  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
};

/**
 * @api private
 */
module.exports = util;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/xml/builder.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-sdk/lib/xml/builder.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/aws-sdk/lib/util.js");
var XmlNode = (__webpack_require__(/*! ./xml-node */ "./node_modules/aws-sdk/lib/xml/xml-node.js").XmlNode);
var XmlText = (__webpack_require__(/*! ./xml-text */ "./node_modules/aws-sdk/lib/xml/xml-text.js").XmlText);

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = new XmlNode(rootElement);
  applyNamespaces(xml, shape, true);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.addAttribute(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = new XmlNode(name);
        xml.addChildNode(element);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
    xml.addChildNode(entry);

    var entryKey = new XmlNode(xmlKey);
    var entryValue = new XmlNode(xmlValue);
    entry.addChildNode(entryKey);
    entry.addChildNode(entryValue);

    serialize(entryKey, key, shape.key);
    serialize(entryValue, value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.addChildNode(
    new XmlText(shape.toWireFormat(value))
  );
}

function applyNamespaces(xml, shape, isRoot) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.addAttribute(prefix, uri);
}

/**
 * @api private
 */
module.exports = XmlBuilder;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/xml/escape-attribute.js":
/*!**********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/xml/escape-attribute.js ***!
  \**********************************************************/
/***/ ((module) => {

/**
 * Escapes characters that can not be in an XML attribute.
 */
function escapeAttribute(value) {
    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/**
 * @api private
 */
module.exports = {
    escapeAttribute: escapeAttribute
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/xml/escape-element.js":
/*!********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/xml/escape-element.js ***!
  \********************************************************/
/***/ ((module) => {

/**
 * Escapes characters that can not be in an XML element.
 */
function escapeElement(value) {
    return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\r/g, '&#x0D;')
                .replace(/\n/g, '&#x0A;')
                .replace(/\u0085/g, '&#x85;')
                .replace(/\u2028/, '&#x2028;');
}

/**
 * @api private
 */
module.exports = {
    escapeElement: escapeElement
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/xml/node_parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-sdk/lib/xml/node_parser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var AWS = __webpack_require__(/*! ../core */ "./node_modules/aws-sdk/lib/core.js");
var util = AWS.util;
var Shape = AWS.Model.Shape;

var xml2js = __webpack_require__(/*! xml2js */ "./node_modules/xml2js/lib/xml2js.js");

/**
 * @api private
 */
var options = {  // options passed to xml2js parser
  explicitCharkey: false, // undocumented
  trim: false,            // trim the leading/trailing whitespace from text nodes
  normalize: false,       // trim interior whitespace inside text nodes
  explicitRoot: false,    // return the root node in the resulting object?
  emptyTag: null,         // the default value for empty nodes
  explicitArray: true,    // always put child nodes in an array
  ignoreAttrs: false,     // ignore attributes, only create text nodes
  mergeAttrs: false,      // merge attributes and child elements
  validator: null         // a callable validator
};

function NodeXmlParser() { }

NodeXmlParser.prototype.parse = function(xml, shape) {
  shape = shape || {};

  var result = null;
  var error = null;

  var parser = new xml2js.Parser(options);
  parser.parseString(xml, function (e, r) {
    error = e;
    result = r;
  });

  if (result) {
    var data = parseXml(result, shape);
    if (result.ResponseMetadata) {
      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
    }
    return data;
  } else if (error) {
    throw util.error(error, {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return parseXml({}, shape);
  }
};

function parseXml(xml, shape) {
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    var xmlName = memberShape.name;
    if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
      var xmlChild = xml[xmlName];
      if (!memberShape.flattened) xmlChild = xmlChild[0];

      data[memberName] = parseXml(xmlChild, memberShape);
    } else if (memberShape.isXmlAttribute &&
               xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
      data[memberName] = parseScalar(xml.$[xmlName], memberShape);
    } else if (memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {
      data[memberName] = memberShape.defaultValue;
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  if (xml === null) return data;

  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var iterable = shape.flattened ? xml : xml.entry;

  if (Array.isArray(iterable)) {
    util.arrayEach(iterable, function(child) {
      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
    });
  }

  return data;
}

function parseList(xml, shape) {
  var data = [];
  var name = shape.member.name || 'member';
  if (shape.flattened) {
    util.arrayEach(xml, function(xmlChild) {
      data.push(parseXml(xmlChild, shape.member));
    });
  } else if (xml && Array.isArray(xml[name])) {
    util.arrayEach(xml[name], function(child) {
      data.push(parseXml(child, shape.member));
    });
  }

  return data;
}

function parseScalar(text, shape) {
  if (text && text.$ && text.$.encoding === 'base64') {
    shape = new Shape.create({type: text.$.encoding});
  }
  if (text && text._) text = text._;

  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';
  if (typeof xml === 'string') return xml;

  // parse a list
  if (Array.isArray(xml)) {
    var arr = [];
    for (i = 0; i < xml.length; i++) {
      arr.push(parseXml(xml[i], {}));
    }
    return arr;
  }

  // empty object
  var keys = Object.keys(xml), i;
  if (keys.length === 0 || (keys.length === 1 && keys[0] === '$')) {
    return {};
  }

  // object, parse as structure
  var data = {};
  for (i = 0; i < keys.length; i++) {
    var key = keys[i], value = xml[key];
    if (key === '$') continue;
    if (value.length > 1) { // this member is a list
      data[key] = parseList(value, {member: {}});
    } else { // this member is a single item
      data[key] = parseXml(value[0], {});
    }
  }
  return data;
}

/**
 * @api private
 */
module.exports = NodeXmlParser;


/***/ }),

/***/ "./node_modules/aws-sdk/lib/xml/xml-node.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/lib/xml/xml-node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeAttribute = (__webpack_require__(/*! ./escape-attribute */ "./node_modules/aws-sdk/lib/xml/escape-attribute.js").escapeAttribute);

/**
 * Represents an XML node.
 * @api private
 */
function XmlNode(name, children) {
    if (children === void 0) { children = []; }
    this.name = name;
    this.children = children;
    this.attributes = {};
}
XmlNode.prototype.addAttribute = function (name, value) {
    this.attributes[name] = value;
    return this;
};
XmlNode.prototype.addChildNode = function (child) {
    this.children.push(child);
    return this;
};
XmlNode.prototype.removeAttribute = function (name) {
    delete this.attributes[name];
    return this;
};
XmlNode.prototype.toString = function () {
    var hasChildren = Boolean(this.children.length);
    var xmlText = '<' + this.name;
    // add attributes
    var attributes = this.attributes;
    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== 'undefined' && attribute !== null) {
            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
        }
    }
    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
};

/**
 * @api private
 */
module.exports = {
    XmlNode: XmlNode
};


/***/ }),

/***/ "./node_modules/aws-sdk/lib/xml/xml-text.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-sdk/lib/xml/xml-text.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeElement = (__webpack_require__(/*! ./escape-element */ "./node_modules/aws-sdk/lib/xml/escape-element.js").escapeElement);

/**
 * Represents an XML text value.
 * @api private
 */
function XmlText(value) {
    this.value = value;
}

XmlText.prototype.toString = function () {
    return escapeElement('' + this.value);
};

/**
 * @api private
 */
module.exports = {
    XmlText: XmlText
};


/***/ }),

/***/ "./node_modules/aws-sdk/vendor/endpoint-cache/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/aws-sdk/vendor/endpoint-cache/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LRU_1 = __webpack_require__(/*! ./utils/LRU */ "./node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js");
var CACHE_SIZE = 1000;
/**
 * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
 */
var EndpointCache = /** @class */ (function () {
    function EndpointCache(maxSize) {
        if (maxSize === void 0) { maxSize = CACHE_SIZE; }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
    }
    ;
    Object.defineProperty(EndpointCache.prototype, "size", {
        get: function () {
            return this.cache.length;
        },
        enumerable: true,
        configurable: true
    });
    EndpointCache.prototype.put = function (key, value) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
    };
    EndpointCache.prototype.get = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
            for (var i = records.length-1; i >= 0; i--) {
                var record = records[i];
                if (record.Expire < now) {
                    records.splice(i, 1);
                }
            }
            if (records.length === 0) {
                this.cache.remove(keyString);
                return undefined;
            }
        }
        return records;
    };
    EndpointCache.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
            var identifierName = identifierNames[i];
            if (key[identifierName] === undefined)
                continue;
            identifiers.push(key[identifierName]);
        }
        return identifiers.join(' ');
    };
    EndpointCache.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) { return ({
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
        }); });
    };
    EndpointCache.prototype.empty = function () {
        this.cache.empty();
    };
    EndpointCache.prototype.remove = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        this.cache.remove(keyString);
    };
    return EndpointCache;
}());
exports.EndpointCache = EndpointCache;

/***/ }),

/***/ "./node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js":
/*!*****************************************************************!*\
  !*** ./node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LinkedListNode = /** @class */ (function () {
    function LinkedListNode(key, value) {
        this.key = key;
        this.value = value;
    }
    return LinkedListNode;
}());
var LRUCache = /** @class */ (function () {
    function LRUCache(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== 'number' || size < 1) {
            throw new Error('Cache size can only be positive number');
        }
        this.sizeLimit = size;
    }
    Object.defineProperty(LRUCache.prototype, "length", {
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    LRUCache.prototype.prependToList = function (node) {
        if (!this.headerNode) {
            this.tailNode = node;
        }
        else {
            this.headerNode.prev = node;
            node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
    };
    LRUCache.prototype.removeFromTail = function () {
        if (!this.tailNode) {
            return undefined;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
            prevNode.next = undefined;
        }
        node.prev = undefined;
        this.tailNode = prevNode;
        this.size--;
        return node;
    };
    LRUCache.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
            this.headerNode = node.next;
        }
        if (this.tailNode === node) {
            this.tailNode = node.prev;
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        node.next = undefined;
        node.prev = undefined;
        this.size--;
    };
    LRUCache.prototype.get = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            this.prependToList(node);
            return node.value;
        }
    };
    LRUCache.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    LRUCache.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
            this.remove(key);
        }
        else if (this.size === this.sizeLimit) {
            var tailNode = this.removeFromTail();
            var key_1 = tailNode.key;
            delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
    };
    LRUCache.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    return LRUCache;
}());
exports.LRUCache = LRUCache;

/***/ }),

/***/ "./node_modules/jmespath/jmespath.js":
/*!*******************************************!*\
  !*** ./node_modules/jmespath/jmespath.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
            break;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
            break;
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                // Creating a projection.
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
            break;
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
            break;
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})( false ? 0 : exports);


/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = (__webpack_require__(/*! stream */ "stream").Stream)
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = (__webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder)
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // character classes and tokens
  var whitespace = '\r\n\t '

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var number = '0124356789'
  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

  // (Letter | "_" | ":")
  var quote = '\'"'
  var attribEnd = whitespace + '>'
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // turn all the string character sets into character class objects.
  whitespace = charClass(whitespace)
  number = charClass(number)
  letter = charClass(letter)

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  quote = charClass(quote)
  attribEnd = charClass(attribEnd)

  function charClass (str) {
    return str.split('').reduce(function (s, c) {
      s[c] = true
      return s
    }, {})
  }

  function isRegExp (c) {
    return Object.prototype.toString.call(c) === '[object RegExp]'
  }

  function is (charclass, c) {
    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
  }

  function not (charclass, c) {
    return !is(charclass, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (not(whitespace, c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c
      if (!c) {
        break
      }
      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }
      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (is(whitespace, c)) {
            // wait for it...
          } else if (is(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (is(quote, c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (is(quote, c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (is(quote, c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (is(whitespace, c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && is(whitespace, c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (is(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (not(whitespace, c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (is(whitespace, c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (is(whitespace, c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (is(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (is(whitespace, c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (is(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (is(whitespace, c)) {
            continue
          } else if (is(quote, c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (is(whitespace, c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (not(attribEnd, c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (is(whitespace, c)) {
              continue
            } else if (not(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (is(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (not(whitespace, c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (is(whitespace, c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? 0 : exports)


/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng.js":
/*!**************************************!*\
  !*** ./node_modules/uuid/lib/rng.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/xml2js/lib/bom.js":
/*!****************************************!*\
  !*** ./node_modules/xml2js/lib/bom.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/builder.js":
/*!********************************************!*\
  !*** ./node_modules/xml2js/lib/builder.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    hasProp = {}.hasOwnProperty;

  builder = __webpack_require__(/*! xmlbuilder */ "./node_modules/xmlbuilder/lib/index.js");

  defaults = (__webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js").defaults);

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else if (Array.isArray(obj)) {
            for (index in obj) {
              if (!hasProp.call(obj, index)) continue;
              child = obj[index];
              for (key in child) {
                entry = child[key];
                element = render(element.ele(key), entry).up();
              }
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/defaults.js":
/*!*********************************************!*\
  !*** ./node_modules/xml2js/lib/defaults.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xml2js/lib/parser.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  sax = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");

  events = __webpack_require__(/*! events */ "events");

  bom = __webpack_require__(/*! ./bom */ "./node_modules/xml2js/lib/bom.js");

  processors = __webpack_require__(/*! ./processors */ "./node_modules/xml2js/lib/processors.js");

  setImmediate = (__webpack_require__(/*! timers */ "timers").setImmediate);

  defaults = (__webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js").defaults);

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processItem = function(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk, err;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.onend = (function(_this) {
        return function() {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            (function() {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                err = error1;
                return _this.emit("error", err);
              }
            })();
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              if (_this.options.normalize) {
                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
              }
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    return Parser;

  })(events.EventEmitter);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/processors.js":
/*!***********************************************!*\
  !*** ./node_modules/xml2js/lib/processors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function(str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xml2js/lib/xml2js.js":
/*!*******************************************!*\
  !*** ./node_modules/xml2js/lib/xml2js.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, parser, processors,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  defaults = __webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js");

  builder = __webpack_require__(/*! ./builder */ "./node_modules/xml2js/lib/builder.js");

  parser = __webpack_require__(/*! ./parser */ "./node_modules/xml2js/lib/parser.js");

  processors = __webpack_require__(/*! ./processors */ "./node_modules/xml2js/lib/processors.js");

  exports.defaults = defaults.defaults;

  exports.processors = processors;

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = builder.Builder;

  exports.Parser = parser.Parser;

  exports.parseString = parser.parseString;

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/Utility.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/Utility.js ***!
  \************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  assign = function() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \*****************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute;

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.options = parent.options;
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return Object.create(this);
    };

    XMLAttribute.prototype.toString = function(options) {
      return this.options.writer.set(options).attribute(this);
    };

    return XMLAttribute;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCData.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCData.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCData.prototype.toString = function(options) {
      return this.options.writer.set(options).cdata(this);
    };

    return XMLCData;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLComment.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLComment.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLComment, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return Object.create(this);
    };

    XMLComment.prototype.toString = function(options) {
      return this.options.writer.set(options).comment(this);
    };

    return XMLComment;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDAttList = (function(superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdAttList(this);
    };

    return XMLDTDAttList;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDElement, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDElement = (function(superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdElement(this);
    };

    return XMLDTDElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDEntity, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDEntity = (function(superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdEntity(this);
    };

    return XMLDTDEntity;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDNotation, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDTDNotation = (function(superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdNotation(this);
    };

    return XMLDTDNotation;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDeclaration, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options) {
      return this.options.writer.set(options).declaration(this);
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocType.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  module.exports = XMLDocType = (function(superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      XMLDocType.__super__.constructor.call(this, parent);
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function(options) {
      return this.options.writer.set(options).docType(this);
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root() || this.documentObject;
    };

    return XMLDocType;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocument.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocument.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isPlainObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js").isPlainObject);

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  module.exports = XMLDocument = (function(superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      this.isDocument = true;
    }

    XMLDocument.prototype.end = function(writer) {
      var writerOptions;
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer.set(writerOptions);
      }
      return writer.document(this);
    };

    XMLDocument.prototype.toString = function(options) {
      return this.options.writer.set(options).document(this);
    };

    return XMLDocument;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xmlbuilder/lib/XMLAttribute.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  module.exports = XMLDocumentCB = (function() {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter(options);
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter(writerOptions);
      }
      this.options = options;
      this.writer = options.writer;
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.node = function(name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node");
      }
      this.openCurrent();
      name = name.valueOf();
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function(name, attributes, text) {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.dtdElement.apply(this, arguments);
      } else {
        return this.node(name, attributes, text);
      }
    };

    XMLDocumentCB.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode");
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.cdata = function(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.comment = function(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.raw = function(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.entity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.notation = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.up = function() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function(node) {
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
          this.root = node;
        }
        this.onData(this.writer.openNode(node, this.currentLevel));
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function(node) {
      if (!node.isClosed) {
        this.onData(this.writer.closeNode(node, this.currentLevel));
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function(chunk) {
      this.documentStarted = true;
      return this.onDataCallback(chunk);
    };

    XMLDocumentCB.prototype.onEnd = function() {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.ele = function() {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLElement.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLElement.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xmlbuilder/lib/XMLAttribute.js");

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.isDocument) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, ref1;
      clonedSelf = Object.create(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref1 = this.attributes;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function(options) {
      return this.options.writer.set(options).element(this);
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNode.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNode.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.children = [];
      if (!XMLElement) {
        XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");
        XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");
        XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");
        XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");
        XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");
        XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");
        XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");
        XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
      }
    }

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref1;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref1;
      if (name != null) {
        name = name.valueOf();
      }
      attributes || (attributes = {});
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.instruction = function(target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children[0] instanceof XMLDeclaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref1 = doc.children;
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        child = ref1[i];
        if (child instanceof XMLDocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref2 = doc.children;
      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
        child = ref2[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function(options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function(doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function(doc) {
      return this.importDocument(doc);
    };

    return XMLNode;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLProcessingInstruction,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLProcessingInstruction = (function(superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return Object.create(this);
    };

    XMLProcessingInstruction.prototype.toString = function(options) {
      return this.options.writer.set(options).processingInstruction(this);
    };

    return XMLProcessingInstruction;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLRaw.js":
/*!***********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLRaw,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return Object.create(this);
    };

    XMLRaw.prototype.toString = function(options) {
      return this.options.writer.set(options).raw(this);
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xmlbuilder/lib/XMLWriterBase.js");

  module.exports = XMLStreamWriter = (function(superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      XMLStreamWriter.__super__.constructor.call(this, options);
      this.stream = stream;
    }

    XMLStreamWriter.prototype.document = function(doc) {
      var child, i, j, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.isLastRootNode = false;
      }
      doc.children[doc.children.length - 1].isLastRootNode = true;
      ref1 = doc.children;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        child = ref1[j];
        switch (false) {
          case !(child instanceof XMLDeclaration):
            results.push(this.declaration(child));
            break;
          case !(child instanceof XMLDocType):
            results.push(this.docType(child));
            break;
          case !(child instanceof XMLComment):
            results.push(this.comment(child));
            break;
          case !(child instanceof XMLProcessingInstruction):
            results.push(this.processingInstruction(child));
            break;
          default:
            results.push(this.element(child));
        }
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function(att) {
      return this.stream.write(' ' + att.name + '="' + att.value + '"');
    };

    XMLStreamWriter.prototype.cdata = function(node, level) {
      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
    };

    XMLStreamWriter.prototype.comment = function(node, level) {
      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
    };

    XMLStreamWriter.prototype.declaration = function(node, level) {
      this.stream.write(this.space(level));
      this.stream.write('<?xml version="' + node.version + '"');
      if (node.encoding != null) {
        this.stream.write(' encoding="' + node.encoding + '"');
      }
      if (node.standalone != null) {
        this.stream.write(' standalone="' + node.standalone + '"');
      }
      this.stream.write(this.spacebeforeslash + '?>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.docType = function(node, level) {
      var child, i, len, ref;
      level || (level = 0);
      this.stream.write(this.space(level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node));
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          switch (false) {
            case !(child instanceof XMLDTDAttList):
              this.dtdAttList(child, level + 1);
              break;
            case !(child instanceof XMLDTDElement):
              this.dtdElement(child, level + 1);
              break;
            case !(child instanceof XMLDTDEntity):
              this.dtdEntity(child, level + 1);
              break;
            case !(child instanceof XMLDTDNotation):
              this.dtdNotation(child, level + 1);
              break;
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown DTD node type: " + child.constructor.name);
          }
        }
        this.stream.write(']');
      }
      this.stream.write(this.spacebeforeslash + '>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.element = function(node, level) {
      var att, child, i, len, name, ref, ref1, space;
      level || (level = 0);
      space = this.space(level);
      this.stream.write(space + '<' + node.name);
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          this.stream.write('></' + node.name + '>');
        } else {
          this.stream.write(this.spacebeforeslash + '/>');
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        this.stream.write('>');
        this.stream.write(node.children[0].value);
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.newline);
        ref1 = node.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          switch (false) {
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLElement):
              this.element(child, level + 1);
              break;
            case !(child instanceof XMLRaw):
              this.raw(child, level + 1);
              break;
            case !(child instanceof XMLText):
              this.text(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown XML node type: " + child.constructor.name);
          }
        }
        this.stream.write(space + '</' + node.name + '>');
      }
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
      this.stream.write(this.space(level) + '<?' + node.target);
      if (node.value) {
        this.stream.write(' ' + node.value);
      }
      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
    };

    XMLStreamWriter.prototype.raw = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.text = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
      if (node.defaultValueType !== '#DEFAULT') {
        this.stream.write(' ' + node.defaultValueType);
      }
      if (node.defaultValue) {
        this.stream.write(' "' + node.defaultValue + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdElement = function(node, level) {
      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
      this.stream.write(this.space(level) + '<!ENTITY');
      if (node.pe) {
        this.stream.write(' %');
      }
      this.stream.write(' ' + node.name);
      if (node.value) {
        this.stream.write(' "' + node.value + '"');
      } else {
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.nData) {
          this.stream.write(' NDATA ' + node.nData);
        }
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.pubID) {
        this.stream.write(' PUBLIC "' + node.pubID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.endline = function(node) {
      if (!node.isLastRootNode) {
        return this.newline;
      } else {
        return '';
      }
    };

    return XMLStreamWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xmlbuilder/lib/XMLWriterBase.js");

  module.exports = XMLStringWriter = (function(superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function(doc) {
      var child, i, len, r, ref;
      this.textispresent = false;
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += (function() {
          switch (false) {
            case !(child instanceof XMLDeclaration):
              return this.declaration(child);
            case !(child instanceof XMLDocType):
              return this.docType(child);
            case !(child instanceof XMLComment):
              return this.comment(child);
            case !(child instanceof XMLProcessingInstruction):
              return this.processingInstruction(child);
            default:
              return this.element(child, 0);
          }
        }).call(this);
      }
      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
        r = r.slice(0, -this.newline.length);
      }
      return r;
    };

    XMLStringWriter.prototype.attribute = function(att) {
      return ' ' + att.name + '="' + att.value + '"';
    };

    XMLStringWriter.prototype.cdata = function(node, level) {
      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
    };

    XMLStringWriter.prototype.comment = function(node, level) {
      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
    };

    XMLStringWriter.prototype.declaration = function(node, level) {
      var r;
      r = this.space(level);
      r += '<?xml version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      r += this.spacebeforeslash + '?>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.docType = function(node, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      r = this.space(level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.newline;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLDTDAttList):
                return this.dtdAttList(child, level + 1);
              case !(child instanceof XMLDTDElement):
                return this.dtdElement(child, level + 1);
              case !(child instanceof XMLDTDEntity):
                return this.dtdEntity(child, level + 1);
              case !(child instanceof XMLDTDNotation):
                return this.dtdNotation(child, level + 1);
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }).call(this);
        }
        r += ']';
      }
      r += this.spacebeforeslash + '>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.element = function(node, level) {
      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
      level || (level = 0);
      textispresentwasset = false;
      if (this.textispresent) {
        this.newline = '';
        this.pretty = false;
      } else {
        this.newline = this.newlinedefault;
        this.pretty = this.prettydefault;
      }
      space = this.space(level);
      r = '';
      r += space + '<' + node.name;
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          r += '></' + node.name + '>' + this.newline;
        } else {
          r += this.spacebeforeslash + '/>' + this.newline;
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        r += '>';
        r += node.children[0].value;
        r += '</' + node.name + '>' + this.newline;
      } else {
        if (this.dontprettytextnodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if (child.value != null) {
              this.textispresent++;
              textispresentwasset = true;
              break;
            }
          }
        }
        if (this.textispresent) {
          this.newline = '';
          this.pretty = false;
          space = this.space(level);
        }
        r += '>' + this.newline;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLElement):
                return this.element(child, level + 1);
              case !(child instanceof XMLRaw):
                return this.raw(child, level + 1);
              case !(child instanceof XMLText):
                return this.text(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }).call(this);
        }
        if (textispresentwasset) {
          this.textispresent--;
        }
        if (!this.textispresent) {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        r += space + '</' + node.name + '>' + this.newline;
      }
      return r;
    };

    XMLStringWriter.prototype.processingInstruction = function(node, level) {
      var r;
      r = this.space(level) + '<?' + node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      r += this.spacebeforeslash + '?>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.raw = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.text = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.dtdAttList = function(node, level) {
      var r;
      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdElement = function(node, level) {
      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
    };

    XMLStringWriter.prototype.dtdEntity = function(node, level) {
      var r;
      r = this.space(level) + '<!ENTITY';
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdNotation = function(node, level) {
      var r;
      r = this.space(level) + '<!NOTATION ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.openNode = function(node, level) {
      var att, name, r, ref;
      level || (level = 0);
      if (node instanceof XMLElement) {
        r = this.space(level) + '<' + node.name;
        ref = node.attributes;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att);
        }
        r += (node.children ? '>' : '/>') + this.newline;
        return r;
      } else {
        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        r += (node.children ? ' [' : '>') + this.newline;
        return r;
      }
    };

    XMLStringWriter.prototype.closeNode = function(node, level) {
      level || (level = 0);
      switch (false) {
        case !(node instanceof XMLElement):
          return this.space(level) + '</' + node.name + '>' + this.newline;
        case !(node instanceof XMLDocType):
          return this.space(level) + ']>' + this.newline;
      }
    };

    return XMLStringWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \*******************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.noDoubleEncoding = options.noDoubleEncoding;
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return val = '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var res;
      res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
      if (res) {
        throw new Error("Invalid character in string: " + str + " at index " + res.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLText.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLText.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return Object.create(this);
    };

    XMLText.prototype.toString = function(options) {
      return this.options.writer.set(options).text(this);
    };

    return XMLText;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLWriterBase.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
  \******************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLWriterBase,
    hasProp = {}.hasOwnProperty;

  module.exports = XMLWriterBase = (function() {
    function XMLWriterBase(options) {
      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
      options || (options = {});
      this.pretty = options.pretty || false;
      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
      if (this.pretty) {
        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref6 = options.writer || {};
      for (key in ref6) {
        if (!hasProp.call(ref6, key)) continue;
        value = ref6[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.set = function(options) {
      var key, ref, value;
      options || (options = {});
      if ("pretty" in options) {
        this.pretty = options.pretty;
      }
      if ("allowEmpty" in options) {
        this.allowEmpty = options.allowEmpty;
      }
      if (this.pretty) {
        this.indent = "indent" in options ? options.indent : '  ';
        this.newline = "newline" in options ? options.newline : '\n';
        this.offset = "offset" in options ? options.offset : 0;
        this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
      return this;
    };

    XMLWriterBase.prototype.space = function(level) {
      var indent;
      if (this.pretty) {
        indent = (level || 0) + this.offset + 1;
        if (indent > 0) {
          return new Array(indent).join(this.indent);
        } else {
          return '';
        }
      } else {
        return '';
      }
    };

    return XMLWriterBase;

  })();

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"), assign = ref.assign, isFunction = ref.isFunction;

  XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xmlbuilder/lib/XMLDocument.js");

  XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js");

  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.doctype(options);
      }
    }
    return root;
  };

  module.exports.begin = function(options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

}).call(this);


/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "dgram":
/*!************************!*\
  !*** external "dgram" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("dgram");

/***/ }),

/***/ "domain":
/*!*************************!*\
  !*** external "domain" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("domain");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json":
/*!************************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2014-06-30","endpointPrefix":"cognito-identity","jsonVersion":"1.1","protocol":"json","serviceFullName":"Amazon Cognito Identity","serviceId":"Cognito Identity","signatureVersion":"v4","targetPrefix":"AWSCognitoIdentityService","uid":"cognito-identity-2014-06-30"},"operations":{"CreateIdentityPool":{"input":{"type":"structure","required":["IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"AllowClassicFlow":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S5"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S9"},"CognitoIdentityProviders":{"shape":"Sb"},"SamlProviderARNs":{"shape":"Sg"},"IdentityPoolTags":{"shape":"Sh"}}},"output":{"shape":"Sk"}},"DeleteIdentities":{"input":{"type":"structure","required":["IdentityIdsToDelete"],"members":{"IdentityIdsToDelete":{"type":"list","member":{}}}},"output":{"type":"structure","members":{"UnprocessedIdentityIds":{"type":"list","member":{"type":"structure","members":{"IdentityId":{},"ErrorCode":{}}}}}}},"DeleteIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}}},"DescribeIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{}}},"output":{"shape":"Sv"}},"DescribeIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"shape":"Sk"}},"GetCredentialsForIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"S10"},"CustomRoleArn":{}}},"output":{"type":"structure","members":{"IdentityId":{},"Credentials":{"type":"structure","members":{"AccessKeyId":{},"SecretKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}}}},"authtype":"none"},"GetId":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"AccountId":{},"IdentityPoolId":{},"Logins":{"shape":"S10"}}},"output":{"type":"structure","members":{"IdentityId":{}}},"authtype":"none"},"GetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Roles":{"shape":"S1c"},"RoleMappings":{"shape":"S1e"}}}},"GetOpenIdToken":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"S10"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}},"authtype":"none"},"GetOpenIdTokenForDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId","Logins"],"members":{"IdentityPoolId":{},"IdentityId":{},"Logins":{"shape":"S10"},"PrincipalTags":{"shape":"S1s"},"TokenDuration":{"type":"long"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"GetPrincipalTagAttributeMap":{"input":{"type":"structure","required":["IdentityPoolId","IdentityProviderName"],"members":{"IdentityPoolId":{},"IdentityProviderName":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"IdentityProviderName":{},"UseDefaults":{"type":"boolean"},"PrincipalTags":{"shape":"S1s"}}}},"ListIdentities":{"input":{"type":"structure","required":["IdentityPoolId","MaxResults"],"members":{"IdentityPoolId":{},"MaxResults":{"type":"integer"},"NextToken":{},"HideDisabled":{"type":"boolean"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Identities":{"type":"list","member":{"shape":"Sv"}},"NextToken":{}}}},"ListIdentityPools":{"input":{"type":"structure","required":["MaxResults"],"members":{"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityPools":{"type":"list","member":{"type":"structure","members":{"IdentityPoolId":{},"IdentityPoolName":{}}}},"NextToken":{}}}},"ListTagsForResource":{"input":{"type":"structure","required":["ResourceArn"],"members":{"ResourceArn":{}}},"output":{"type":"structure","members":{"Tags":{"shape":"Sh"}}}},"LookupDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{},"IdentityId":{},"DeveloperUserIdentifier":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityId":{},"DeveloperUserIdentifierList":{"type":"list","member":{}},"NextToken":{}}}},"MergeDeveloperIdentities":{"input":{"type":"structure","required":["SourceUserIdentifier","DestinationUserIdentifier","DeveloperProviderName","IdentityPoolId"],"members":{"SourceUserIdentifier":{},"DestinationUserIdentifier":{},"DeveloperProviderName":{},"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"SetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId","Roles"],"members":{"IdentityPoolId":{},"Roles":{"shape":"S1c"},"RoleMappings":{"shape":"S1e"}}}},"SetPrincipalTagAttributeMap":{"input":{"type":"structure","required":["IdentityPoolId","IdentityProviderName"],"members":{"IdentityPoolId":{},"IdentityProviderName":{},"UseDefaults":{"type":"boolean"},"PrincipalTags":{"shape":"S1s"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"IdentityProviderName":{},"UseDefaults":{"type":"boolean"},"PrincipalTags":{"shape":"S1s"}}}},"TagResource":{"input":{"type":"structure","required":["ResourceArn","Tags"],"members":{"ResourceArn":{},"Tags":{"shape":"Sh"}}},"output":{"type":"structure","members":{}}},"UnlinkDeveloperIdentity":{"input":{"type":"structure","required":["IdentityId","IdentityPoolId","DeveloperProviderName","DeveloperUserIdentifier"],"members":{"IdentityId":{},"IdentityPoolId":{},"DeveloperProviderName":{},"DeveloperUserIdentifier":{}}}},"UnlinkIdentity":{"input":{"type":"structure","required":["IdentityId","Logins","LoginsToRemove"],"members":{"IdentityId":{},"Logins":{"shape":"S10"},"LoginsToRemove":{"shape":"Sw"}}},"authtype":"none"},"UntagResource":{"input":{"type":"structure","required":["ResourceArn","TagKeys"],"members":{"ResourceArn":{},"TagKeys":{"type":"list","member":{}}}},"output":{"type":"structure","members":{}}},"UpdateIdentityPool":{"input":{"shape":"Sk"},"output":{"shape":"Sk"}}},"shapes":{"S5":{"type":"map","key":{},"value":{}},"S9":{"type":"list","member":{}},"Sb":{"type":"list","member":{"type":"structure","members":{"ProviderName":{},"ClientId":{},"ServerSideTokenCheck":{"type":"boolean"}}}},"Sg":{"type":"list","member":{}},"Sh":{"type":"map","key":{},"value":{}},"Sk":{"type":"structure","required":["IdentityPoolId","IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolId":{},"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"AllowClassicFlow":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S5"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S9"},"CognitoIdentityProviders":{"shape":"Sb"},"SamlProviderARNs":{"shape":"Sg"},"IdentityPoolTags":{"shape":"Sh"}}},"Sv":{"type":"structure","members":{"IdentityId":{},"Logins":{"shape":"Sw"},"CreationDate":{"type":"timestamp"},"LastModifiedDate":{"type":"timestamp"}}},"Sw":{"type":"list","member":{}},"S10":{"type":"map","key":{},"value":{}},"S1c":{"type":"map","key":{},"value":{}},"S1e":{"type":"map","key":{},"value":{"type":"structure","required":["Type"],"members":{"Type":{},"AmbiguousRoleResolution":{},"RulesConfiguration":{"type":"structure","required":["Rules"],"members":{"Rules":{"type":"list","member":{"type":"structure","required":["Claim","MatchType","Value","RoleARN"],"members":{"Claim":{},"MatchType":{},"Value":{},"RoleARN":{}}}}}}}}},"S1s":{"type":"map","key":{},"value":{}}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json":
/*!*******************************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"pagination":{"ListIdentityPools":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken","result_key":"IdentityPools"}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/dynamodb-2011-12-05.min.json":
/*!****************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/dynamodb-2011-12-05.min.json ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2011-12-05","endpointPrefix":"dynamodb","jsonVersion":"1.0","protocol":"json","serviceAbbreviation":"DynamoDB","serviceFullName":"Amazon DynamoDB","serviceId":"DynamoDB","signatureVersion":"v4","targetPrefix":"DynamoDB_20111205","uid":"dynamodb-2011-12-05"},"operations":{"BatchGetItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S2"}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"type":"structure","members":{"Items":{"shape":"Sk"},"ConsumedCapacityUnits":{"type":"double"}}}},"UnprocessedKeys":{"shape":"S2"}}}},"BatchWriteItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"So"}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"type":"structure","members":{"ConsumedCapacityUnits":{"type":"double"}}}},"UnprocessedItems":{"shape":"So"}}}},"CreateTable":{"input":{"type":"structure","required":["TableName","KeySchema","ProvisionedThroughput"],"members":{"TableName":{},"KeySchema":{"shape":"Sy"},"ProvisionedThroughput":{"shape":"S12"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}},"DeleteItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"DeleteTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}},"DescribeTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"Table":{"shape":"S15"}}}},"GetItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributesToGet":{"shape":"Se"},"ConsistentRead":{"type":"boolean"}}},"output":{"type":"structure","members":{"Item":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"ListTables":{"input":{"type":"structure","members":{"ExclusiveStartTableName":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"TableNames":{"type":"list","member":{}},"LastEvaluatedTableName":{}}}},"PutItem":{"input":{"type":"structure","required":["TableName","Item"],"members":{"TableName":{},"Item":{"shape":"Ss"},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"Query":{"input":{"type":"structure","required":["TableName","HashKeyValue"],"members":{"TableName":{},"AttributesToGet":{"shape":"Se"},"Limit":{"type":"integer"},"ConsistentRead":{"type":"boolean"},"Count":{"type":"boolean"},"HashKeyValue":{"shape":"S7"},"RangeKeyCondition":{"shape":"S1u"},"ScanIndexForward":{"type":"boolean"},"ExclusiveStartKey":{"shape":"S6"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sk"},"Count":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacityUnits":{"type":"double"}}}},"Scan":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"AttributesToGet":{"shape":"Se"},"Limit":{"type":"integer"},"Count":{"type":"boolean"},"ScanFilter":{"type":"map","key":{},"value":{"shape":"S1u"}},"ExclusiveStartKey":{"shape":"S6"}}},"output":{"type":"structure","members":{"Items":{"shape":"Sk"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S6"},"ConsumedCapacityUnits":{"type":"double"}}}},"UpdateItem":{"input":{"type":"structure","required":["TableName","Key","AttributeUpdates"],"members":{"TableName":{},"Key":{"shape":"S6"},"AttributeUpdates":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S7"},"Action":{}}}},"Expected":{"shape":"S1b"},"ReturnValues":{}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sl"},"ConsumedCapacityUnits":{"type":"double"}}}},"UpdateTable":{"input":{"type":"structure","required":["TableName","ProvisionedThroughput"],"members":{"TableName":{},"ProvisionedThroughput":{"shape":"S12"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S15"}}}}},"shapes":{"S2":{"type":"map","key":{},"value":{"type":"structure","required":["Keys"],"members":{"Keys":{"type":"list","member":{"shape":"S6"}},"AttributesToGet":{"shape":"Se"},"ConsistentRead":{"type":"boolean"}}}},"S6":{"type":"structure","required":["HashKeyElement"],"members":{"HashKeyElement":{"shape":"S7"},"RangeKeyElement":{"shape":"S7"}}},"S7":{"type":"structure","members":{"S":{},"N":{},"B":{"type":"blob"},"SS":{"type":"list","member":{}},"NS":{"type":"list","member":{}},"BS":{"type":"list","member":{"type":"blob"}}}},"Se":{"type":"list","member":{}},"Sk":{"type":"list","member":{"shape":"Sl"}},"Sl":{"type":"map","key":{},"value":{"shape":"S7"}},"So":{"type":"map","key":{},"value":{"type":"list","member":{"type":"structure","members":{"PutRequest":{"type":"structure","required":["Item"],"members":{"Item":{"shape":"Ss"}}},"DeleteRequest":{"type":"structure","required":["Key"],"members":{"Key":{"shape":"S6"}}}}}}},"Ss":{"type":"map","key":{},"value":{"shape":"S7"}},"Sy":{"type":"structure","required":["HashKeyElement"],"members":{"HashKeyElement":{"shape":"Sz"},"RangeKeyElement":{"shape":"Sz"}}},"Sz":{"type":"structure","required":["AttributeName","AttributeType"],"members":{"AttributeName":{},"AttributeType":{}}},"S12":{"type":"structure","required":["ReadCapacityUnits","WriteCapacityUnits"],"members":{"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S15":{"type":"structure","members":{"TableName":{},"KeySchema":{"shape":"Sy"},"TableStatus":{},"CreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"type":"structure","members":{"LastIncreaseDateTime":{"type":"timestamp"},"LastDecreaseDateTime":{"type":"timestamp"},"NumberOfDecreasesToday":{"type":"long"},"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"TableSizeBytes":{"type":"long"},"ItemCount":{"type":"long"}}},"S1b":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S7"},"Exists":{"type":"boolean"}}}},"S1u":{"type":"structure","required":["ComparisonOperator"],"members":{"AttributeValueList":{"type":"list","member":{"shape":"S7"}},"ComparisonOperator":{}}}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/dynamodb-2011-12-05.paginators.json":
/*!***********************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/dynamodb-2011-12-05.paginators.json ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"pagination":{"BatchGetItem":{"input_token":"RequestItems","output_token":"UnprocessedKeys"},"ListTables":{"input_token":"ExclusiveStartTableName","limit_key":"Limit","output_token":"LastEvaluatedTableName","result_key":"TableNames"},"Query":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"},"Scan":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/dynamodb-2011-12-05.waiters2.json":
/*!*********************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/dynamodb-2011-12-05.waiters2.json ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":2,"waiters":{"TableExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ACTIVE","matcher":"path","state":"success","argument":"Table.TableStatus"},{"expected":"ResourceNotFoundException","matcher":"error","state":"retry"}]},"TableNotExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ResourceNotFoundException","matcher":"error","state":"success"}]}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/dynamodb-2012-08-10.min.json":
/*!****************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/dynamodb-2012-08-10.min.json ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2012-08-10","endpointPrefix":"dynamodb","jsonVersion":"1.0","protocol":"json","serviceAbbreviation":"DynamoDB","serviceFullName":"Amazon DynamoDB","serviceId":"DynamoDB","signatureVersion":"v4","targetPrefix":"DynamoDB_20120810","uid":"dynamodb-2012-08-10"},"operations":{"BatchExecuteStatement":{"input":{"type":"structure","required":["Statements"],"members":{"Statements":{"type":"list","member":{"type":"structure","required":["Statement"],"members":{"Statement":{},"Parameters":{"shape":"S5"},"ConsistentRead":{"type":"boolean"}}}},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"type":"list","member":{"type":"structure","members":{"Error":{"type":"structure","members":{"Code":{},"Message":{}}},"TableName":{},"Item":{"shape":"Sr"}}}},"ConsumedCapacity":{"shape":"Ss"}}}},"BatchGetItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"Sz"},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"type":"map","key":{},"value":{"shape":"S19"}},"UnprocessedKeys":{"shape":"Sz"},"ConsumedCapacity":{"shape":"Ss"}}},"endpointdiscovery":{}},"BatchWriteItem":{"input":{"type":"structure","required":["RequestItems"],"members":{"RequestItems":{"shape":"S1b"},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{}}},"output":{"type":"structure","members":{"UnprocessedItems":{"shape":"S1b"},"ItemCollectionMetrics":{"shape":"S1j"},"ConsumedCapacity":{"shape":"Ss"}}},"endpointdiscovery":{}},"CreateBackup":{"input":{"type":"structure","required":["TableName","BackupName"],"members":{"TableName":{},"BackupName":{}}},"output":{"type":"structure","members":{"BackupDetails":{"shape":"S1s"}}},"endpointdiscovery":{}},"CreateGlobalTable":{"input":{"type":"structure","required":["GlobalTableName","ReplicationGroup"],"members":{"GlobalTableName":{},"ReplicationGroup":{"shape":"S20"}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S24"}}},"endpointdiscovery":{}},"CreateTable":{"input":{"type":"structure","required":["AttributeDefinitions","TableName","KeySchema"],"members":{"AttributeDefinitions":{"shape":"S2k"},"TableName":{},"KeySchema":{"shape":"S2o"},"LocalSecondaryIndexes":{"shape":"S2r"},"GlobalSecondaryIndexes":{"shape":"S2x"},"BillingMode":{},"ProvisionedThroughput":{"shape":"S2z"},"StreamSpecification":{"shape":"S31"},"SSESpecification":{"shape":"S34"},"Tags":{"shape":"S37"},"TableClass":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"DeleteBackup":{"input":{"type":"structure","required":["BackupArn"],"members":{"BackupArn":{}}},"output":{"type":"structure","members":{"BackupDescription":{"shape":"S40"}}},"endpointdiscovery":{}},"DeleteItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S12"},"Expected":{"shape":"S4d"},"ConditionalOperator":{},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"},"ItemCollectionMetrics":{"shape":"S1l"}}},"endpointdiscovery":{}},"DeleteTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"DescribeBackup":{"input":{"type":"structure","required":["BackupArn"],"members":{"BackupArn":{}}},"output":{"type":"structure","members":{"BackupDescription":{"shape":"S40"}}},"endpointdiscovery":{}},"DescribeContinuousBackups":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"ContinuousBackupsDescription":{"shape":"S4u"}}},"endpointdiscovery":{}},"DescribeContributorInsights":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{}}},"output":{"type":"structure","members":{"TableName":{},"IndexName":{},"ContributorInsightsRuleList":{"type":"list","member":{}},"ContributorInsightsStatus":{},"LastUpdateDateTime":{"type":"timestamp"},"FailureException":{"type":"structure","members":{"ExceptionName":{},"ExceptionDescription":{}}}}}},"DescribeEndpoints":{"input":{"type":"structure","members":{}},"output":{"type":"structure","required":["Endpoints"],"members":{"Endpoints":{"type":"list","member":{"type":"structure","required":["Address","CachePeriodInMinutes"],"members":{"Address":{},"CachePeriodInMinutes":{"type":"long"}}}}}},"endpointoperation":true},"DescribeExport":{"input":{"type":"structure","required":["ExportArn"],"members":{"ExportArn":{}}},"output":{"type":"structure","members":{"ExportDescription":{"shape":"S5e"}}}},"DescribeGlobalTable":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S24"}}},"endpointdiscovery":{}},"DescribeGlobalTableSettings":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{}}},"output":{"type":"structure","members":{"GlobalTableName":{},"ReplicaSettings":{"shape":"S5y"}}},"endpointdiscovery":{}},"DescribeKinesisStreamingDestination":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableName":{},"KinesisDataStreamDestinations":{"type":"list","member":{"type":"structure","members":{"StreamArn":{},"DestinationStatus":{},"DestinationStatusDescription":{}}}}}},"endpointdiscovery":{}},"DescribeLimits":{"input":{"type":"structure","members":{}},"output":{"type":"structure","members":{"AccountMaxReadCapacityUnits":{"type":"long"},"AccountMaxWriteCapacityUnits":{"type":"long"},"TableMaxReadCapacityUnits":{"type":"long"},"TableMaxWriteCapacityUnits":{"type":"long"}}},"endpointdiscovery":{}},"DescribeTable":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"Table":{"shape":"S3c"}}},"endpointdiscovery":{}},"DescribeTableReplicaAutoScaling":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TableAutoScalingDescription":{"shape":"S6k"}}}},"DescribeTimeToLive":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{}}},"output":{"type":"structure","members":{"TimeToLiveDescription":{"shape":"S49"}}},"endpointdiscovery":{}},"DisableKinesisStreamingDestination":{"input":{"shape":"S6r"},"output":{"shape":"S6s"},"endpointdiscovery":{}},"EnableKinesisStreamingDestination":{"input":{"shape":"S6r"},"output":{"shape":"S6s"},"endpointdiscovery":{}},"ExecuteStatement":{"input":{"type":"structure","required":["Statement"],"members":{"Statement":{},"Parameters":{"shape":"S5"},"ConsistentRead":{"type":"boolean"},"NextToken":{},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Items":{"shape":"S19"},"NextToken":{},"ConsumedCapacity":{"shape":"St"}}}},"ExecuteTransaction":{"input":{"type":"structure","required":["TransactStatements"],"members":{"TransactStatements":{"type":"list","member":{"type":"structure","required":["Statement"],"members":{"Statement":{},"Parameters":{"shape":"S5"}}}},"ClientRequestToken":{"idempotencyToken":true},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"Responses":{"shape":"S71"},"ConsumedCapacity":{"shape":"Ss"}}}},"ExportTableToPointInTime":{"input":{"type":"structure","required":["TableArn","S3Bucket"],"members":{"TableArn":{},"ExportTime":{"type":"timestamp"},"ClientToken":{"idempotencyToken":true},"S3Bucket":{},"S3BucketOwner":{},"S3Prefix":{},"S3SseAlgorithm":{},"S3SseKmsKeyId":{},"ExportFormat":{}}},"output":{"type":"structure","members":{"ExportDescription":{"shape":"S5e"}}}},"GetItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S12"},"AttributesToGet":{"shape":"S13"},"ConsistentRead":{"type":"boolean"},"ReturnConsumedCapacity":{},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"S15"}}},"output":{"type":"structure","members":{"Item":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"ListBackups":{"input":{"type":"structure","members":{"TableName":{},"Limit":{"type":"integer"},"TimeRangeLowerBound":{"type":"timestamp"},"TimeRangeUpperBound":{"type":"timestamp"},"ExclusiveStartBackupArn":{},"BackupType":{}}},"output":{"type":"structure","members":{"BackupSummaries":{"type":"list","member":{"type":"structure","members":{"TableName":{},"TableId":{},"TableArn":{},"BackupArn":{},"BackupName":{},"BackupCreationDateTime":{"type":"timestamp"},"BackupExpiryDateTime":{"type":"timestamp"},"BackupStatus":{},"BackupType":{},"BackupSizeBytes":{"type":"long"}}}},"LastEvaluatedBackupArn":{}}},"endpointdiscovery":{}},"ListContributorInsights":{"input":{"type":"structure","members":{"TableName":{},"NextToken":{},"MaxResults":{"type":"integer"}}},"output":{"type":"structure","members":{"ContributorInsightsSummaries":{"type":"list","member":{"type":"structure","members":{"TableName":{},"IndexName":{},"ContributorInsightsStatus":{}}}},"NextToken":{}}}},"ListExports":{"input":{"type":"structure","members":{"TableArn":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"ExportSummaries":{"type":"list","member":{"type":"structure","members":{"ExportArn":{},"ExportStatus":{}}}},"NextToken":{}}}},"ListGlobalTables":{"input":{"type":"structure","members":{"ExclusiveStartGlobalTableName":{},"Limit":{"type":"integer"},"RegionName":{}}},"output":{"type":"structure","members":{"GlobalTables":{"type":"list","member":{"type":"structure","members":{"GlobalTableName":{},"ReplicationGroup":{"shape":"S20"}}}},"LastEvaluatedGlobalTableName":{}}},"endpointdiscovery":{}},"ListTables":{"input":{"type":"structure","members":{"ExclusiveStartTableName":{},"Limit":{"type":"integer"}}},"output":{"type":"structure","members":{"TableNames":{"type":"list","member":{}},"LastEvaluatedTableName":{}}},"endpointdiscovery":{}},"ListTagsOfResource":{"input":{"type":"structure","required":["ResourceArn"],"members":{"ResourceArn":{},"NextToken":{}}},"output":{"type":"structure","members":{"Tags":{"shape":"S37"},"NextToken":{}}},"endpointdiscovery":{}},"PutItem":{"input":{"type":"structure","required":["TableName","Item"],"members":{"TableName":{},"Item":{"shape":"S1f"},"Expected":{"shape":"S4d"},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ConditionalOperator":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"},"ItemCollectionMetrics":{"shape":"S1l"}}},"endpointdiscovery":{}},"Query":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{},"Select":{},"AttributesToGet":{"shape":"S13"},"Limit":{"type":"integer"},"ConsistentRead":{"type":"boolean"},"KeyConditions":{"type":"map","key":{},"value":{"shape":"S88"}},"QueryFilter":{"shape":"S89"},"ConditionalOperator":{},"ScanIndexForward":{"type":"boolean"},"ExclusiveStartKey":{"shape":"S12"},"ReturnConsumedCapacity":{},"ProjectionExpression":{},"FilterExpression":{},"KeyConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Items":{"shape":"S19"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S12"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"RestoreTableFromBackup":{"input":{"type":"structure","required":["TargetTableName","BackupArn"],"members":{"TargetTableName":{},"BackupArn":{},"BillingModeOverride":{},"GlobalSecondaryIndexOverride":{"shape":"S2x"},"LocalSecondaryIndexOverride":{"shape":"S2r"},"ProvisionedThroughputOverride":{"shape":"S2z"},"SSESpecificationOverride":{"shape":"S34"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"RestoreTableToPointInTime":{"input":{"type":"structure","required":["TargetTableName"],"members":{"SourceTableArn":{},"SourceTableName":{},"TargetTableName":{},"UseLatestRestorableTime":{"type":"boolean"},"RestoreDateTime":{"type":"timestamp"},"BillingModeOverride":{},"GlobalSecondaryIndexOverride":{"shape":"S2x"},"LocalSecondaryIndexOverride":{"shape":"S2r"},"ProvisionedThroughputOverride":{"shape":"S2z"},"SSESpecificationOverride":{"shape":"S34"}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"Scan":{"input":{"type":"structure","required":["TableName"],"members":{"TableName":{},"IndexName":{},"AttributesToGet":{"shape":"S13"},"Limit":{"type":"integer"},"Select":{},"ScanFilter":{"shape":"S89"},"ConditionalOperator":{},"ExclusiveStartKey":{"shape":"S12"},"ReturnConsumedCapacity":{},"TotalSegments":{"type":"integer"},"Segment":{"type":"integer"},"ProjectionExpression":{},"FilterExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ConsistentRead":{"type":"boolean"}}},"output":{"type":"structure","members":{"Items":{"shape":"S19"},"Count":{"type":"integer"},"ScannedCount":{"type":"integer"},"LastEvaluatedKey":{"shape":"S12"},"ConsumedCapacity":{"shape":"St"}}},"endpointdiscovery":{}},"TagResource":{"input":{"type":"structure","required":["ResourceArn","Tags"],"members":{"ResourceArn":{},"Tags":{"shape":"S37"}}},"endpointdiscovery":{}},"TransactGetItems":{"input":{"type":"structure","required":["TransactItems"],"members":{"TransactItems":{"type":"list","member":{"type":"structure","required":["Get"],"members":{"Get":{"type":"structure","required":["Key","TableName"],"members":{"Key":{"shape":"S12"},"TableName":{},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"S15"}}}}}},"ReturnConsumedCapacity":{}}},"output":{"type":"structure","members":{"ConsumedCapacity":{"shape":"Ss"},"Responses":{"shape":"S71"}}},"endpointdiscovery":{}},"TransactWriteItems":{"input":{"type":"structure","required":["TransactItems"],"members":{"TransactItems":{"type":"list","member":{"type":"structure","members":{"ConditionCheck":{"type":"structure","required":["Key","TableName","ConditionExpression"],"members":{"Key":{"shape":"S12"},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}},"Put":{"type":"structure","required":["Item","TableName"],"members":{"Item":{"shape":"S1f"},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}},"Delete":{"type":"structure","required":["Key","TableName"],"members":{"Key":{"shape":"S12"},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}},"Update":{"type":"structure","required":["Key","UpdateExpression","TableName"],"members":{"Key":{"shape":"S12"},"UpdateExpression":{},"TableName":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"},"ReturnValuesOnConditionCheckFailure":{}}}}}},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"ClientRequestToken":{"idempotencyToken":true}}},"output":{"type":"structure","members":{"ConsumedCapacity":{"shape":"Ss"},"ItemCollectionMetrics":{"shape":"S1j"}}},"endpointdiscovery":{}},"UntagResource":{"input":{"type":"structure","required":["ResourceArn","TagKeys"],"members":{"ResourceArn":{},"TagKeys":{"type":"list","member":{}}}},"endpointdiscovery":{}},"UpdateContinuousBackups":{"input":{"type":"structure","required":["TableName","PointInTimeRecoverySpecification"],"members":{"TableName":{},"PointInTimeRecoverySpecification":{"type":"structure","required":["PointInTimeRecoveryEnabled"],"members":{"PointInTimeRecoveryEnabled":{"type":"boolean"}}}}},"output":{"type":"structure","members":{"ContinuousBackupsDescription":{"shape":"S4u"}}},"endpointdiscovery":{}},"UpdateContributorInsights":{"input":{"type":"structure","required":["TableName","ContributorInsightsAction"],"members":{"TableName":{},"IndexName":{},"ContributorInsightsAction":{}}},"output":{"type":"structure","members":{"TableName":{},"IndexName":{},"ContributorInsightsStatus":{}}}},"UpdateGlobalTable":{"input":{"type":"structure","required":["GlobalTableName","ReplicaUpdates"],"members":{"GlobalTableName":{},"ReplicaUpdates":{"type":"list","member":{"type":"structure","members":{"Create":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}},"Delete":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}}}}}}},"output":{"type":"structure","members":{"GlobalTableDescription":{"shape":"S24"}}},"endpointdiscovery":{}},"UpdateGlobalTableSettings":{"input":{"type":"structure","required":["GlobalTableName"],"members":{"GlobalTableName":{},"GlobalTableBillingMode":{},"GlobalTableProvisionedWriteCapacityUnits":{"type":"long"},"GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate":{"shape":"S9g"},"GlobalTableGlobalSecondaryIndexSettingsUpdate":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedWriteCapacityUnits":{"type":"long"},"ProvisionedWriteCapacityAutoScalingSettingsUpdate":{"shape":"S9g"}}}},"ReplicaSettingsUpdate":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaProvisionedReadCapacityUnits":{"type":"long"},"ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate":{"shape":"S9g"},"ReplicaGlobalSecondaryIndexSettingsUpdate":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedReadCapacityUnits":{"type":"long"},"ProvisionedReadCapacityAutoScalingSettingsUpdate":{"shape":"S9g"}}}},"ReplicaTableClass":{}}}}}},"output":{"type":"structure","members":{"GlobalTableName":{},"ReplicaSettings":{"shape":"S5y"}}},"endpointdiscovery":{}},"UpdateItem":{"input":{"type":"structure","required":["TableName","Key"],"members":{"TableName":{},"Key":{"shape":"S12"},"AttributeUpdates":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S6"},"Action":{}}}},"Expected":{"shape":"S4d"},"ConditionalOperator":{},"ReturnValues":{},"ReturnConsumedCapacity":{},"ReturnItemCollectionMetrics":{},"UpdateExpression":{},"ConditionExpression":{},"ExpressionAttributeNames":{"shape":"S15"},"ExpressionAttributeValues":{"shape":"S4l"}}},"output":{"type":"structure","members":{"Attributes":{"shape":"Sr"},"ConsumedCapacity":{"shape":"St"},"ItemCollectionMetrics":{"shape":"S1l"}}},"endpointdiscovery":{}},"UpdateTable":{"input":{"type":"structure","required":["TableName"],"members":{"AttributeDefinitions":{"shape":"S2k"},"TableName":{},"BillingMode":{},"ProvisionedThroughput":{"shape":"S2z"},"GlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"Update":{"type":"structure","required":["IndexName","ProvisionedThroughput"],"members":{"IndexName":{},"ProvisionedThroughput":{"shape":"S2z"}}},"Create":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"ProvisionedThroughput":{"shape":"S2z"}}},"Delete":{"type":"structure","required":["IndexName"],"members":{"IndexName":{}}}}}},"StreamSpecification":{"shape":"S31"},"SSESpecification":{"shape":"S34"},"ReplicaUpdates":{"type":"list","member":{"type":"structure","members":{"Create":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"KMSMasterKeyId":{},"ProvisionedThroughputOverride":{"shape":"S2b"},"GlobalSecondaryIndexes":{"shape":"Sa5"},"TableClassOverride":{}}},"Update":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"KMSMasterKeyId":{},"ProvisionedThroughputOverride":{"shape":"S2b"},"GlobalSecondaryIndexes":{"shape":"Sa5"},"TableClassOverride":{}}},"Delete":{"type":"structure","required":["RegionName"],"members":{"RegionName":{}}}}}},"TableClass":{}}},"output":{"type":"structure","members":{"TableDescription":{"shape":"S3c"}}},"endpointdiscovery":{}},"UpdateTableReplicaAutoScaling":{"input":{"type":"structure","required":["TableName"],"members":{"GlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"ProvisionedWriteCapacityAutoScalingUpdate":{"shape":"S9g"}}}},"TableName":{},"ProvisionedWriteCapacityAutoScalingUpdate":{"shape":"S9g"},"ReplicaUpdates":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaGlobalSecondaryIndexUpdates":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"ProvisionedReadCapacityAutoScalingUpdate":{"shape":"S9g"}}}},"ReplicaProvisionedReadCapacityAutoScalingUpdate":{"shape":"S9g"}}}}}},"output":{"type":"structure","members":{"TableAutoScalingDescription":{"shape":"S6k"}}}},"UpdateTimeToLive":{"input":{"type":"structure","required":["TableName","TimeToLiveSpecification"],"members":{"TableName":{},"TimeToLiveSpecification":{"shape":"Saj"}}},"output":{"type":"structure","members":{"TimeToLiveSpecification":{"shape":"Saj"}}},"endpointdiscovery":{}}},"shapes":{"S5":{"type":"list","member":{"shape":"S6"}},"S6":{"type":"structure","members":{"S":{},"N":{},"B":{"type":"blob"},"SS":{"type":"list","member":{}},"NS":{"type":"list","member":{}},"BS":{"type":"list","member":{"type":"blob"}},"M":{"type":"map","key":{},"value":{"shape":"S6"}},"L":{"type":"list","member":{"shape":"S6"}},"NULL":{"type":"boolean"},"BOOL":{"type":"boolean"}}},"Sr":{"type":"map","key":{},"value":{"shape":"S6"}},"Ss":{"type":"list","member":{"shape":"St"}},"St":{"type":"structure","members":{"TableName":{},"CapacityUnits":{"type":"double"},"ReadCapacityUnits":{"type":"double"},"WriteCapacityUnits":{"type":"double"},"Table":{"shape":"Sv"},"LocalSecondaryIndexes":{"shape":"Sw"},"GlobalSecondaryIndexes":{"shape":"Sw"}}},"Sv":{"type":"structure","members":{"ReadCapacityUnits":{"type":"double"},"WriteCapacityUnits":{"type":"double"},"CapacityUnits":{"type":"double"}}},"Sw":{"type":"map","key":{},"value":{"shape":"Sv"}},"Sz":{"type":"map","key":{},"value":{"type":"structure","required":["Keys"],"members":{"Keys":{"type":"list","member":{"shape":"S12"}},"AttributesToGet":{"shape":"S13"},"ConsistentRead":{"type":"boolean"},"ProjectionExpression":{},"ExpressionAttributeNames":{"shape":"S15"}}}},"S12":{"type":"map","key":{},"value":{"shape":"S6"}},"S13":{"type":"list","member":{}},"S15":{"type":"map","key":{},"value":{}},"S19":{"type":"list","member":{"shape":"Sr"}},"S1b":{"type":"map","key":{},"value":{"type":"list","member":{"type":"structure","members":{"PutRequest":{"type":"structure","required":["Item"],"members":{"Item":{"shape":"S1f"}}},"DeleteRequest":{"type":"structure","required":["Key"],"members":{"Key":{"shape":"S12"}}}}}}},"S1f":{"type":"map","key":{},"value":{"shape":"S6"}},"S1j":{"type":"map","key":{},"value":{"type":"list","member":{"shape":"S1l"}}},"S1l":{"type":"structure","members":{"ItemCollectionKey":{"type":"map","key":{},"value":{"shape":"S6"}},"SizeEstimateRangeGB":{"type":"list","member":{"type":"double"}}}},"S1s":{"type":"structure","required":["BackupArn","BackupName","BackupStatus","BackupType","BackupCreationDateTime"],"members":{"BackupArn":{},"BackupName":{},"BackupSizeBytes":{"type":"long"},"BackupStatus":{},"BackupType":{},"BackupCreationDateTime":{"type":"timestamp"},"BackupExpiryDateTime":{"type":"timestamp"}}},"S20":{"type":"list","member":{"type":"structure","members":{"RegionName":{}}}},"S24":{"type":"structure","members":{"ReplicationGroup":{"shape":"S25"},"GlobalTableArn":{},"CreationDateTime":{"type":"timestamp"},"GlobalTableStatus":{},"GlobalTableName":{}}},"S25":{"type":"list","member":{"type":"structure","members":{"RegionName":{},"ReplicaStatus":{},"ReplicaStatusDescription":{},"ReplicaStatusPercentProgress":{},"KMSMasterKeyId":{},"ProvisionedThroughputOverride":{"shape":"S2b"},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"ProvisionedThroughputOverride":{"shape":"S2b"}}}},"ReplicaInaccessibleDateTime":{"type":"timestamp"},"ReplicaTableClassSummary":{"shape":"S2f"}}}},"S2b":{"type":"structure","members":{"ReadCapacityUnits":{"type":"long"}}},"S2f":{"type":"structure","members":{"TableClass":{},"LastUpdateDateTime":{"type":"timestamp"}}},"S2k":{"type":"list","member":{"type":"structure","required":["AttributeName","AttributeType"],"members":{"AttributeName":{},"AttributeType":{}}}},"S2o":{"type":"list","member":{"type":"structure","required":["AttributeName","KeyType"],"members":{"AttributeName":{},"KeyType":{}}}},"S2r":{"type":"list","member":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"}}}},"S2t":{"type":"structure","members":{"ProjectionType":{},"NonKeyAttributes":{"type":"list","member":{}}}},"S2x":{"type":"list","member":{"type":"structure","required":["IndexName","KeySchema","Projection"],"members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"ProvisionedThroughput":{"shape":"S2z"}}}},"S2z":{"type":"structure","required":["ReadCapacityUnits","WriteCapacityUnits"],"members":{"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S31":{"type":"structure","required":["StreamEnabled"],"members":{"StreamEnabled":{"type":"boolean"},"StreamViewType":{}}},"S34":{"type":"structure","members":{"Enabled":{"type":"boolean"},"SSEType":{},"KMSMasterKeyId":{}}},"S37":{"type":"list","member":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}}},"S3c":{"type":"structure","members":{"AttributeDefinitions":{"shape":"S2k"},"TableName":{},"KeySchema":{"shape":"S2o"},"TableStatus":{},"CreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"shape":"S3e"},"TableSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"TableArn":{},"TableId":{},"BillingModeSummary":{"shape":"S3i"},"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"IndexSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"IndexArn":{}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"IndexStatus":{},"Backfilling":{"type":"boolean"},"ProvisionedThroughput":{"shape":"S3e"},"IndexSizeBytes":{"type":"long"},"ItemCount":{"type":"long"},"IndexArn":{}}}},"StreamSpecification":{"shape":"S31"},"LatestStreamLabel":{},"LatestStreamArn":{},"GlobalTableVersion":{},"Replicas":{"shape":"S25"},"RestoreSummary":{"type":"structure","required":["RestoreDateTime","RestoreInProgress"],"members":{"SourceBackupArn":{},"SourceTableArn":{},"RestoreDateTime":{"type":"timestamp"},"RestoreInProgress":{"type":"boolean"}}},"SSEDescription":{"shape":"S3t"},"ArchivalSummary":{"type":"structure","members":{"ArchivalDateTime":{"type":"timestamp"},"ArchivalReason":{},"ArchivalBackupArn":{}}},"TableClassSummary":{"shape":"S2f"}}},"S3e":{"type":"structure","members":{"LastIncreaseDateTime":{"type":"timestamp"},"LastDecreaseDateTime":{"type":"timestamp"},"NumberOfDecreasesToday":{"type":"long"},"ReadCapacityUnits":{"type":"long"},"WriteCapacityUnits":{"type":"long"}}},"S3i":{"type":"structure","members":{"BillingMode":{},"LastUpdateToPayPerRequestDateTime":{"type":"timestamp"}}},"S3t":{"type":"structure","members":{"Status":{},"SSEType":{},"KMSMasterKeyArn":{},"InaccessibleEncryptionDateTime":{"type":"timestamp"}}},"S40":{"type":"structure","members":{"BackupDetails":{"shape":"S1s"},"SourceTableDetails":{"type":"structure","required":["TableName","TableId","KeySchema","TableCreationDateTime","ProvisionedThroughput"],"members":{"TableName":{},"TableId":{},"TableArn":{},"TableSizeBytes":{"type":"long"},"KeySchema":{"shape":"S2o"},"TableCreationDateTime":{"type":"timestamp"},"ProvisionedThroughput":{"shape":"S2z"},"ItemCount":{"type":"long"},"BillingMode":{}}},"SourceTableFeatureDetails":{"type":"structure","members":{"LocalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"}}}},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"KeySchema":{"shape":"S2o"},"Projection":{"shape":"S2t"},"ProvisionedThroughput":{"shape":"S2z"}}}},"StreamDescription":{"shape":"S31"},"TimeToLiveDescription":{"shape":"S49"},"SSEDescription":{"shape":"S3t"}}}}},"S49":{"type":"structure","members":{"TimeToLiveStatus":{},"AttributeName":{}}},"S4d":{"type":"map","key":{},"value":{"type":"structure","members":{"Value":{"shape":"S6"},"Exists":{"type":"boolean"},"ComparisonOperator":{},"AttributeValueList":{"shape":"S4h"}}}},"S4h":{"type":"list","member":{"shape":"S6"}},"S4l":{"type":"map","key":{},"value":{"shape":"S6"}},"S4u":{"type":"structure","required":["ContinuousBackupsStatus"],"members":{"ContinuousBackupsStatus":{},"PointInTimeRecoveryDescription":{"type":"structure","members":{"PointInTimeRecoveryStatus":{},"EarliestRestorableDateTime":{"type":"timestamp"},"LatestRestorableDateTime":{"type":"timestamp"}}}}},"S5e":{"type":"structure","members":{"ExportArn":{},"ExportStatus":{},"StartTime":{"type":"timestamp"},"EndTime":{"type":"timestamp"},"ExportManifest":{},"TableArn":{},"TableId":{},"ExportTime":{"type":"timestamp"},"ClientToken":{},"S3Bucket":{},"S3BucketOwner":{},"S3Prefix":{},"S3SseAlgorithm":{},"S3SseKmsKeyId":{},"FailureCode":{},"FailureMessage":{},"ExportFormat":{},"BilledSizeBytes":{"type":"long"},"ItemCount":{"type":"long"}}},"S5y":{"type":"list","member":{"type":"structure","required":["RegionName"],"members":{"RegionName":{},"ReplicaStatus":{},"ReplicaBillingModeSummary":{"shape":"S3i"},"ReplicaProvisionedReadCapacityUnits":{"type":"long"},"ReplicaProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaProvisionedWriteCapacityUnits":{"type":"long"},"ReplicaProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaGlobalSecondaryIndexSettings":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"IndexStatus":{},"ProvisionedReadCapacityUnits":{"type":"long"},"ProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ProvisionedWriteCapacityUnits":{"type":"long"},"ProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"}}}},"ReplicaTableClassSummary":{"shape":"S2f"}}}},"S60":{"type":"structure","members":{"MinimumUnits":{"type":"long"},"MaximumUnits":{"type":"long"},"AutoScalingDisabled":{"type":"boolean"},"AutoScalingRoleArn":{},"ScalingPolicies":{"type":"list","member":{"type":"structure","members":{"PolicyName":{},"TargetTrackingScalingPolicyConfiguration":{"type":"structure","required":["TargetValue"],"members":{"DisableScaleIn":{"type":"boolean"},"ScaleInCooldown":{"type":"integer"},"ScaleOutCooldown":{"type":"integer"},"TargetValue":{"type":"double"}}}}}}}},"S6k":{"type":"structure","members":{"TableName":{},"TableStatus":{},"Replicas":{"type":"list","member":{"type":"structure","members":{"RegionName":{},"GlobalSecondaryIndexes":{"type":"list","member":{"type":"structure","members":{"IndexName":{},"IndexStatus":{},"ProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"}}}},"ReplicaProvisionedReadCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaProvisionedWriteCapacityAutoScalingSettings":{"shape":"S60"},"ReplicaStatus":{}}}}}},"S6r":{"type":"structure","required":["TableName","StreamArn"],"members":{"TableName":{},"StreamArn":{}}},"S6s":{"type":"structure","members":{"TableName":{},"StreamArn":{},"DestinationStatus":{}}},"S71":{"type":"list","member":{"type":"structure","members":{"Item":{"shape":"Sr"}}}},"S88":{"type":"structure","required":["ComparisonOperator"],"members":{"AttributeValueList":{"shape":"S4h"},"ComparisonOperator":{}}},"S89":{"type":"map","key":{},"value":{"shape":"S88"}},"S9g":{"type":"structure","members":{"MinimumUnits":{"type":"long"},"MaximumUnits":{"type":"long"},"AutoScalingDisabled":{"type":"boolean"},"AutoScalingRoleArn":{},"ScalingPolicyUpdate":{"type":"structure","required":["TargetTrackingScalingPolicyConfiguration"],"members":{"PolicyName":{},"TargetTrackingScalingPolicyConfiguration":{"type":"structure","required":["TargetValue"],"members":{"DisableScaleIn":{"type":"boolean"},"ScaleInCooldown":{"type":"integer"},"ScaleOutCooldown":{"type":"integer"},"TargetValue":{"type":"double"}}}}}}},"Sa5":{"type":"list","member":{"type":"structure","required":["IndexName"],"members":{"IndexName":{},"ProvisionedThroughputOverride":{"shape":"S2b"}}}},"Saj":{"type":"structure","required":["Enabled","AttributeName"],"members":{"Enabled":{"type":"boolean"},"AttributeName":{}}}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/dynamodb-2012-08-10.paginators.json":
/*!***********************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/dynamodb-2012-08-10.paginators.json ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"pagination":{"BatchGetItem":{"input_token":"RequestItems","output_token":"UnprocessedKeys"},"ListContributorInsights":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken"},"ListExports":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken"},"ListTables":{"input_token":"ExclusiveStartTableName","limit_key":"Limit","output_token":"LastEvaluatedTableName","result_key":"TableNames"},"Query":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"},"Scan":{"input_token":"ExclusiveStartKey","limit_key":"Limit","output_token":"LastEvaluatedKey","result_key":"Items"}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/dynamodb-2012-08-10.waiters2.json":
/*!*********************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/dynamodb-2012-08-10.waiters2.json ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":2,"waiters":{"TableExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ACTIVE","matcher":"path","state":"success","argument":"Table.TableStatus"},{"expected":"ResourceNotFoundException","matcher":"error","state":"retry"}]},"TableNotExists":{"delay":20,"operation":"DescribeTable","maxAttempts":25,"acceptors":[{"expected":"ResourceNotFoundException","matcher":"error","state":"success"}]}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/metadata.json":
/*!*************************************************!*\
  !*** ./node_modules/aws-sdk/apis/metadata.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"acm":{"name":"ACM","cors":true},"apigateway":{"name":"APIGateway","cors":true},"applicationautoscaling":{"prefix":"application-autoscaling","name":"ApplicationAutoScaling","cors":true},"appstream":{"name":"AppStream"},"autoscaling":{"name":"AutoScaling","cors":true},"batch":{"name":"Batch"},"budgets":{"name":"Budgets"},"clouddirectory":{"name":"CloudDirectory","versions":["2016-05-10*"]},"cloudformation":{"name":"CloudFormation","cors":true},"cloudfront":{"name":"CloudFront","versions":["2013-05-12*","2013-11-11*","2014-05-31*","2014-10-21*","2014-11-06*","2015-04-17*","2015-07-27*","2015-09-17*","2016-01-13*","2016-01-28*","2016-08-01*","2016-08-20*","2016-09-07*","2016-09-29*","2016-11-25*","2017-03-25*","2017-10-30*","2018-06-18*","2018-11-05*","2019-03-26*"],"cors":true},"cloudhsm":{"name":"CloudHSM","cors":true},"cloudsearch":{"name":"CloudSearch"},"cloudsearchdomain":{"name":"CloudSearchDomain"},"cloudtrail":{"name":"CloudTrail","cors":true},"cloudwatch":{"prefix":"monitoring","name":"CloudWatch","cors":true},"cloudwatchevents":{"prefix":"events","name":"CloudWatchEvents","versions":["2014-02-03*"],"cors":true},"cloudwatchlogs":{"prefix":"logs","name":"CloudWatchLogs","cors":true},"codebuild":{"name":"CodeBuild","cors":true},"codecommit":{"name":"CodeCommit","cors":true},"codedeploy":{"name":"CodeDeploy","cors":true},"codepipeline":{"name":"CodePipeline","cors":true},"cognitoidentity":{"prefix":"cognito-identity","name":"CognitoIdentity","cors":true},"cognitoidentityserviceprovider":{"prefix":"cognito-idp","name":"CognitoIdentityServiceProvider","cors":true},"cognitosync":{"prefix":"cognito-sync","name":"CognitoSync","cors":true},"configservice":{"prefix":"config","name":"ConfigService","cors":true},"cur":{"name":"CUR","cors":true},"datapipeline":{"name":"DataPipeline"},"devicefarm":{"name":"DeviceFarm","cors":true},"directconnect":{"name":"DirectConnect","cors":true},"directoryservice":{"prefix":"ds","name":"DirectoryService"},"discovery":{"name":"Discovery"},"dms":{"name":"DMS"},"dynamodb":{"name":"DynamoDB","cors":true},"dynamodbstreams":{"prefix":"streams.dynamodb","name":"DynamoDBStreams","cors":true},"ec2":{"name":"EC2","versions":["2013-06-15*","2013-10-15*","2014-02-01*","2014-05-01*","2014-06-15*","2014-09-01*","2014-10-01*","2015-03-01*","2015-04-15*","2015-10-01*","2016-04-01*","2016-09-15*"],"cors":true},"ecr":{"name":"ECR","cors":true},"ecs":{"name":"ECS","cors":true},"efs":{"prefix":"elasticfilesystem","name":"EFS","cors":true},"elasticache":{"name":"ElastiCache","versions":["2012-11-15*","2014-03-24*","2014-07-15*","2014-09-30*"],"cors":true},"elasticbeanstalk":{"name":"ElasticBeanstalk","cors":true},"elb":{"prefix":"elasticloadbalancing","name":"ELB","cors":true},"elbv2":{"prefix":"elasticloadbalancingv2","name":"ELBv2","cors":true},"emr":{"prefix":"elasticmapreduce","name":"EMR","cors":true},"es":{"name":"ES"},"elastictranscoder":{"name":"ElasticTranscoder","cors":true},"firehose":{"name":"Firehose","cors":true},"gamelift":{"name":"GameLift","cors":true},"glacier":{"name":"Glacier"},"health":{"name":"Health"},"iam":{"name":"IAM","cors":true},"importexport":{"name":"ImportExport"},"inspector":{"name":"Inspector","versions":["2015-08-18*"],"cors":true},"iot":{"name":"Iot","cors":true},"iotdata":{"prefix":"iot-data","name":"IotData","cors":true},"kinesis":{"name":"Kinesis","cors":true},"kinesisanalytics":{"name":"KinesisAnalytics"},"kms":{"name":"KMS","cors":true},"lambda":{"name":"Lambda","cors":true},"lexruntime":{"prefix":"runtime.lex","name":"LexRuntime","cors":true},"lightsail":{"name":"Lightsail"},"machinelearning":{"name":"MachineLearning","cors":true},"marketplacecommerceanalytics":{"name":"MarketplaceCommerceAnalytics","cors":true},"marketplacemetering":{"prefix":"meteringmarketplace","name":"MarketplaceMetering"},"mturk":{"prefix":"mturk-requester","name":"MTurk","cors":true},"mobileanalytics":{"name":"MobileAnalytics","cors":true},"opsworks":{"name":"OpsWorks","cors":true},"opsworkscm":{"name":"OpsWorksCM"},"organizations":{"name":"Organizations"},"pinpoint":{"name":"Pinpoint"},"polly":{"name":"Polly","cors":true},"rds":{"name":"RDS","versions":["2014-09-01*"],"cors":true},"redshift":{"name":"Redshift","cors":true},"rekognition":{"name":"Rekognition","cors":true},"resourcegroupstaggingapi":{"name":"ResourceGroupsTaggingAPI"},"route53":{"name":"Route53","cors":true},"route53domains":{"name":"Route53Domains","cors":true},"s3":{"name":"S3","dualstackAvailable":true,"cors":true},"s3control":{"name":"S3Control","dualstackAvailable":true,"xmlNoDefaultLists":true},"servicecatalog":{"name":"ServiceCatalog","cors":true},"ses":{"prefix":"email","name":"SES","cors":true},"shield":{"name":"Shield"},"simpledb":{"prefix":"sdb","name":"SimpleDB"},"sms":{"name":"SMS"},"snowball":{"name":"Snowball"},"sns":{"name":"SNS","cors":true},"sqs":{"name":"SQS","cors":true},"ssm":{"name":"SSM","cors":true},"storagegateway":{"name":"StorageGateway","cors":true},"stepfunctions":{"prefix":"states","name":"StepFunctions"},"sts":{"name":"STS","cors":true},"support":{"name":"Support"},"swf":{"name":"SWF"},"xray":{"name":"XRay","cors":true},"waf":{"name":"WAF","cors":true},"wafregional":{"prefix":"waf-regional","name":"WAFRegional"},"workdocs":{"name":"WorkDocs","cors":true},"workspaces":{"name":"WorkSpaces"},"codestar":{"name":"CodeStar"},"lexmodelbuildingservice":{"prefix":"lex-models","name":"LexModelBuildingService","cors":true},"marketplaceentitlementservice":{"prefix":"entitlement.marketplace","name":"MarketplaceEntitlementService"},"athena":{"name":"Athena","cors":true},"greengrass":{"name":"Greengrass"},"dax":{"name":"DAX"},"migrationhub":{"prefix":"AWSMigrationHub","name":"MigrationHub"},"cloudhsmv2":{"name":"CloudHSMV2","cors":true},"glue":{"name":"Glue"},"mobile":{"name":"Mobile"},"pricing":{"name":"Pricing","cors":true},"costexplorer":{"prefix":"ce","name":"CostExplorer","cors":true},"mediaconvert":{"name":"MediaConvert"},"medialive":{"name":"MediaLive"},"mediapackage":{"name":"MediaPackage"},"mediastore":{"name":"MediaStore"},"mediastoredata":{"prefix":"mediastore-data","name":"MediaStoreData","cors":true},"appsync":{"name":"AppSync"},"guardduty":{"name":"GuardDuty"},"mq":{"name":"MQ"},"comprehend":{"name":"Comprehend","cors":true},"iotjobsdataplane":{"prefix":"iot-jobs-data","name":"IoTJobsDataPlane"},"kinesisvideoarchivedmedia":{"prefix":"kinesis-video-archived-media","name":"KinesisVideoArchivedMedia","cors":true},"kinesisvideomedia":{"prefix":"kinesis-video-media","name":"KinesisVideoMedia","cors":true},"kinesisvideo":{"name":"KinesisVideo","cors":true},"sagemakerruntime":{"prefix":"runtime.sagemaker","name":"SageMakerRuntime"},"sagemaker":{"name":"SageMaker"},"translate":{"name":"Translate","cors":true},"resourcegroups":{"prefix":"resource-groups","name":"ResourceGroups","cors":true},"alexaforbusiness":{"name":"AlexaForBusiness"},"cloud9":{"name":"Cloud9"},"serverlessapplicationrepository":{"prefix":"serverlessrepo","name":"ServerlessApplicationRepository"},"servicediscovery":{"name":"ServiceDiscovery"},"workmail":{"name":"WorkMail"},"autoscalingplans":{"prefix":"autoscaling-plans","name":"AutoScalingPlans"},"transcribeservice":{"prefix":"transcribe","name":"TranscribeService"},"connect":{"name":"Connect","cors":true},"acmpca":{"prefix":"acm-pca","name":"ACMPCA"},"fms":{"name":"FMS"},"secretsmanager":{"name":"SecretsManager","cors":true},"iotanalytics":{"name":"IoTAnalytics","cors":true},"iot1clickdevicesservice":{"prefix":"iot1click-devices","name":"IoT1ClickDevicesService"},"iot1clickprojects":{"prefix":"iot1click-projects","name":"IoT1ClickProjects"},"pi":{"name":"PI"},"neptune":{"name":"Neptune"},"mediatailor":{"name":"MediaTailor"},"eks":{"name":"EKS"},"macie":{"name":"Macie"},"dlm":{"name":"DLM"},"signer":{"name":"Signer"},"chime":{"name":"Chime"},"pinpointemail":{"prefix":"pinpoint-email","name":"PinpointEmail"},"ram":{"name":"RAM"},"route53resolver":{"name":"Route53Resolver"},"pinpointsmsvoice":{"prefix":"sms-voice","name":"PinpointSMSVoice"},"quicksight":{"name":"QuickSight"},"rdsdataservice":{"prefix":"rds-data","name":"RDSDataService"},"amplify":{"name":"Amplify"},"datasync":{"name":"DataSync"},"robomaker":{"name":"RoboMaker"},"transfer":{"name":"Transfer"},"globalaccelerator":{"name":"GlobalAccelerator"},"comprehendmedical":{"name":"ComprehendMedical","cors":true},"kinesisanalyticsv2":{"name":"KinesisAnalyticsV2"},"mediaconnect":{"name":"MediaConnect"},"fsx":{"name":"FSx"},"securityhub":{"name":"SecurityHub"},"appmesh":{"name":"AppMesh","versions":["2018-10-01*"]},"licensemanager":{"prefix":"license-manager","name":"LicenseManager"},"kafka":{"name":"Kafka"},"apigatewaymanagementapi":{"name":"ApiGatewayManagementApi"},"apigatewayv2":{"name":"ApiGatewayV2"},"docdb":{"name":"DocDB"},"backup":{"name":"Backup"},"worklink":{"name":"WorkLink"},"textract":{"name":"Textract"},"managedblockchain":{"name":"ManagedBlockchain"},"mediapackagevod":{"prefix":"mediapackage-vod","name":"MediaPackageVod"},"groundstation":{"name":"GroundStation"},"iotthingsgraph":{"name":"IoTThingsGraph"},"iotevents":{"name":"IoTEvents"},"ioteventsdata":{"prefix":"iotevents-data","name":"IoTEventsData"},"personalize":{"name":"Personalize","cors":true},"personalizeevents":{"prefix":"personalize-events","name":"PersonalizeEvents","cors":true},"personalizeruntime":{"prefix":"personalize-runtime","name":"PersonalizeRuntime","cors":true},"applicationinsights":{"prefix":"application-insights","name":"ApplicationInsights"},"servicequotas":{"prefix":"service-quotas","name":"ServiceQuotas"},"ec2instanceconnect":{"prefix":"ec2-instance-connect","name":"EC2InstanceConnect"},"eventbridge":{"name":"EventBridge"},"lakeformation":{"name":"LakeFormation"},"forecastservice":{"prefix":"forecast","name":"ForecastService","cors":true},"forecastqueryservice":{"prefix":"forecastquery","name":"ForecastQueryService","cors":true},"qldb":{"name":"QLDB"},"qldbsession":{"prefix":"qldb-session","name":"QLDBSession"},"workmailmessageflow":{"name":"WorkMailMessageFlow"},"codestarnotifications":{"prefix":"codestar-notifications","name":"CodeStarNotifications"},"savingsplans":{"name":"SavingsPlans"},"sso":{"name":"SSO"},"ssooidc":{"prefix":"sso-oidc","name":"SSOOIDC"},"marketplacecatalog":{"prefix":"marketplace-catalog","name":"MarketplaceCatalog"},"dataexchange":{"name":"DataExchange"},"sesv2":{"name":"SESV2"},"migrationhubconfig":{"prefix":"migrationhub-config","name":"MigrationHubConfig"},"connectparticipant":{"name":"ConnectParticipant"},"appconfig":{"name":"AppConfig"},"iotsecuretunneling":{"name":"IoTSecureTunneling"},"wafv2":{"name":"WAFV2"},"elasticinference":{"prefix":"elastic-inference","name":"ElasticInference"},"imagebuilder":{"name":"Imagebuilder"},"schemas":{"name":"Schemas"},"accessanalyzer":{"name":"AccessAnalyzer"},"codegurureviewer":{"prefix":"codeguru-reviewer","name":"CodeGuruReviewer"},"codeguruprofiler":{"name":"CodeGuruProfiler"},"computeoptimizer":{"prefix":"compute-optimizer","name":"ComputeOptimizer"},"frauddetector":{"name":"FraudDetector"},"kendra":{"name":"Kendra"},"networkmanager":{"name":"NetworkManager"},"outposts":{"name":"Outposts"},"augmentedairuntime":{"prefix":"sagemaker-a2i-runtime","name":"AugmentedAIRuntime"},"ebs":{"name":"EBS"},"kinesisvideosignalingchannels":{"prefix":"kinesis-video-signaling","name":"KinesisVideoSignalingChannels","cors":true},"detective":{"name":"Detective"},"codestarconnections":{"prefix":"codestar-connections","name":"CodeStarconnections"},"synthetics":{"name":"Synthetics"},"iotsitewise":{"name":"IoTSiteWise"},"macie2":{"name":"Macie2"},"codeartifact":{"name":"CodeArtifact"},"honeycode":{"name":"Honeycode"},"ivs":{"name":"IVS"},"braket":{"name":"Braket"},"identitystore":{"name":"IdentityStore"},"appflow":{"name":"Appflow"},"redshiftdata":{"prefix":"redshift-data","name":"RedshiftData"},"ssoadmin":{"prefix":"sso-admin","name":"SSOAdmin"},"timestreamquery":{"prefix":"timestream-query","name":"TimestreamQuery"},"timestreamwrite":{"prefix":"timestream-write","name":"TimestreamWrite"},"s3outposts":{"name":"S3Outposts"},"databrew":{"name":"DataBrew"},"servicecatalogappregistry":{"prefix":"servicecatalog-appregistry","name":"ServiceCatalogAppRegistry"},"networkfirewall":{"prefix":"network-firewall","name":"NetworkFirewall"},"mwaa":{"name":"MWAA"},"amplifybackend":{"name":"AmplifyBackend"},"appintegrations":{"name":"AppIntegrations"},"connectcontactlens":{"prefix":"connect-contact-lens","name":"ConnectContactLens"},"devopsguru":{"prefix":"devops-guru","name":"DevOpsGuru"},"ecrpublic":{"prefix":"ecr-public","name":"ECRPUBLIC"},"lookoutvision":{"name":"LookoutVision"},"sagemakerfeaturestoreruntime":{"prefix":"sagemaker-featurestore-runtime","name":"SageMakerFeatureStoreRuntime"},"customerprofiles":{"prefix":"customer-profiles","name":"CustomerProfiles"},"auditmanager":{"name":"AuditManager"},"emrcontainers":{"prefix":"emr-containers","name":"EMRcontainers"},"healthlake":{"name":"HealthLake"},"sagemakeredge":{"prefix":"sagemaker-edge","name":"SagemakerEdge"},"amp":{"name":"Amp"},"greengrassv2":{"name":"GreengrassV2"},"iotdeviceadvisor":{"name":"IotDeviceAdvisor"},"iotfleethub":{"name":"IoTFleetHub"},"iotwireless":{"name":"IoTWireless"},"location":{"name":"Location","cors":true},"wellarchitected":{"name":"WellArchitected"},"lexmodelsv2":{"prefix":"models.lex.v2","name":"LexModelsV2"},"lexruntimev2":{"prefix":"runtime.lex.v2","name":"LexRuntimeV2","cors":true},"fis":{"name":"Fis"},"lookoutmetrics":{"name":"LookoutMetrics"},"mgn":{"name":"Mgn"},"lookoutequipment":{"name":"LookoutEquipment"},"nimble":{"name":"Nimble"},"finspace":{"name":"Finspace"},"finspacedata":{"prefix":"finspace-data","name":"Finspacedata"},"ssmcontacts":{"prefix":"ssm-contacts","name":"SSMContacts"},"ssmincidents":{"prefix":"ssm-incidents","name":"SSMIncidents"},"applicationcostprofiler":{"name":"ApplicationCostProfiler"},"apprunner":{"name":"AppRunner"},"proton":{"name":"Proton"},"route53recoverycluster":{"prefix":"route53-recovery-cluster","name":"Route53RecoveryCluster"},"route53recoverycontrolconfig":{"prefix":"route53-recovery-control-config","name":"Route53RecoveryControlConfig"},"route53recoveryreadiness":{"prefix":"route53-recovery-readiness","name":"Route53RecoveryReadiness"},"chimesdkidentity":{"prefix":"chime-sdk-identity","name":"ChimeSDKIdentity"},"chimesdkmessaging":{"prefix":"chime-sdk-messaging","name":"ChimeSDKMessaging"},"snowdevicemanagement":{"prefix":"snow-device-management","name":"SnowDeviceManagement"},"memorydb":{"name":"MemoryDB"},"opensearch":{"name":"OpenSearch"},"kafkaconnect":{"name":"KafkaConnect"},"voiceid":{"prefix":"voice-id","name":"VoiceID"},"wisdom":{"name":"Wisdom"},"account":{"name":"Account"},"cloudcontrol":{"name":"CloudControl"},"grafana":{"name":"Grafana"},"panorama":{"name":"Panorama"},"chimesdkmeetings":{"prefix":"chime-sdk-meetings","name":"ChimeSDKMeetings"},"resiliencehub":{"name":"Resiliencehub"},"migrationhubstrategy":{"name":"MigrationHubStrategy"},"appconfigdata":{"name":"AppConfigData"},"drs":{"name":"Drs"},"migrationhubrefactorspaces":{"prefix":"migration-hub-refactor-spaces","name":"MigrationHubRefactorSpaces"},"evidently":{"name":"Evidently"},"inspector2":{"name":"Inspector2"},"rbin":{"name":"Rbin"},"rum":{"name":"RUM"},"backupgateway":{"prefix":"backup-gateway","name":"BackupGateway"},"iottwinmaker":{"name":"IoTTwinMaker"},"workspacesweb":{"prefix":"workspaces-web","name":"WorkSpacesWeb"},"amplifyuibuilder":{"name":"AmplifyUIBuilder"}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/sts-2011-06-15.min.json":
/*!***********************************************************!*\
  !*** ./node_modules/aws-sdk/apis/sts-2011-06-15.min.json ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2011-06-15","endpointPrefix":"sts","globalEndpoint":"sts.amazonaws.com","protocol":"query","serviceAbbreviation":"AWS STS","serviceFullName":"AWS Security Token Service","serviceId":"STS","signatureVersion":"v4","uid":"sts-2011-06-15","xmlNamespace":"https://sts.amazonaws.com/doc/2011-06-15/"},"operations":{"AssumeRole":{"input":{"type":"structure","required":["RoleArn","RoleSessionName"],"members":{"RoleArn":{},"RoleSessionName":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"},"Tags":{"shape":"S8"},"TransitiveTagKeys":{"type":"list","member":{}},"ExternalId":{},"SerialNumber":{},"TokenCode":{},"SourceIdentity":{}}},"output":{"resultWrapper":"AssumeRoleResult","type":"structure","members":{"Credentials":{"shape":"Si"},"AssumedRoleUser":{"shape":"Sn"},"PackedPolicySize":{"type":"integer"},"SourceIdentity":{}}}},"AssumeRoleWithSAML":{"input":{"type":"structure","required":["RoleArn","PrincipalArn","SAMLAssertion"],"members":{"RoleArn":{},"PrincipalArn":{},"SAMLAssertion":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithSAMLResult","type":"structure","members":{"Credentials":{"shape":"Si"},"AssumedRoleUser":{"shape":"Sn"},"PackedPolicySize":{"type":"integer"},"Subject":{},"SubjectType":{},"Issuer":{},"Audience":{},"NameQualifier":{},"SourceIdentity":{}}}},"AssumeRoleWithWebIdentity":{"input":{"type":"structure","required":["RoleArn","RoleSessionName","WebIdentityToken"],"members":{"RoleArn":{},"RoleSessionName":{},"WebIdentityToken":{},"ProviderId":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithWebIdentityResult","type":"structure","members":{"Credentials":{"shape":"Si"},"SubjectFromWebIdentityToken":{},"AssumedRoleUser":{"shape":"Sn"},"PackedPolicySize":{"type":"integer"},"Provider":{},"Audience":{},"SourceIdentity":{}}}},"DecodeAuthorizationMessage":{"input":{"type":"structure","required":["EncodedMessage"],"members":{"EncodedMessage":{}}},"output":{"resultWrapper":"DecodeAuthorizationMessageResult","type":"structure","members":{"DecodedMessage":{}}}},"GetAccessKeyInfo":{"input":{"type":"structure","required":["AccessKeyId"],"members":{"AccessKeyId":{}}},"output":{"resultWrapper":"GetAccessKeyInfoResult","type":"structure","members":{"Account":{}}}},"GetCallerIdentity":{"input":{"type":"structure","members":{}},"output":{"resultWrapper":"GetCallerIdentityResult","type":"structure","members":{"UserId":{},"Account":{},"Arn":{}}}},"GetFederationToken":{"input":{"type":"structure","required":["Name"],"members":{"Name":{},"Policy":{},"PolicyArns":{"shape":"S4"},"DurationSeconds":{"type":"integer"},"Tags":{"shape":"S8"}}},"output":{"resultWrapper":"GetFederationTokenResult","type":"structure","members":{"Credentials":{"shape":"Si"},"FederatedUser":{"type":"structure","required":["FederatedUserId","Arn"],"members":{"FederatedUserId":{},"Arn":{}}},"PackedPolicySize":{"type":"integer"}}}},"GetSessionToken":{"input":{"type":"structure","members":{"DurationSeconds":{"type":"integer"},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"GetSessionTokenResult","type":"structure","members":{"Credentials":{"shape":"Si"}}}}},"shapes":{"S4":{"type":"list","member":{"type":"structure","members":{"arn":{}}}},"S8":{"type":"list","member":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}}},"Si":{"type":"structure","required":["AccessKeyId","SecretAccessKey","SessionToken","Expiration"],"members":{"AccessKeyId":{},"SecretAccessKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}},"Sn":{"type":"structure","required":["AssumedRoleId","Arn"],"members":{"AssumedRoleId":{},"Arn":{}}}}}');

/***/ }),

/***/ "./node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json":
/*!******************************************************************!*\
  !*** ./node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = {"pagination":{}};

/***/ }),

/***/ "./node_modules/aws-sdk/lib/region_config_data.json":
/*!**********************************************************!*\
  !*** ./node_modules/aws-sdk/lib/region_config_data.json ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"rules":{"*/*":{"endpoint":"{service}.{region}.amazonaws.com"},"cn-*/*":{"endpoint":"{service}.{region}.amazonaws.com.cn"},"us-iso-*/*":"usIso","us-isob-*/*":"usIsob","*/budgets":"globalSSL","*/cloudfront":"globalSSL","*/sts":"globalSSL","*/importexport":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2","globalEndpoint":true},"*/route53":"globalSSL","cn-*/route53":{"endpoint":"{service}.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-northwest-1"},"us-gov-*/route53":"globalGovCloud","*/waf":"globalSSL","*/iam":"globalSSL","cn-*/iam":{"endpoint":"{service}.cn-north-1.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-north-1"},"us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{"endpoint":"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3signature","us-west-1/s3":"s3signature","us-west-2/s3":"s3signature","eu-west-1/s3":"s3signature","ap-southeast-1/s3":"s3signature","ap-southeast-2/s3":"s3signature","ap-northeast-1/s3":"s3signature","sa-east-1/s3":"s3signature","us-east-1/s3":{"endpoint":"{service}.amazonaws.com","signatureVersion":"s3"},"us-east-1/sdb":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2"},"*/sdb":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"v2"}},"fipsRules":{"*/*":"fipsStandard","us-gov-*/*":"fipsStandard","us-iso-*/*":{"endpoint":"{service}-fips.{region}.c2s.ic.gov"},"us-iso-*/dms":"usIso","us-isob-*/*":{"endpoint":"{service}-fips.{region}.sc2s.sgov.gov"},"us-isob-*/dms":"usIsob","cn-*/*":{"endpoint":"{service}-fips.{region}.amazonaws.com.cn"},"*/api.ecr":"fips.api.ecr","*/api.sagemaker":"fips.api.sagemaker","*/batch":"fipsDotPrefix","*/eks":"fipsDotPrefix","*/models.lex":"fips.models.lex","*/runtime.lex":"fips.runtime.lex","*/runtime.sagemaker":{"endpoint":"runtime-fips.sagemaker.{region}.amazonaws.com"},"*/iam":"fipsWithoutRegion","*/route53":"fipsWithoutRegion","*/transcribe":"fipsDotPrefix","*/waf":"fipsWithoutRegion","us-gov-*/transcribe":"fipsDotPrefix","us-gov-*/api.ecr":"fips.api.ecr","us-gov-*/api.sagemaker":"fips.api.sagemaker","us-gov-*/models.lex":"fips.models.lex","us-gov-*/runtime.lex":"fips.runtime.lex","us-gov-*/acm-pca":"fipsWithServiceOnly","us-gov-*/batch":"fipsWithServiceOnly","us-gov-*/config":"fipsWithServiceOnly","us-gov-*/eks":"fipsWithServiceOnly","us-gov-*/elasticmapreduce":"fipsWithServiceOnly","us-gov-*/identitystore":"fipsWithServiceOnly","us-gov-*/dynamodb":"fipsWithServiceOnly","us-gov-*/elasticloadbalancing":"fipsWithServiceOnly","us-gov-*/guardduty":"fipsWithServiceOnly","us-gov-*/monitoring":"fipsWithServiceOnly","us-gov-*/resource-groups":"fipsWithServiceOnly","us-gov-*/runtime.sagemaker":"fipsWithServiceOnly","us-gov-*/servicecatalog-appregistry":"fipsWithServiceOnly","us-gov-*/servicequotas":"fipsWithServiceOnly","us-gov-*/ssm":"fipsWithServiceOnly","us-gov-*/sts":"fipsWithServiceOnly","us-gov-*/support":"fipsWithServiceOnly","us-gov-west-1/states":"fipsWithServiceOnly","us-iso-east-1/elasticfilesystem":{"endpoint":"elasticfilesystem-fips.{region}.c2s.ic.gov"},"us-gov-west-1/organizations":"fipsWithServiceOnly","us-gov-west-1/route53":{"endpoint":"route53.us-gov.amazonaws.com"}},"dualstackRules":{"*/*":{"endpoint":"{service}.{region}.api.aws"},"cn-*/*":{"endpoint":"{service}.{region}.api.amazonwebservices.com.cn"},"*/s3":"dualstackLegacy","cn-*/s3":"dualstackLegacyCn","*/s3-control":"dualstackLegacy","cn-*/s3-control":"dualstackLegacyCn","ap-south-1/ec2":"dualstackLegacyEc2","eu-west-1/ec2":"dualstackLegacyEc2","sa-east-1/ec2":"dualstackLegacyEc2","us-east-1/ec2":"dualstackLegacyEc2","us-east-2/ec2":"dualstackLegacyEc2","us-west-2/ec2":"dualstackLegacyEc2"},"dualstackFipsRules":{"*/*":{"endpoint":"{service}-fips.{region}.api.aws"},"cn-*/*":{"endpoint":"{service}-fips.{region}.api.amazonwebservices.com.cn"},"*/s3":"dualstackFipsLegacy","cn-*/s3":"dualstackFipsLegacyCn","*/s3-control":"dualstackFipsLegacy","cn-*/s3-control":"dualstackFipsLegacyCn"},"patterns":{"globalSSL":{"endpoint":"https://{service}.amazonaws.com","globalEndpoint":true,"signingRegion":"us-east-1"},"globalGovCloud":{"endpoint":"{service}.us-gov.amazonaws.com","globalEndpoint":true,"signingRegion":"us-gov-west-1"},"s3signature":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"s3"},"usIso":{"endpoint":"{service}.{region}.c2s.ic.gov"},"usIsob":{"endpoint":"{service}.{region}.sc2s.sgov.gov"},"fipsStandard":{"endpoint":"{service}-fips.{region}.amazonaws.com"},"fipsDotPrefix":{"endpoint":"fips.{service}.{region}.amazonaws.com"},"fipsWithoutRegion":{"endpoint":"{service}-fips.amazonaws.com"},"fips.api.ecr":{"endpoint":"ecr-fips.{region}.amazonaws.com"},"fips.api.sagemaker":{"endpoint":"api-fips.sagemaker.{region}.amazonaws.com"},"fips.models.lex":{"endpoint":"models-fips.lex.{region}.amazonaws.com"},"fips.runtime.lex":{"endpoint":"runtime-fips.lex.{region}.amazonaws.com"},"fipsWithServiceOnly":{"endpoint":"{service}.{region}.amazonaws.com"},"dualstackLegacy":{"endpoint":"{service}.dualstack.{region}.amazonaws.com"},"dualstackLegacyCn":{"endpoint":"{service}.dualstack.{region}.amazonaws.com.cn"},"dualstackFipsLegacy":{"endpoint":"{service}-fips.dualstack.{region}.amazonaws.com"},"dualstackFipsLegacyCn":{"endpoint":"{service}-fips.dualstack.{region}.amazonaws.com.cn"},"dualstackLegacyEc2":{"endpoint":"api.ec2.{region}.aws"}}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!******************!*\
  !*** ./index.js ***!
  \******************/
const DynamoDB = __webpack_require__(/*! aws-sdk/clients/dynamodb */ "./node_modules/aws-sdk/clients/dynamodb.js")
const { REGION, ADMINS_TABLE } = process.env;
const docClient = new DynamoDB.DocumentClient({ region: REGION })

exports.handler = async (event) => {
  const accountId = event.requestContext.authorizer.id

  const params = {
    TableName: ADMINS_TABLE,
    ExclusiveStartKey: undefined,
    FilterExpression: `id = :id`,
    ProjectionExpression: "email, id, #n, commercial_name, phone_number, is_email_verified, original_profile_photo, image_position, image_zoom, image_rotate",
    ExpressionAttributeValues: {
      ":id": accountId 
    },
    ExpressionAttributeNames: {
      "#n": "name"
    }
  }

  try {
    const items = await docClient.scan(params).promise()

    return {
      statusCode: 200,
      body: JSON.stringify(items.Items),
      headers: {
        "Access-Control-Allow-Origin": "*", // Required for CORS support to work
      },
      isBase64Encoded: false,
    }
  } catch (error) {
    console.error(error);

    return {
      statusCode: error.statusCode,
      body: JSON.stringify({ message: "Erro desconhecido, tente novamente." }),
      headers: {
        "Access-Control-Allow-Origin": "*", // Required for CORS support to work
      },
      isBase64Encoded: false,
    }
  }
}
})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FB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LGtDQUFrQyw4Q0FBOEM7QUFDaEYsU0FBUyxrQ0FBa0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDek5BLFdBQVcsbUJBQU8sQ0FBQyxtREFBUzs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3REEsV0FBVyxtQkFBTyxDQUFDLG1EQUFTOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25FQSxVQUFVLG1CQUFPLENB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QUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVELGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCx3Q0FBd0MsZUFBZTtBQUN2RCwwQ0FBMEMsZUFBZTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUJBQXVCO0FBQzdCO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixxQkFB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OUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSxtRUFBbUUsRUFBRTs7QUFFckU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEI7QUFDOUIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ROQSxVQUFVLG1CQUFPLENBQUMsbURBQVM7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9C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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjs7Ozs7Ozs7OztBQzFHaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUI7QUFDcEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlB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Q2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxjQUFjO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQzs7Ozs7Ozs7Ozs7QUN0UkQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQiwyREFBMkQsa0JBQWtCLDRCQUE0QixtQ0FBbUMsOEJBQThCLG9DQUFvQyxlQUFlO0FBQzlSLGdCQUFnQjs7QUFFaEIsbUJBQW1CLG1CQUFPLENBQUMseUVBQWtCOztBQUU3QyxlQUFlLG1CQUFPLENBQUMsaUVBQWM7O0FBRXJDLGFBQWEsbUJBQU8sQ0FBQyw2REFBWTs7QUFFakMsZUFBZSxtQkFBTyxDQUFDLGlFQUFjOztBQUVyQyxlQUFlLG1CQUFPLENBQUMsaUVBQWM7O0FBRXJDLFdBQVcsbUJBQU8sQ0FBQyx5REFBVTs7QUFFN0IsWUFBWSxtQkFBTyxDQUFDLDJEQUFXOztBQUUvQiw2QkFBNkIsbUJBQU8sQ0FBQyw2RkFBNEI7O0FBRWpFLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFpQjs7QUFFM0Msa0JBQWtCLG1CQUFPLENBQUMsdUVBQWlCOztBQUUzQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBZ0I7O0FBRXpDLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFrQjs7QUFFN0Msa0JBQWtCLG1CQUFPLENBQUMsdUVBQWlCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7Ozs7OztBQzdVRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CLG9DQUFvQztBQUNwRixnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FB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QTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDQUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7Ozs7OztBQ3RCQSxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBMEI7QUFDbkQsUUFBUSx1QkFBdUI7QUFDL0IsZ0RBQWdELGdCQUFnQjs7QUFFaEUsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQWdEO0FBQzdFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9jb2duaXRvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9jbGllbnRzL2R5bmFtb2RiLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9zdHMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYXBpX2xvYWRlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29uZmlnX3JlZ2lvbmFsX2VuZHBvaW50LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY2hhaW5hYmxlX3RlbXBvcmFyeV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9jb2duaXRvX2lkZW50aXR5X2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2NyZWRlbnRpYWxfcHJvdmlkZXJfY2hhaW4uanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvZWMyX21ldGFkYXRhX2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2Vjc19jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9lbnZpcm9ubWVudF9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9maWxlX3N5c3RlbV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9wcm9jZXNzX2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3JlbW90ZV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9zYW1sX2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3NoYXJlZF9pbmlfZmlsZV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy90ZW1wb3JhcnlfY3JlZGVudGlhbHMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvdG9rZW5fZmlsZV93ZWJfaWRlbnRpdHlfY3JlZGVudGlhbHMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvd2ViX2lkZW50aXR5X2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Rpc2NvdmVyX2VuZHBvaW50LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2R5bmFtb2RiL2NvbnZlcnRlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9keW5hbW9kYi9kb2N1bWVudF9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZHluYW1vZGIvbnVtYmVyVmFsdWUuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZHluYW1vZGIvc2V0LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2R5bmFtb2RiL3RyYW5zbGF0b3IuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZHluYW1vZGIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2J1ZmZlcmVkLWNyZWF0ZS1ldmVudC1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlci1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vZXZlbnQtbWVzc2FnZS11bm1hcnNoYWxsZXItc3RyZWFtLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9pbnQ2NC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vcGFyc2UtZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3BhcnNlLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3NwbGl0LW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3N0cmVhbWluZy1jcmVhdGUtZXZlbnQtc3RyZWFtLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50X2xpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2h0dHAvbm9kZS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9qc29uL2J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvanNvbi9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbWV0YWRhdGFfc2VydmljZS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tZXRhZGF0YV9zZXJ2aWNlL2dldF9lbmRwb2ludC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tZXRhZGF0YV9zZXJ2aWNlL2dldF9lbmRwb2ludF9jb25maWdfb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tZXRhZGF0YV9zZXJ2aWNlL2dldF9lbmRwb2ludF9tb2RlLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21ldGFkYXRhX3NlcnZpY2UvZ2V0X2VuZHBvaW50X21vZGVfY29uZmlnX29wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbWV0YWRhdGFfc2VydmljZS9nZXRfbWV0YWRhdGFfc2VydmljZV9lbmRwb2ludC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9hcGkuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvcGFnaW5hdG9yLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3Jlc291cmNlX3dhaXRlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9zaGFwZS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ub2RlX2xvYWRlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wYXJhbV92YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9qc29uLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3F1ZXJ5LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3QuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdF9qc29uLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3RfeG1sLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3B1Ymxpc2hlci9jb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3B1Ymxpc2hlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9xdWVyeS9xdWVyeV9wYXJhbV9zZXJpYWxpemVyLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlYWxjbG9jay9ub2RlQ2xvY2suanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVnaW9uL3V0aWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlZ2lvbl9jb25maWcuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZXNvdXJjZV93YWl0ZXIuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VxdWVudGlhbF9leGVjdXRvci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXJ2aWNlLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL2R5bmFtb2RiLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL3N0cy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaGFyZWQtaW5pL2luZGV4LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NoYXJlZC1pbmkvaW5pLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3ByZXNpZ24uanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy9yZXF1ZXN0X3NpZ25lci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3MzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjIuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92My5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3YzaHR0cHMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92NC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3Y0X2NyZWRlbnRpYWxzLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3N0YXRlX21hY2hpbmUuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvYnVpbGRlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL25vZGVfcGFyc2VyLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC94bWwtbm9kZS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwveG1sLXRleHQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay92ZW5kb3IvZW5kcG9pbnQtY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvYXdzLXNkay92ZW5kb3IvZW5kcG9pbnQtY2FjaGUvdXRpbHMvTFJVLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL2ptZXNwYXRoL2ptZXNwYXRoLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3NheC9saWIvc2F4LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWwyanMvbGliL2JvbS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWwyanMvbGliL2J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sMmpzL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWwyanMvbGliL3BhcnNlci5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWwyanMvbGliL3Byb2Nlc3NvcnMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sMmpzL2xpYi94bWwyanMuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvVXRpbGl0eS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxBdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ0RhdGEuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ29tbWVudC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVERBdHRMaXN0LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRERW50aXR5LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERURE5vdGF0aW9uLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERvY1R5cGUuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRG9jdW1lbnRDQi5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxFbGVtZW50LmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTE5vZGUuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFJhdy5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxTdHJlYW1Xcml0ZXIuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MU3RyaW5nV3JpdGVyLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFN0cmluZ2lmaWVyLmpzIiwid2VicGFjazovL2dldC1hY2NvdW50Ly4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFRleHQuanMiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MV3JpdGVyQmFzZS5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiYnVmZmVyXCIiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImNoaWxkX3Byb2Nlc3NcIiIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY3J5cHRvXCIiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImRncmFtXCIiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImRvbWFpblwiIiwid2VicGFjazovL2dldC1hY2NvdW50L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJldmVudHNcIiIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZnNcIiIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cFwiIiwid2VicGFjazovL2dldC1hY2NvdW50L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJodHRwc1wiIiwid2VicGFjazovL2dldC1hY2NvdW50L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJvc1wiIiwid2VicGFjazovL2dldC1hY2NvdW50L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInF1ZXJ5c3RyaW5nXCIiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInN0cmVhbVwiIiwid2VicGFjazovL2dldC1hY2NvdW50L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJzdHJpbmdfZGVjb2RlclwiIiwid2VicGFjazovL2dldC1hY2NvdW50L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ0aW1lcnNcIiIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXJsXCIiLCJ3ZWJwYWNrOi8vZ2V0LWFjY291bnQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInV0aWxcIiIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9nZXQtYWNjb3VudC8uL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uL2xpYi9ub2RlX2xvYWRlcicpO1xudmFyIEFXUyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlJyk7XG52YXIgU2VydmljZSA9IEFXUy5TZXJ2aWNlO1xudmFyIGFwaUxvYWRlciA9IEFXUy5hcGlMb2FkZXI7XG5cbmFwaUxvYWRlci5zZXJ2aWNlc1snY29nbml0b2lkZW50aXR5J10gPSB7fTtcbkFXUy5Db2duaXRvSWRlbnRpdHkgPSBTZXJ2aWNlLmRlZmluZVNlcnZpY2UoJ2NvZ25pdG9pZGVudGl0eScsIFsnMjAxNC0wNi0zMCddKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGlMb2FkZXIuc2VydmljZXNbJ2NvZ25pdG9pZGVudGl0eSddLCAnMjAxNC0wNi0zMCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIG1vZGVsID0gcmVxdWlyZSgnLi4vYXBpcy9jb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzAubWluLmpzb24nKTtcbiAgICBtb2RlbC5wYWdpbmF0b3JzID0gcmVxdWlyZSgnLi4vYXBpcy9jb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzAucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLkNvZ25pdG9JZGVudGl0eTtcbiIsInJlcXVpcmUoJy4uL2xpYi9ub2RlX2xvYWRlcicpO1xudmFyIEFXUyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlJyk7XG52YXIgU2VydmljZSA9IEFXUy5TZXJ2aWNlO1xudmFyIGFwaUxvYWRlciA9IEFXUy5hcGlMb2FkZXI7XG5cbmFwaUxvYWRlci5zZXJ2aWNlc1snZHluYW1vZGInXSA9IHt9O1xuQVdTLkR5bmFtb0RCID0gU2VydmljZS5kZWZpbmVTZXJ2aWNlKCdkeW5hbW9kYicsIFsnMjAxMS0xMi0wNScsICcyMDEyLTA4LTEwJ10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL2R5bmFtb2RiJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpTG9hZGVyLnNlcnZpY2VzWydkeW5hbW9kYiddLCAnMjAxMS0xMi0wNScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIG1vZGVsID0gcmVxdWlyZSgnLi4vYXBpcy9keW5hbW9kYi0yMDExLTEyLTA1Lm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvZHluYW1vZGItMjAxMS0xMi0wNS5wYWdpbmF0b3JzLmpzb24nKS5wYWdpbmF0aW9uO1xuICAgIG1vZGVsLndhaXRlcnMgPSByZXF1aXJlKCcuLi9hcGlzL2R5bmFtb2RiLTIwMTEtMTItMDUud2FpdGVyczIuanNvbicpLndhaXRlcnM7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snZHluYW1vZGInXSwgJzIwMTItMDgtMTAnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvZHluYW1vZGItMjAxMi0wOC0xMC5taW4uanNvbicpO1xuICAgIG1vZGVsLnBhZ2luYXRvcnMgPSByZXF1aXJlKCcuLi9hcGlzL2R5bmFtb2RiLTIwMTItMDgtMTAucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICBtb2RlbC53YWl0ZXJzID0gcmVxdWlyZSgnLi4vYXBpcy9keW5hbW9kYi0yMDEyLTA4LTEwLndhaXRlcnMyLmpzb24nKS53YWl0ZXJzO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuRHluYW1vREI7XG4iLCJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ3N0cyddID0ge307XG5BV1MuU1RTID0gU2VydmljZS5kZWZpbmVTZXJ2aWNlKCdzdHMnLCBbJzIwMTEtMDYtMTUnXSk7XG5yZXF1aXJlKCcuLi9saWIvc2VydmljZXMvc3RzJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpTG9hZGVyLnNlcnZpY2VzWydzdHMnXSwgJzIwMTEtMDYtMTUnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvc3RzLTIwMTEtMDYtMTUubWluLmpzb24nKTtcbiAgICBtb2RlbC5wYWdpbmF0b3JzID0gcmVxdWlyZSgnLi4vYXBpcy9zdHMtMjAxMS0wNi0xNS5wYWdpbmF0b3JzLmpzb24nKS5wYWdpbmF0aW9uO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuU1RTO1xuIiwiZnVuY3Rpb24gYXBpTG9hZGVyKHN2YywgdmVyc2lvbikge1xuICBpZiAoIWFwaUxvYWRlci5zZXJ2aWNlcy5oYXNPd25Qcm9wZXJ0eShzdmMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU2VydmljZTogRmFpbGVkIHRvIGxvYWQgYXBpIGZvciAnICsgc3ZjKTtcbiAgfVxuICByZXR1cm4gYXBpTG9hZGVyLnNlcnZpY2VzW3N2Y11bdmVyc2lvbl07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKlxuICogVGhpcyBtZW1iZXIgb2YgQVdTLmFwaUxvYWRlciBpcyBwcml2YXRlLCBidXQgY2hhbmdpbmcgaXQgd2lsbCBuZWNlc3NpdGF0ZSBhXG4gKiBjaGFuZ2UgdG8gLi4vc2NyaXB0cy9zZXJ2aWNlcy10YWJsZS1nZW5lcmF0b3IudHNcbiAqL1xuYXBpTG9hZGVyLnNlcnZpY2VzID0ge307XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYXBpTG9hZGVyO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluJyk7XG52YXIgUHJvbWlzZXNEZXBlbmRlbmN5O1xuXG4vKipcbiAqIFRoZSBtYWluIGNvbmZpZ3VyYXRpb24gY2xhc3MgdXNlZCBieSBhbGwgc2VydmljZSBvYmplY3RzIHRvIHNldFxuICogdGhlIHJlZ2lvbiwgY3JlZGVudGlhbHMsIGFuZCBvdGhlciBvcHRpb25zIGZvciByZXF1ZXN0cy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBjcmVkZW50aWFscyBhbmQgcmVnaW9uIHNldHRpbmdzIGFyZSBsZWZ0IHVuY29uZmlndXJlZC5cbiAqIFRoaXMgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGJlZm9yZSB1c2luZyBhbnlcbiAqIEFXUyBzZXJ2aWNlIEFQSXMuXG4gKlxuICogSW4gb3JkZXIgdG8gc2V0IGdsb2JhbCBjb25maWd1cmF0aW9uIG9wdGlvbnMsIHByb3BlcnRpZXMgc2hvdWxkXG4gKiBiZSBhc3NpZ25lZCB0byB0aGUgZ2xvYmFsIHtBV1MuY29uZmlnfSBvYmplY3QuXG4gKlxuICogQHNlZSBBV1MuY29uZmlnXG4gKlxuICogQCFncm91cCBHZW5lcmFsIENvbmZpZ3VyYXRpb24gT3B0aW9uc1xuICpcbiAqIEAhYXR0cmlidXRlIGNyZWRlbnRpYWxzXG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gdGhlIEFXUyBjcmVkZW50aWFscyB0byBzaWduIHJlcXVlc3RzIHdpdGguXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVnaW9uXG4gKiAgIEBleGFtcGxlIFNldCB0aGUgZ2xvYmFsIHJlZ2lvbiBzZXR0aW5nIHRvIHVzLXdlc3QtMlxuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZWdpb246ICd1cy13ZXN0LTInfSk7XG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gVGhlIHJlZ2lvbiB0byBzZW5kIHNlcnZpY2UgcmVxdWVzdHMgdG8uXG4gKiAgIEBzZWUgaHR0cDovL2RvY3MuYW1hem9ud2Vic2VydmljZXMuY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3JhbmRlLmh0bWxcbiAqICAgICBBIGxpc3Qgb2YgYXZhaWxhYmxlIGVuZHBvaW50cyBmb3IgZWFjaCBBV1Mgc2VydmljZVxuICpcbiAqIEAhYXR0cmlidXRlIG1heFJldHJpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJldHJpZXMgdG8gcGVyZm9ybSBmb3IgYVxuICogICAgIHNlcnZpY2UgcmVxdWVzdC4gQnkgZGVmYXVsdCB0aGlzIHZhbHVlIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIHNwZWNpZmljXG4gKiAgICAgc2VydmljZSBvYmplY3QgdGhhdCB0aGUgcmVxdWVzdCBpcyBiZWluZyBtYWRlIHRvLlxuICpcbiAqIEAhYXR0cmlidXRlIG1heFJlZGlyZWN0c1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmVkaXJlY3RzIHRvIGZvbGxvdyBmb3IgYVxuICogICAgIHNlcnZpY2UgcmVxdWVzdC4gRGVmYXVsdHMgdG8gMTAuXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1WYWxpZGF0aW9uXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIGJlIHZhbGlkYXRlZCBhZ2FpbnN0XG4gKiAgICAgdGhlIG9wZXJhdGlvbiBkZXNjcmlwdGlvbiBiZWZvcmUgc2VuZGluZyB0aGUgcmVxdWVzdC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBzcGVjaWZpYyB2YWxpZGF0aW9uIGZlYXR1cmVzOlxuICpcbiAqICAgICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gKiAgICAgICBjb25zdHJhaW50LiBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIHBhcmFtVmFsaWRhdGlvbiBpcyBzZXRcbiAqICAgICAgIHRvIGB0cnVlYC5cbiAqICAgICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gKiAgICAgICBjb25zdHJhaW50LlxuICogICAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gKiAgICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiAgICAgKiAqKmVudW0qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIG9uZVxuICogICAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBjb21wdXRlQ2hlY2tzdW1zXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gY29tcHV0ZSBjaGVja3N1bXMgZm9yIHBheWxvYWQgYm9kaWVzIHdoZW5cbiAqICAgICB0aGUgc2VydmljZSBhY2NlcHRzIGl0IChjdXJyZW50bHkgc3VwcG9ydGVkIGluIFMzIGFuZCBTUVMgb25seSkuXG4gKlxuICogQCFhdHRyaWJ1dGUgY29udmVydFJlc3BvbnNlVHlwZXNcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0eXBlcyBhcmUgY29udmVydGVkIHdoZW4gcGFyc2luZyByZXNwb25zZSBkYXRhLlxuICogICAgIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBmb3IgSlNPTiBiYXNlZCBzZXJ2aWNlcy4gVHVybmluZyB0aGlzIG9mZiBtYXlcbiAqICAgICBpbXByb3ZlIHBlcmZvcm1hbmNlIG9uIGxhcmdlIHJlc3BvbnNlIHBheWxvYWRzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgY29ycmVjdENsb2NrU2tld1xuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGFwcGx5IGEgY2xvY2sgc2tldyBjb3JyZWN0aW9uIGFuZCByZXRyeVxuICogICAgIHJlcXVlc3RzIHRoYXQgZmFpbCBiZWNhdXNlIG9mIGFuIHNrZXdlZCBjbGllbnQgY2xvY2suIERlZmF1bHRzIHRvXG4gKiAgICAgYGZhbHNlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzc2xFbmFibGVkXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgU1NMIGlzIGVuYWJsZWQgZm9yIHJlcXVlc3RzXG4gKlxuICogQCFhdHRyaWJ1dGUgczNGb3JjZVBhdGhTdHlsZVxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGZvcmNlIHBhdGggc3R5bGUgVVJMcyBmb3IgUzMgb2JqZWN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHMzQnVja2V0RW5kcG9pbnRcbiAqICAgQG5vdGUgU2V0dGluZyB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHJlcXVpcmVzIGFuIGBlbmRwb2ludGAgdG8gYmVcbiAqICAgICBwcm92aWRlZCBleHBsaWNpdGx5IHRvIHRoZSBzZXJ2aWNlIGNvbnN0cnVjdG9yLlxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbmRwb2ludCBhZGRyZXNzZXMgYW4gaW5kaXZpZHVhbFxuICogICAgIGJ1Y2tldCAoZmFsc2UgaWYgaXQgYWRkcmVzc2VzIHRoZSByb290IEFQSSBlbmRwb2ludCkuXG4gKlxuICogQCFhdHRyaWJ1dGUgczNEaXNhYmxlQm9keVNpZ25pbmdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBkaXNhYmxlIFMzIGJvZHkgc2lnbmluZyB3aGVuIHVzaW5nIHNpZ25hdHVyZSB2ZXJzaW9uIGB2NGAuXG4gKiAgICAgQm9keSBzaWduaW5nIGNhbiBvbmx5IGJlIGRpc2FibGVkIHdoZW4gdXNpbmcgaHR0cHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50XG4gKiAgIEByZXR1cm4gWydsZWdhY3knfCdyZWdpb25hbCddIHdoZW4gcmVnaW9uIGlzIHNldCB0byAndXMtZWFzdC0xJywgd2hldGhlciB0byBzZW5kIHMzXG4gKiAgICAgcmVxdWVzdCB0byBnbG9iYWwgZW5kcG9pbnRzIG9yICd1cy1lYXN0LTEnIHJlZ2lvbmFsIGVuZHBvaW50cy4gVGhpcyBjb25maWcgaXMgb25seVxuICogICAgIGFwcGxpY2FibGUgdG8gUzMgY2xpZW50O1xuICogICAgIERlZmF1bHRzIHRvICdsZWdhY3knXG4gKiBAIWF0dHJpYnV0ZSBzM1VzZUFyblJlZ2lvblxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIG92ZXJyaWRlIHRoZSByZXF1ZXN0IHJlZ2lvbiB3aXRoIHRoZSByZWdpb24gaW5mZXJyZWRcbiAqICAgICBmcm9tIHJlcXVlc3RlZCByZXNvdXJjZSdzIEFSTi4gT25seSBhdmFpbGFibGUgZm9yIFMzIGJ1Y2tldHNcbiAqICAgICBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAqXG4gKiBAIWF0dHJpYnV0ZSB1c2VBY2NlbGVyYXRlRW5kcG9pbnRcbiAqICAgQG5vdGUgVGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCBTMyB3aGlsZSBhY2Nlc3NpbmdcbiAqICAgICBkbnMtY29tcGF0aWJsZSBidWNrZXRzLlxuICogICBAcmV0dXJuIFtCb29sZWFuXSBXaGV0aGVyIHRvIHVzZSB0aGUgQWNjZWxlcmF0ZSBlbmRwb2ludCB3aXRoIHRoZSBTMyBzZXJ2aWNlLlxuICogICAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmV0cnlEZWxheU9wdGlvbnNcbiAqICAgQGV4YW1wbGUgU2V0IHRoZSBiYXNlIHJldHJ5IGRlbGF5IGZvciBhbGwgc2VydmljZXMgdG8gMzAwIG1zXG4gKiAgICAgQVdTLmNvbmZpZy51cGRhdGUoe3JldHJ5RGVsYXlPcHRpb25zOiB7YmFzZTogMzAwfX0pO1xuICogICAgIC8vIERlbGF5cyB3aXRoIG1heFJldHJpZXMgPSAzOiAzMDAsIDYwMCwgMTIwMFxuICogICBAZXhhbXBsZSBTZXQgYSBjdXN0b20gYmFja29mZiBmdW5jdGlvbiB0byBwcm92aWRlIGRlbGF5IHZhbHVlcyBvbiByZXRyaWVzXG4gKiAgICAgQVdTLmNvbmZpZy51cGRhdGUoe3JldHJ5RGVsYXlPcHRpb25zOiB7Y3VzdG9tQmFja29mZjogZnVuY3Rpb24ocmV0cnlDb3VudCwgZXJyKSB7XG4gKiAgICAgICAvLyByZXR1cm5zIGRlbGF5IGluIG1zXG4gKiAgICAgfX19KTtcbiAqICAgQHJldHVybiBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgcmV0cnkgZGVsYXkgb24gcmV0cnlhYmxlIGVycm9ycy5cbiAqICAgICBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqICAgICAqICoqYmFzZSoqIFtJbnRlZ2VyXSAmbWRhc2g7IFRoZSBiYXNlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdXNlIGluIHRoZVxuICogICAgICAgZXhwb25lbnRpYWwgYmFja29mZiBmb3Igb3BlcmF0aW9uIHJldHJpZXMuIERlZmF1bHRzIHRvIDEwMCBtcyBmb3IgYWxsIHNlcnZpY2VzIGV4Y2VwdFxuICogICAgICAgRHluYW1vREIsIHdoZXJlIGl0IGRlZmF1bHRzIHRvIDUwbXMuXG4gKlxuICogICAgICogKipjdXN0b21CYWNrb2ZmICoqIFtmdW5jdGlvbl0gJm1kYXNoOyBBIGN1c3RvbSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYVxuICogICAgICAgcmV0cnkgY291bnQgYW5kIGVycm9yIGFuZCByZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBpblxuICogICAgICAgbWlsbGlzZWNvbmRzLiBJZiB0aGUgcmVzdWx0IGlzIGEgbm9uLXplcm8gbmVnYXRpdmUgdmFsdWUsIG5vIGZ1cnRoZXJcbiAqICAgICAgIHJldHJ5IGF0dGVtcHRzIHdpbGwgYmUgbWFkZS4gVGhlIGBiYXNlYCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIGlmIHRoaXNcbiAqICAgICAgIG9wdGlvbiBpcyBzdXBwbGllZC4gVGhlIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGZvciByZXRyeWFibGUgZXJyb3JzLlxuICpcbiAqIEAhYXR0cmlidXRlIGh0dHBPcHRpb25zXG4gKiAgIEByZXR1cm4gW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBsb3ctbGV2ZWwgSFRUUCByZXF1ZXN0LlxuICogICAgIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogICAgICogKipwcm94eSoqIFtTdHJpbmddICZtZGFzaDsgdGhlIFVSTCB0byBwcm94eSByZXF1ZXN0cyB0aHJvdWdoXG4gKiAgICAgKiAqKmFnZW50KiogW2h0dHAuQWdlbnQsIGh0dHBzLkFnZW50XSAmbWRhc2g7IHRoZSBBZ2VudCBvYmplY3QgdG8gcGVyZm9ybVxuICogICAgICAgSFRUUCByZXF1ZXN0cyB3aXRoLiBVc2VkIGZvciBjb25uZWN0aW9uIHBvb2xpbmcuIE5vdGUgdGhhdCBmb3JcbiAqICAgICAgIFNTTCBjb25uZWN0aW9ucywgYSBzcGVjaWFsIEFnZW50IG9iamVjdCBpcyB1c2VkIGluIG9yZGVyIHRvIGVuYWJsZVxuICogICAgICAgcGVlciBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24uIFRoaXMgZmVhdHVyZSBpcyBvbmx5IHN1cHBvcnRlZCBpbiB0aGVcbiAqICAgICAgIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKiAgICAgKiAqKmNvbm5lY3RUaW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXJcbiAqICAgICAgIGZhaWxpbmcgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgYWZ0ZXJcbiAqICAgICAgIGBjb25uZWN0VGltZW91dGAgbWlsbGlzZWNvbmRzLiBUaGlzIHRpbWVvdXQgaGFzIG5vIGVmZmVjdCBvbmNlIGEgc29ja2V0XG4gKiAgICAgICBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICogICAgICogKip0aW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhblxuICogICAgICAgdGFrZSBiZWZvcmUgYXV0b21hdGljYWxseSBiZWluZyB0ZXJtaW5hdGVkLlxuICogICAgICAgRGVmYXVsdHMgdG8gdHdvIG1pbnV0ZXMgKDEyMDAwMCkuXG4gKiAgICAgKiAqKnhockFzeW5jKiogW0Jvb2xlYW5dICZtZGFzaDsgV2hldGhlciB0aGUgU0RLIHdpbGwgc2VuZCBhc3luY2hyb25vdXNcbiAqICAgICAgIEhUVFAgcmVxdWVzdHMuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb25seS4gU2V0IHRvIGZhbHNlIHRvXG4gKiAgICAgICBzZW5kIHJlcXVlc3RzIHN5bmNocm9ub3VzbHkuIERlZmF1bHRzIHRvIHRydWUgKGFzeW5jIG9uKS5cbiAqICAgICAqICoqeGhyV2l0aENyZWRlbnRpYWxzKiogW0Jvb2xlYW5dICZtZGFzaDsgU2V0cyB0aGUgXCJ3aXRoQ3JlZGVudGlhbHNcIlxuICogICAgICAgcHJvcGVydHkgb2YgYW4gWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50XG4gKiAgICAgICBvbmx5LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEAhYXR0cmlidXRlIGxvZ2dlclxuICogICBAcmV0dXJuIFsjd3JpdGUsI2xvZ10gYW4gb2JqZWN0IHRoYXQgcmVzcG9uZHMgdG8gLndyaXRlKCkgKGxpa2UgYSBzdHJlYW0pXG4gKiAgICAgb3IgLmxvZygpIChsaWtlIHRoZSBjb25zb2xlIG9iamVjdCkgaW4gb3JkZXIgdG8gbG9nIGluZm9ybWF0aW9uIGFib3V0XG4gKiAgICAgcmVxdWVzdHNcbiAqXG4gKiBAIWF0dHJpYnV0ZSBzeXN0ZW1DbG9ja09mZnNldFxuICogICBAcmV0dXJuIFtOdW1iZXJdIGFuIG9mZnNldCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMgdG8gYXBwbHkgdG8gYWxsIHNpZ25pbmdcbiAqICAgICB0aW1lcy4gVXNlIHRoaXMgdG8gY29tcGVuc2F0ZSBmb3IgY2xvY2sgc2tldyB3aGVuIHlvdXIgc3lzdGVtIG1heSBiZVxuICogICAgIG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZpY2UgdGltZS4gTm90ZSB0aGF0IHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb25cbiAqICAgICBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRoZSBnbG9iYWwgYEFXUy5jb25maWdgIG9iamVjdCBhbmQgY2Fubm90IGJlXG4gKiAgICAgb3ZlcnJpZGRlbiBpbiBzZXJ2aWNlLXNwZWNpZmljIGNvbmZpZ3VyYXRpb24uIERlZmF1bHRzIHRvIDAgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEAhYXR0cmlidXRlIHNpZ25hdHVyZVZlcnNpb25cbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgc2lnbmF0dXJlIHZlcnNpb24gdG8gc2lnbiByZXF1ZXN0cyB3aXRoIChvdmVycmlkaW5nXG4gKiAgICAgdGhlIEFQSSBjb25maWd1cmF0aW9uKS4gUG9zc2libGUgdmFsdWVzIGFyZTogJ3YyJywgJ3YzJywgJ3Y0Jy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzaWduYXR1cmVDYWNoZVxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBzaWduYXR1cmUgdG8gc2lnbiByZXF1ZXN0cyB3aXRoIChvdmVycmlkaW5nXG4gKiAgICAgdGhlIEFQSSBjb25maWd1cmF0aW9uKSBpcyBjYWNoZWQuIE9ubHkgYXBwbGllcyB0byB0aGUgc2lnbmF0dXJlIHZlcnNpb24gJ3Y0Jy5cbiAqICAgICBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW58dW5kZWZpbmVkXSB3aGV0aGVyIHRvIGNhbGwgb3BlcmF0aW9ucyB3aXRoIGVuZHBvaW50c1xuICogICAgIGdpdmVuIGJ5IHNlcnZpY2UgZHluYW1pY2FsbHkuIFNldHRpbmcgdGhpcyBjb25maWcgdG8gYHRydWVgIHdpbGwgZW5hYmxlXG4gKiAgICAgZW5kcG9pbnQgZGlzY292ZXJ5IGZvciBhbGwgYXBwbGljYWJsZSBvcGVyYXRpb25zLiBTZXR0aW5nIGl0IHRvIGBmYWxzZWBcbiAqICAgICB3aWxsIGV4cGxpY2l0bHkgZGlzYWJsZSBlbmRwb2ludCBkaXNjb3ZlcnkgZXZlbiB0aG91Z2ggb3BlcmF0aW9ucyB0aGF0XG4gKiAgICAgcmVxdWlyZSBlbmRwb2ludCBkaXNjb3Zlcnkgd2lsbCBwcmVzdW1hYmx5IGZhaWwuIExlYXZpbmcgaXQgdG9cbiAqICAgICBgdW5kZWZpbmVkYCBtZWFucyBTREsgb25seSBkbyBlbmRwb2ludCBkaXNjb3Zlcnkgd2hlbiBpdCdzIHJlcXVpcmVkLlxuICogICAgIERlZmF1bHRzIHRvIGB1bmRlZmluZWRgXG4gKlxuICogQCFhdHRyaWJ1dGUgZW5kcG9pbnRDYWNoZVNpemVcbiAqICAgQHJldHVybiBbTnVtYmVyXSB0aGUgc2l6ZSBvZiB0aGUgZ2xvYmFsIGNhY2hlIHN0b3JpbmcgZW5kcG9pbnRzIGZyb20gZW5kcG9pbnRcbiAqICAgICBkaXNjb3Zlcnkgb3BlcmF0aW9ucy4gT25jZSBlbmRwb2ludCBjYWNoZSBpcyBjcmVhdGVkLCB1cGRhdGluZyB0aGlzIHNldHRpbmdcbiAqICAgICBjYW5ub3QgY2hhbmdlIGV4aXN0aW5nIGNhY2hlIHNpemUuXG4gKiAgICAgRGVmYXVsdHMgdG8gMTAwMFxuICpcbiAqIEAhYXR0cmlidXRlIGhvc3RQcmVmaXhFbmFibGVkXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gbWFyc2hhbCByZXF1ZXN0IHBhcmFtZXRlcnMgdG8gdGhlIHByZWZpeCBvZlxuICogICAgIGhvc3RuYW1lLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3RzUmVnaW9uYWxFbmRwb2ludHNcbiAqICAgQHJldHVybiBbJ2xlZ2FjeSd8J3JlZ2lvbmFsJ10gd2hldGhlciB0byBzZW5kIHN0cyByZXF1ZXN0IHRvIGdsb2JhbCBlbmRwb2ludHMgb3JcbiAqICAgICByZWdpb25hbCBlbmRwb2ludHMuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2xlZ2FjeScuXG4gKlxuICogQCFhdHRyaWJ1dGUgdXNlRmlwc0VuZHBvaW50XG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIEVuYWJsZXMgRklQUyBjb21wYXRpYmxlIGVuZHBvaW50cy4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSB1c2VEdWFsc3RhY2tFbmRwb2ludFxuICogICBAcmV0dXJuIFtCb29sZWFuXSBFbmFibGVzIElQdjYgZHVhbHN0YWNrIGVuZHBvaW50LiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICovXG5BV1MuQ29uZmlnID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBAIWVuZGdyb3VwXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBUaGlzIGlzIHRoZSBvYmplY3QgdGhhdCBwYXNzZXNcbiAgICogb3B0aW9uIGRhdGEgYWxvbmcgdG8gc2VydmljZSByZXF1ZXN0cywgaW5jbHVkaW5nIGNyZWRlbnRpYWxzLCBzZWN1cml0eSxcbiAgICogcmVnaW9uIGluZm9ybWF0aW9uLCBhbmQgc29tZSBzZXJ2aWNlIHNwZWNpZmljIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIGNyZWRlbnRpYWxzIGFuZCByZWdpb25cbiAgICogICB2YXIgY29uZmlnID0gbmV3IEFXUy5Db25maWcoe1xuICAgKiAgICAgYWNjZXNzS2V5SWQ6ICdBS0lEJywgc2VjcmV0QWNjZXNzS2V5OiAnU0VDUkVUJywgcmVnaW9uOiAndXMtd2VzdC0yJ1xuICAgKiAgIH0pO1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgYWNjZXNzS2V5SWQgW1N0cmluZ10geW91ciBBV1MgYWNjZXNzIGtleSBJRC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNlY3JldEFjY2Vzc0tleSBbU3RyaW5nXSB5b3VyIEFXUyBzZWNyZXQgYWNjZXNzIGtleS5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNlc3Npb25Ub2tlbiBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgb3B0aW9uYWwgQVdTXG4gICAqICAgc2Vzc2lvbiB0b2tlbiB0byBzaWduIHJlcXVlc3RzIHdpdGguXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgdG8gc2lnbiByZXF1ZXN0cyB3aXRoLiBZb3UgY2FuIGVpdGhlciBzcGVjaWZ5IHRoaXMgb2JqZWN0LCBvclxuICAgKiAgIHNwZWNpZnkgdGhlIGFjY2Vzc0tleUlkIGFuZCBzZWNyZXRBY2Nlc3NLZXkgb3B0aW9ucyBkaXJlY3RseS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNyZWRlbnRpYWxQcm92aWRlciBbQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXSB0aGVcbiAgICogICBwcm92aWRlciBjaGFpbiB1c2VkIHRvIHJlc29sdmUgY3JlZGVudGlhbHMgaWYgbm8gc3RhdGljIGBjcmVkZW50aWFsc2BcbiAgICogICBwcm9wZXJ0eSBpcyBzZXQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZWdpb24gW1N0cmluZ10gdGhlIHJlZ2lvbiB0byBzZW5kIHNlcnZpY2UgcmVxdWVzdHMgdG8uXG4gICAqICAgU2VlIHtyZWdpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbWF4UmV0cmllcyBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJldHJpZXMgdG9cbiAgICogICBhdHRlbXB0IHdpdGggYSByZXF1ZXN0LiBTZWUge21heFJldHJpZXN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbWF4UmVkaXJlY3RzIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmVkaXJlY3RzIHRvXG4gICAqICAgZm9sbG93IHdpdGggYSByZXF1ZXN0LiBTZWUge21heFJlZGlyZWN0c30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzc2xFbmFibGVkIFtCb29sZWFuXSB3aGV0aGVyIHRvIGVuYWJsZSBTU0wgZm9yXG4gICAqICAgcmVxdWVzdHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbVZhbGlkYXRpb24gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnNcbiAgICogICBzaG91bGQgYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9wZXJhdGlvbiBkZXNjcmlwdGlvbiBiZWZvcmUgc2VuZGluZ1xuICAgKiAgIHRoZSByZXF1ZXN0LiBEZWZhdWx0cyB0byB0cnVlLiBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlXG4gICAqICAgZm9sbG93aW5nIHNwZWNpZmljIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gICAqXG4gICAqICAgKiAqKm1pbioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1pblxuICAgKiAgICAgY29uc3RyYWludC4gVGhpcyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBwYXJhbVZhbGlkYXRpb24gaXMgc2V0XG4gICAqICAgICB0byBgdHJ1ZWAuXG4gICAqICAgKiAqKm1heCoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1heFxuICAgKiAgICAgY29uc3RyYWludC5cbiAgICogICAqICoqcGF0dGVybioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYVxuICAgKiAgICAgcmVndWxhciBleHByZXNzaW9uLlxuICAgKiAgICogKiplbnVtKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBvbmVcbiAgICogICAgIG9mIHRoZSBhbGxvd2FibGUgZW51bSB2YWx1ZXMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb21wdXRlQ2hlY2tzdW1zIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbXB1dGUgY2hlY2tzdW1zXG4gICAqICAgZm9yIHBheWxvYWQgYm9kaWVzIHdoZW4gdGhlIHNlcnZpY2UgYWNjZXB0cyBpdCAoY3VycmVudGx5IHN1cHBvcnRlZFxuICAgKiAgIGluIFMzIG9ubHkpXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb252ZXJ0UmVzcG9uc2VUeXBlcyBbQm9vbGVhbl0gd2hldGhlciB0eXBlcyBhcmUgY29udmVydGVkXG4gICAqICAgICB3aGVuIHBhcnNpbmcgcmVzcG9uc2UgZGF0YS4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGZvciBKU09OIGJhc2VkXG4gICAqICAgICBzZXJ2aWNlcy4gVHVybmluZyB0aGlzIG9mZiBtYXkgaW1wcm92ZSBwZXJmb3JtYW5jZSBvbiBsYXJnZSByZXNwb25zZVxuICAgKiAgICAgcGF5bG9hZHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvcnJlY3RDbG9ja1NrZXcgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gYXBwbHkgYSBjbG9jayBza2V3XG4gICAqICAgICBjb3JyZWN0aW9uIGFuZCByZXRyeSByZXF1ZXN0cyB0aGF0IGZhaWwgYmVjYXVzZSBvZiBhbiBza2V3ZWQgY2xpZW50XG4gICAqICAgICBjbG9jay4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzRm9yY2VQYXRoU3R5bGUgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZm9yY2UgcGF0aFxuICAgKiAgIHN0eWxlIFVSTHMgZm9yIFMzIG9iamVjdHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM0J1Y2tldEVuZHBvaW50IFtCb29sZWFuXSB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbmRwb2ludFxuICAgKiAgIGFkZHJlc3NlcyBhbiBpbmRpdmlkdWFsIGJ1Y2tldCAoZmFsc2UgaWYgaXQgYWRkcmVzc2VzIHRoZSByb290IEFQSVxuICAgKiAgIGVuZHBvaW50KS4gTm90ZSB0aGF0IHNldHRpbmcgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiByZXF1aXJlcyBhblxuICAgKiAgIGBlbmRwb2ludGAgdG8gYmUgcHJvdmlkZWQgZXhwbGljaXRseSB0byB0aGUgc2VydmljZSBjb25zdHJ1Y3Rvci5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzRGlzYWJsZUJvZHlTaWduaW5nIFtCb29sZWFuXSB3aGV0aGVyIFMzIGJvZHkgc2lnbmluZ1xuICAgKiAgIHNob3VsZCBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIHNpZ25hdHVyZSB2ZXJzaW9uIGB2NGAuIEJvZHkgc2lnbmluZ1xuICAgKiAgIGNhbiBvbmx5IGJlIGRpc2FibGVkIHdoZW4gdXNpbmcgaHR0cHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQgWydsZWdhY3knfCdyZWdpb25hbCddIHdoZW4gcmVnaW9uXG4gICAqICAgaXMgc2V0IHRvICd1cy1lYXN0LTEnLCB3aGV0aGVyIHRvIHNlbmQgczMgcmVxdWVzdCB0byBnbG9iYWwgZW5kcG9pbnRzIG9yXG4gICAqICAgJ3VzLWVhc3QtMScgcmVnaW9uYWwgZW5kcG9pbnRzLiBUaGlzIGNvbmZpZyBpcyBvbmx5IGFwcGxpY2FibGUgdG8gUzMgY2xpZW50LlxuICAgKiAgIERlZmF1bHRzIHRvIGBsZWdhY3lgXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM1VzZUFyblJlZ2lvbiBbQm9vbGVhbl0gd2hldGhlciB0byBvdmVycmlkZSB0aGUgcmVxdWVzdCByZWdpb25cbiAgICogICB3aXRoIHRoZSByZWdpb24gaW5mZXJyZWQgZnJvbSByZXF1ZXN0ZWQgcmVzb3VyY2UncyBBUk4uIE9ubHkgYXZhaWxhYmxlIGZvciBTMyBidWNrZXRzXG4gICAqICAgRGVmYXVsdHMgdG8gYHRydWVgXG4gICAqXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZXRyeURlbGF5T3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZVxuICAgKiAgIHRoZSByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAgICogKipiYXNlKiogW0ludGVnZXJdICZtZGFzaDsgVGhlIGJhc2UgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW4gdGhlXG4gICAqICAgICBleHBvbmVudGlhbCBiYWNrb2ZmIGZvciBvcGVyYXRpb24gcmV0cmllcy4gRGVmYXVsdHMgdG8gMTAwIG1zIGZvciBhbGxcbiAgICogICAgIHNlcnZpY2VzIGV4Y2VwdCBEeW5hbW9EQiwgd2hlcmUgaXQgZGVmYXVsdHMgdG8gNTBtcy5cbiAgICogICAqICoqY3VzdG9tQmFja29mZiAqKiBbZnVuY3Rpb25dICZtZGFzaDsgQSBjdXN0b20gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFcbiAgICogICAgIHJldHJ5IGNvdW50IGFuZCBlcnJvciBhbmQgcmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgaW5cbiAgICogICAgIG1pbGxpc2Vjb25kcy4gSWYgdGhlIHJlc3VsdCBpcyBhIG5vbi16ZXJvIG5lZ2F0aXZlIHZhbHVlLCBubyBmdXJ0aGVyXG4gICAqICAgICByZXRyeSBhdHRlbXB0cyB3aWxsIGJlIG1hZGUuIFRoZSBgYmFzZWAgb3B0aW9uIHdpbGwgYmUgaWdub3JlZCBpZiB0aGlzXG4gICAqICAgICBvcHRpb24gaXMgc3VwcGxpZWQuIFRoZSBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgcmV0cnlhYmxlIGVycm9ycy5cbiAgICogQG9wdGlvbiBvcHRpb25zIGh0dHBPcHRpb25zIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbG93LWxldmVsXG4gICAqICAgSFRUUCByZXF1ZXN0LiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAgICogKipwcm94eSoqIFtTdHJpbmddICZtZGFzaDsgdGhlIFVSTCB0byBwcm94eSByZXF1ZXN0cyB0aHJvdWdoXG4gICAqICAgKiAqKmFnZW50KiogW2h0dHAuQWdlbnQsIGh0dHBzLkFnZW50XSAmbWRhc2g7IHRoZSBBZ2VudCBvYmplY3QgdG8gcGVyZm9ybVxuICAgKiAgICAgSFRUUCByZXF1ZXN0cyB3aXRoLiBVc2VkIGZvciBjb25uZWN0aW9uIHBvb2xpbmcuIERlZmF1bHRzIHRvIHRoZSBnbG9iYWxcbiAgICogICAgIGFnZW50IChgaHR0cC5nbG9iYWxBZ2VudGApIGZvciBub24tU1NMIGNvbm5lY3Rpb25zLiBOb3RlIHRoYXQgZm9yXG4gICAqICAgICBTU0wgY29ubmVjdGlvbnMsIGEgc3BlY2lhbCBBZ2VudCBvYmplY3QgaXMgdXNlZCBpbiBvcmRlciB0byBlbmFibGVcbiAgICogICAgIHBlZXIgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uLiBUaGlzIGZlYXR1cmUgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlXG4gICAqICAgICBOb2RlLmpzIGVudmlyb25tZW50LlxuICAgKiAgICogKipjb25uZWN0VGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyXG4gICAqICAgICBmYWlsaW5nIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyIGFmdGVyXG4gICAqICAgICBgY29ubmVjdFRpbWVvdXRgIG1pbGxpc2Vjb25kcy4gVGhpcyB0aW1lb3V0IGhhcyBubyBlZmZlY3Qgb25jZSBhIHNvY2tldFxuICAgKiAgICAgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAgICogICAqICoqdGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXRcbiAgICogICAgIG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuIERlZmF1bHRzIHRvIHR3byBtaW51dGVzXG4gICAqICAgICAoMTIwMDAwKS5cbiAgICogICAqICoqeGhyQXN5bmMqKiBbQm9vbGVhbl0gJm1kYXNoOyBXaGV0aGVyIHRoZSBTREsgd2lsbCBzZW5kIGFzeW5jaHJvbm91c1xuICAgKiAgICAgSFRUUCByZXF1ZXN0cy4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvbmx5LiBTZXQgdG8gZmFsc2UgdG9cbiAgICogICAgIHNlbmQgcmVxdWVzdHMgc3luY2hyb25vdXNseS4gRGVmYXVsdHMgdG8gdHJ1ZSAoYXN5bmMgb24pLlxuICAgKiAgICogKip4aHJXaXRoQ3JlZGVudGlhbHMqKiBbQm9vbGVhbl0gJm1kYXNoOyBTZXRzIHRoZSBcIndpdGhDcmVkZW50aWFsc1wiXG4gICAqICAgICBwcm9wZXJ0eSBvZiBhbiBYTUxIdHRwUmVxdWVzdCBvYmplY3QuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICogICAgIG9ubHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgYXBpVmVyc2lvbiBbU3RyaW5nLCBEYXRlXSBhIFN0cmluZyBpbiBZWVlZLU1NLUREIGZvcm1hdFxuICAgKiAgIChvciBhIGRhdGUpIHRoYXQgcmVwcmVzZW50cyB0aGUgbGF0ZXN0IHBvc3NpYmxlIEFQSSB2ZXJzaW9uIHRoYXQgY2FuIGJlXG4gICAqICAgdXNlZCBpbiBhbGwgc2VydmljZXMgKHVubGVzcyBvdmVycmlkZGVuIGJ5IGBhcGlWZXJzaW9uc2ApLiBTcGVjaWZ5XG4gICAqICAgJ2xhdGVzdCcgdG8gdXNlIHRoZSBsYXRlc3QgcG9zc2libGUgdmVyc2lvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIGFwaVZlcnNpb25zIFttYXA8U3RyaW5nLCBTdHJpbmd8RGF0ZT5dIGEgbWFwIG9mIHNlcnZpY2VcbiAgICogICBpZGVudGlmaWVycyAodGhlIGxvd2VyY2FzZSBzZXJ2aWNlIGNsYXNzIG5hbWUpIHdpdGggdGhlIEFQSSB2ZXJzaW9uIHRvXG4gICAqICAgdXNlIHdoZW4gaW5zdGFudGlhdGluZyBhIHNlcnZpY2UuIFNwZWNpZnkgJ2xhdGVzdCcgZm9yIGVhY2ggaW5kaXZpZHVhbFxuICAgKiAgIHRoYXQgY2FuIHVzZSB0aGUgbGF0ZXN0IGF2YWlsYWJsZSB2ZXJzaW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbG9nZ2VyIFsjd3JpdGUsI2xvZ10gYW4gb2JqZWN0IHRoYXQgcmVzcG9uZHMgdG8gLndyaXRlKClcbiAgICogICAobGlrZSBhIHN0cmVhbSkgb3IgLmxvZygpIChsaWtlIHRoZSBjb25zb2xlIG9iamVjdCkgaW4gb3JkZXIgdG8gbG9nXG4gICAqICAgaW5mb3JtYXRpb24gYWJvdXQgcmVxdWVzdHNcbiAgICogQG9wdGlvbiBvcHRpb25zIHN5c3RlbUNsb2NrT2Zmc2V0IFtOdW1iZXJdIGFuIG9mZnNldCB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICogICB0byBhcHBseSB0byBhbGwgc2lnbmluZyB0aW1lcy4gVXNlIHRoaXMgdG8gY29tcGVuc2F0ZSBmb3IgY2xvY2sgc2tld1xuICAgKiAgIHdoZW4geW91ciBzeXN0ZW0gbWF5IGJlIG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZpY2UgdGltZS4gTm90ZSB0aGF0XG4gICAqICAgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRoZSBnbG9iYWwgYEFXUy5jb25maWdgXG4gICAqICAgb2JqZWN0IGFuZCBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBpbiBzZXJ2aWNlLXNwZWNpZmljIGNvbmZpZ3VyYXRpb24uXG4gICAqICAgRGVmYXVsdHMgdG8gMCBtaWxsaXNlY29uZHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzaWduYXR1cmVWZXJzaW9uIFtTdHJpbmddIHRoZSBzaWduYXR1cmUgdmVyc2lvbiB0byBzaWduXG4gICAqICAgcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZyB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgKiAgICd2MicsICd2MycsICd2NCcuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzaWduYXR1cmVDYWNoZSBbQm9vbGVhbl0gd2hldGhlciB0aGUgc2lnbmF0dXJlIHRvIHNpZ25cbiAgICogICByZXF1ZXN0cyB3aXRoIChvdmVycmlkaW5nIHRoZSBBUEkgY29uZmlndXJhdGlvbikgaXMgY2FjaGVkLiBPbmx5IGFwcGxpZXNcbiAgICogICB0byB0aGUgc2lnbmF0dXJlIHZlcnNpb24gJ3Y0Jy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZHluYW1vRGJDcmMzMiBbQm9vbGVhbl0gd2hldGhlciB0byB2YWxpZGF0ZSB0aGUgQ1JDMzJcbiAgICogICBjaGVja3N1bSBvZiBIVFRQIHJlc3BvbnNlIGJvZGllcyByZXR1cm5lZCBieSBEeW5hbW9EQi4gRGVmYXVsdDogYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgdXNlQWNjZWxlcmF0ZUVuZHBvaW50IFtCb29sZWFuXSBXaGV0aGVyIHRvIHVzZSB0aGVcbiAgICogICBTMyBUcmFuc2ZlciBBY2NlbGVyYXRpb24gZW5kcG9pbnQgd2l0aCB0aGUgUzMgc2VydmljZS4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNsaWVudFNpZGVNb25pdG9yaW5nIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbGxlY3QgYW5kXG4gICAqICAgcHVibGlzaCB0aGlzIGNsaWVudCdzIHBlcmZvcm1hbmNlIG1ldHJpY3Mgb2YgYWxsIGl0cyBBUEkgcmVxdWVzdHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgW0Jvb2xlYW58dW5kZWZpbmVkXSB3aGV0aGVyIHRvXG4gICAqICAgY2FsbCBvcGVyYXRpb25zIHdpdGggZW5kcG9pbnRzIGdpdmVuIGJ5IHNlcnZpY2UgZHluYW1pY2FsbHkuIFNldHRpbmcgdGhpc1xuICAgKiBjb25maWcgdG8gYHRydWVgIHdpbGwgZW5hYmxlIGVuZHBvaW50IGRpc2NvdmVyeSBmb3IgYWxsIGFwcGxpY2FibGUgb3BlcmF0aW9ucy5cbiAgICogICBTZXR0aW5nIGl0IHRvIGBmYWxzZWAgd2lsbCBleHBsaWNpdGx5IGRpc2FibGUgZW5kcG9pbnQgZGlzY292ZXJ5IGV2ZW4gdGhvdWdoXG4gICAqICAgb3BlcmF0aW9ucyB0aGF0IHJlcXVpcmUgZW5kcG9pbnQgZGlzY292ZXJ5IHdpbGwgcHJlc3VtYWJseSBmYWlsLiBMZWF2aW5nIGl0XG4gICAqICAgdG8gYHVuZGVmaW5lZGAgbWVhbnMgU0RLIHdpbGwgb25seSBkbyBlbmRwb2ludCBkaXNjb3Zlcnkgd2hlbiBpdCdzIHJlcXVpcmVkLlxuICAgKiAgIERlZmF1bHRzIHRvIGB1bmRlZmluZWRgXG4gICAqIEBvcHRpb24gb3B0aW9ucyBlbmRwb2ludENhY2hlU2l6ZSBbTnVtYmVyXSB0aGUgc2l6ZSBvZiB0aGUgZ2xvYmFsIGNhY2hlIHN0b3JpbmdcbiAgICogICBlbmRwb2ludHMgZnJvbSBlbmRwb2ludCBkaXNjb3Zlcnkgb3BlcmF0aW9ucy4gT25jZSBlbmRwb2ludCBjYWNoZSBpcyBjcmVhdGVkLFxuICAgKiAgIHVwZGF0aW5nIHRoaXMgc2V0dGluZyBjYW5ub3QgY2hhbmdlIGV4aXN0aW5nIGNhY2hlIHNpemUuXG4gICAqICAgRGVmYXVsdHMgdG8gMTAwMFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaG9zdFByZWZpeEVuYWJsZWQgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gbWFyc2hhbCByZXF1ZXN0XG4gICAqICAgcGFyYW1ldGVycyB0byB0aGUgcHJlZml4IG9mIGhvc3RuYW1lLlxuICAgKiAgIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHN0c1JlZ2lvbmFsRW5kcG9pbnRzIFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGV0aGVyIHRvIHNlbmQgc3RzIHJlcXVlc3RcbiAgICogICB0byBnbG9iYWwgZW5kcG9pbnRzIG9yIHJlZ2lvbmFsIGVuZHBvaW50cy5cbiAgICogICBEZWZhdWx0cyB0byAnbGVnYWN5Jy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHVzZUZpcHNFbmRwb2ludCBbQm9vbGVhbl0gRW5hYmxlcyBGSVBTIGNvbXBhdGlibGUgZW5kcG9pbnRzLlxuICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB1c2VEdWFsc3RhY2tFbmRwb2ludCBbQm9vbGVhbl0gRW5hYmxlcyBJUHY2IGR1YWxzdGFjayBlbmRwb2ludC5cbiAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENvbmZpZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSB0aGlzLmV4dHJhY3RDcmVkZW50aWFscyhvcHRpb25zKTtcblxuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLmtleXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLnNldChrZXksIG9wdGlvbnNba2V5XSwgdmFsdWUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIWdyb3VwIE1hbmFnaW5nIENyZWRlbnRpYWxzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMb2FkcyBjcmVkZW50aWFscyBmcm9tIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHlcbiAgICogYnkgdGhlIFNESyB0byBlbnN1cmUgdGhhdCByZWZyZXNoYWJsZSB7Q3JlZGVudGlhbHN9IG9iamVjdHMgYXJlIHByb3Blcmx5XG4gICAqIHJlZnJlc2hlZCBhbmQgbG9hZGVkIHdoZW4gc2VuZGluZyBhIHJlcXVlc3QuIElmIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0XG4gICAqIHlvdXIgY3JlZGVudGlhbHMgYXJlIGxvYWRlZCBwcmlvciB0byBhIHJlcXVlc3QsIHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kXG4gICAqIGRpcmVjdGx5IHRvIHByb3ZpZGUgYWNjdXJhdGUgY3JlZGVudGlhbCBkYXRhIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBJZiB5b3UgY29uZmlndXJlIHRoZSBTREsgd2l0aCBzdGF0aWMgb3IgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMsXG4gICAqICAgdGhlIGNyZWRlbnRpYWwgZGF0YSBzaG91bGQgYWxyZWFkeSBiZSBwcmVzZW50IGluIHtjcmVkZW50aWFsc30gYXR0cmlidXRlLlxuICAgKiAgIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSBuZWNlc3NhcnkgdG8gbG9hZCBjcmVkZW50aWFscyBmcm9tIGFzeW5jaHJvbm91c1xuICAgKiAgIHNvdXJjZXMsIG9yIHNvdXJjZXMgdGhhdCBjYW4gcmVmcmVzaCBjcmVkZW50aWFscyBwZXJpb2RpY2FsbHkuXG4gICAqIEBleGFtcGxlIEdldHRpbmcgeW91ciBhY2Nlc3Mga2V5XG4gICAqICAgQVdTLmNvbmZpZy5nZXRDcmVkZW50aWFscyhmdW5jdGlvbihlcnIpIHtcbiAgICogICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVyci5zdGFjayk7IC8vIGNyZWRlbnRpYWxzIG5vdCBsb2FkZWRcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coXCJBY2Nlc3MgS2V5OlwiLCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkKTtcbiAgICogICB9KVxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSB7Y3JlZGVudGlhbHN9IGhhdmUgYmVlbiBwcm9wZXJseSBzZXQgb24gdGhlIGNvbmZpZ3VyYXRpb25cbiAgICogICBvYmplY3QuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIHRoaXMgaXMgc2V0LCBjcmVkZW50aWFscyB3ZXJlIG5vdCBzdWNjZXNzZnVsbHlcbiAgICogICAgIGxvYWRlZCBhbmQgdGhpcyBlcnJvciBwcm92aWRlcyBpbmZvcm1hdGlvbiB3aHkuXG4gICAqIEBzZWUgY3JlZGVudGlhbHNcbiAgICogQHNlZSBDcmVkZW50aWFsc1xuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHM6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCBlcnIgPyBudWxsIDogc2VsZi5jcmVkZW50aWFscyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlZEVycm9yKG1zZywgZXJyKSB7XG4gICAgICByZXR1cm4gbmV3IEFXUy51dGlsLmVycm9yKGVyciB8fCBuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnQ3JlZGVudGlhbHNFcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgbmFtZTogJ0NyZWRlbnRpYWxzRXJyb3InXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3luY0NyZWRlbnRpYWxzKCkge1xuICAgICAgc2VsZi5jcmVkZW50aWFscy5nZXQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgbXNnID0gJ0NvdWxkIG5vdCBsb2FkIGNyZWRlbnRpYWxzIGZyb20gJyArXG4gICAgICAgICAgICBzZWxmLmNyZWRlbnRpYWxzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgZXJyID0gY3JlZEVycm9yKG1zZywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY0NyZWRlbnRpYWxzKCkge1xuICAgICAgdmFyIGVyciA9IG51bGw7XG4gICAgICBpZiAoIXNlbGYuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgfHwgIXNlbGYuY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICAgIGVyciA9IGNyZWRFcnJvcignTWlzc2luZyBjcmVkZW50aWFscycpO1xuICAgICAgfVxuICAgICAgZmluaXNoKGVycik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuY3JlZGVudGlhbHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5jcmVkZW50aWFscy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZ2V0QXN5bmNDcmVkZW50aWFscygpO1xuICAgICAgfSBlbHNlIHsgLy8gc3RhdGljIGNyZWRlbnRpYWxzXG4gICAgICAgIGdldFN0YXRpY0NyZWRlbnRpYWxzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWxmLmNyZWRlbnRpYWxQcm92aWRlcikge1xuICAgICAgc2VsZi5jcmVkZW50aWFsUHJvdmlkZXIucmVzb2x2ZShmdW5jdGlvbihlcnIsIGNyZWRzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBlcnIgPSBjcmVkRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGNyZWRlbnRpYWxzIGZyb20gYW55IHByb3ZpZGVycycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jcmVkZW50aWFscyA9IGNyZWRzO1xuICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2goY3JlZEVycm9yKCdObyBjcmVkZW50aWFscyB0byBsb2FkJykpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBMb2FkaW5nIGFuZCBTZXR0aW5nIENvbmZpZ3VyYXRpb24gT3B0aW9uc1xuICAgKi9cblxuICAvKipcbiAgICogQG92ZXJsb2FkIHVwZGF0ZShvcHRpb25zLCBhbGxvd1Vua25vd25LZXlzID0gZmFsc2UpXG4gICAqICAgVXBkYXRlcyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIG5ldyBvcHRpb25zLlxuICAgKlxuICAgKiAgIEBleGFtcGxlIFVwZGF0ZSBtYXhSZXRyaWVzIHByb3BlcnR5IG9mIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogICAgIGNvbmZpZy51cGRhdGUoe21heFJldHJpZXM6IDEwfSk7XG4gICAqICAgQHBhcmFtIFtPYmplY3RdIG9wdGlvbnMgYSBtYXAgb2Ygb3B0aW9uIGtleXMgYW5kIHZhbHVlcy5cbiAgICogICBAcGFyYW0gW0Jvb2xlYW5dIGFsbG93VW5rbm93bktleXMgd2hldGhlciB1bmtub3duIGtleXMgY2FuIGJlIHNldCBvblxuICAgKiAgICAgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiAgIEBzZWUgY29uc3RydWN0b3JcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9wdGlvbnMsIGFsbG93VW5rbm93bktleXMpIHtcbiAgICBhbGxvd1Vua25vd25LZXlzID0gYWxsb3dVbmtub3duS2V5cyB8fCBmYWxzZTtcbiAgICBvcHRpb25zID0gdGhpcy5leHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucyk7XG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoYWxsb3dVbmtub3duS2V5cyB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5rZXlzLCBrZXkpIHx8XG4gICAgICAgICAgQVdTLlNlcnZpY2UuaGFzU2VydmljZShrZXkpKSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyBjb25maWd1cmF0aW9uIGRhdGEgZnJvbSBhIEpTT04gZmlsZSBpbnRvIHRoaXMgY29uZmlnIG9iamVjdC5cbiAgICogQG5vdGUgTG9hZGluZyBjb25maWd1cmF0aW9uIHdpbGwgcmVzZXQgYWxsIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICogICBvbiB0aGUgb2JqZWN0LlxuICAgKiBAIW1hY3JvIG5vYnJvd3NlclxuICAgKiBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgcGF0aCByZWxhdGl2ZSB0byB5b3VyIHByb2Nlc3MncyBjdXJyZW50XG4gICAqICAgIHdvcmtpbmcgZGlyZWN0b3J5IHRvIGxvYWQgY29uZmlndXJhdGlvbiBmcm9tLlxuICAgKiBAcmV0dXJuIFtBV1MuQ29uZmlnXSB0aGUgc2FtZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgbG9hZEZyb21QYXRoOiBmdW5jdGlvbiBsb2FkRnJvbVBhdGgocGF0aCkge1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHZhciBvcHRpb25zID0gSlNPTi5wYXJzZShBV1MudXRpbC5yZWFkRmlsZVN5bmMocGF0aCkpO1xuICAgIHZhciBmaWxlU3lzdGVtQ3JlZHMgPSBuZXcgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscyhwYXRoKTtcbiAgICB2YXIgY2hhaW4gPSBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKCk7XG4gICAgY2hhaW4ucHJvdmlkZXJzLnVuc2hpZnQoZmlsZVN5c3RlbUNyZWRzKTtcbiAgICBjaGFpbi5yZXNvbHZlKGZ1bmN0aW9uIChlcnIsIGNyZWRzKSB7XG4gICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICBlbHNlIG9wdGlvbnMuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAgICB9KTtcblxuICAgIHRoaXMuY29uc3RydWN0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXJzIGNvbmZpZ3VyYXRpb24gZGF0YSBvbiB0aGlzIG9iamVjdFxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLmtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyByZXNldCBjcmVkZW50aWFsIHByb3ZpZGVyXG4gICAgdGhpcy5zZXQoJ2NyZWRlbnRpYWxzJywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLnNldCgnY3JlZGVudGlhbFByb3ZpZGVyJywgdW5kZWZpbmVkKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHByb3BlcnR5IG9uIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCwgYWxsb3dpbmcgZm9yIGFcbiAgICogZGVmYXVsdCB2YWx1ZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldDogZnVuY3Rpb24gc2V0KHByb3BlcnR5LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLmtleXNbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICdodHRwT3B0aW9ucycgJiYgdGhpc1twcm9wZXJ0eV0pIHtcbiAgICAgIC8vIGRlZXAgbWVyZ2UgaHR0cE9wdGlvbnNcbiAgICAgIHRoaXNbcHJvcGVydHldID0gQVdTLnV0aWwubWVyZ2UodGhpc1twcm9wZXJ0eV0sIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUga2V5cyB3aXRoIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICAgKlxuICAgKiBAY29uc3RhbnRcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBrZXlzOiB7XG4gICAgY3JlZGVudGlhbHM6IG51bGwsXG4gICAgY3JlZGVudGlhbFByb3ZpZGVyOiBudWxsLFxuICAgIHJlZ2lvbjogbnVsbCxcbiAgICBsb2dnZXI6IG51bGwsXG4gICAgYXBpVmVyc2lvbnM6IHt9LFxuICAgIGFwaVZlcnNpb246IG51bGwsXG4gICAgZW5kcG9pbnQ6IHVuZGVmaW5lZCxcbiAgICBodHRwT3B0aW9uczoge1xuICAgICAgdGltZW91dDogMTIwMDAwXG4gICAgfSxcbiAgICBtYXhSZXRyaWVzOiB1bmRlZmluZWQsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICBwYXJhbVZhbGlkYXRpb246IHRydWUsXG4gICAgc3NsRW5hYmxlZDogdHJ1ZSxcbiAgICBzM0ZvcmNlUGF0aFN0eWxlOiBmYWxzZSxcbiAgICBzM0J1Y2tldEVuZHBvaW50OiBmYWxzZSxcbiAgICBzM0Rpc2FibGVCb2R5U2lnbmluZzogdHJ1ZSxcbiAgICBzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50OiAnbGVnYWN5JyxcbiAgICBzM1VzZUFyblJlZ2lvbjogdW5kZWZpbmVkLFxuICAgIGNvbXB1dGVDaGVja3N1bXM6IHRydWUsXG4gICAgY29udmVydFJlc3BvbnNlVHlwZXM6IHRydWUsXG4gICAgY29ycmVjdENsb2NrU2tldzogZmFsc2UsXG4gICAgY3VzdG9tVXNlckFnZW50OiBudWxsLFxuICAgIGR5bmFtb0RiQ3JjMzI6IHRydWUsXG4gICAgc3lzdGVtQ2xvY2tPZmZzZXQ6IDAsXG4gICAgc2lnbmF0dXJlVmVyc2lvbjogbnVsbCxcbiAgICBzaWduYXR1cmVDYWNoZTogdHJ1ZSxcbiAgICByZXRyeURlbGF5T3B0aW9uczoge30sXG4gICAgdXNlQWNjZWxlcmF0ZUVuZHBvaW50OiBmYWxzZSxcbiAgICBjbGllbnRTaWRlTW9uaXRvcmluZzogZmFsc2UsXG4gICAgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkOiB1bmRlZmluZWQsXG4gICAgZW5kcG9pbnRDYWNoZVNpemU6IDEwMDAsXG4gICAgaG9zdFByZWZpeEVuYWJsZWQ6IHRydWUsXG4gICAgc3RzUmVnaW9uYWxFbmRwb2ludHM6ICdsZWdhY3knLFxuICAgIHVzZUZpcHNFbmRwb2ludDogZmFsc2UsXG4gICAgdXNlRHVhbHN0YWNrRW5kcG9pbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFjY2Vzc0tleUlkLCBzZWNyZXRBY2Nlc3NLZXkgYW5kIHNlc3Npb25Ub2tlblxuICAgKiBmcm9tIGEgY29uZmlndXJhdGlvbiBoYXNoLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RDcmVkZW50aWFsczogZnVuY3Rpb24gZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hY2Nlc3NLZXlJZCAmJiBvcHRpb25zLnNlY3JldEFjY2Vzc0tleSkge1xuICAgICAgb3B0aW9ucyA9IEFXUy51dGlsLmNvcHkob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DcmVkZW50aWFscyhvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb21pc2UgZGVwZW5kZW5jeSB0aGUgU0RLIHdpbGwgdXNlIHdoZXJldmVyIFByb21pc2VzIGFyZSByZXR1cm5lZC5cbiAgICogUGFzc2luZyBgbnVsbGAgd2lsbCBmb3JjZSB0aGUgU0RLIHRvIHVzZSBuYXRpdmUgUHJvbWlzZXMgaWYgdGhleSBhcmUgYXZhaWxhYmxlLlxuICAgKiBJZiBuYXRpdmUgUHJvbWlzZXMgYXJlIG5vdCBhdmFpbGFibGUsIHBhc3NpbmcgYG51bGxgIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqIEBwYXJhbSBbQ29uc3RydWN0b3JdIGRlcCBBIHJlZmVyZW5jZSB0byBhIFByb21pc2UgY29uc3RydWN0b3JcbiAgICovXG4gIHNldFByb21pc2VzRGVwZW5kZW5jeTogZnVuY3Rpb24gc2V0UHJvbWlzZXNEZXBlbmRlbmN5KGRlcCkge1xuICAgIFByb21pc2VzRGVwZW5kZW5jeSA9IGRlcDtcbiAgICAvLyBpZiBudWxsIHdhcyBwYXNzZWQgaW4sIHdlIHNob3VsZCB0cnkgdG8gdXNlIG5hdGl2ZSBwcm9taXNlc1xuICAgIGlmIChkZXAgPT09IG51bGwgJiYgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFByb21pc2VzRGVwZW5kZW5jeSA9IFByb21pc2U7XG4gICAgfVxuICAgIHZhciBjb25zdHJ1Y3RvcnMgPSBbQVdTLlJlcXVlc3QsIEFXUy5DcmVkZW50aWFscywgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXTtcbiAgICBpZiAoQVdTLlMzKSB7XG4gICAgICBjb25zdHJ1Y3RvcnMucHVzaChBV1MuUzMpO1xuICAgICAgaWYgKEFXUy5TMy5NYW5hZ2VkVXBsb2FkKSB7XG4gICAgICAgIGNvbnN0cnVjdG9ycy5wdXNoKEFXUy5TMy5NYW5hZ2VkVXBsb2FkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQVdTLnV0aWwuYWRkUHJvbWlzZXMoY29uc3RydWN0b3JzLCBQcm9taXNlc0RlcGVuZGVuY3kpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgc2V0IGJ5IGBBV1MuY29uZmlnLnNldFByb21pc2VzRGVwZW5kZW5jeWAuXG4gICAqL1xuICBnZXRQcm9taXNlc0RlcGVuZGVuY3k6IGZ1bmN0aW9uIGdldFByb21pc2VzRGVwZW5kZW5jeSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZXNEZXBlbmRlbmN5O1xuICB9XG59KTtcblxuLyoqXG4gKiBAcmV0dXJuIFtBV1MuQ29uZmlnXSBUaGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHNpbmdsZXRvbiBpbnN0YW5jZVxuICogQHJlYWRvbmx5XG4gKiBAc2VlIEFXUy5Db25maWdcbiAqL1xuQVdTLmNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKCk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKGNvbmZpZ1ZhbHVlLCBlcnJvck9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25maWdWYWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGVsc2UgaWYgKFsnbGVnYWN5JywgJ3JlZ2lvbmFsJ10uaW5kZXhPZihjb25maWdWYWx1ZS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1ZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIGVycm9yT3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBjb25maWd1cmF0aW9uIHZhbHVlIGZvciByZWdpb25hbCBlbmRwb2ludCBmcm9tIGRpZmZlcmVuY2Ugc291cmNlczogY2xpZW50XG4gKiBjb25maWcsIGVudmlyb25tZW50YWwgdmFyaWFibGUsIHNoYXJlZCBjb25maWcgZmlsZS4gVmFsdWUgY2FuIGJlIGNhc2UtaW5zZW5zaXRpdmVcbiAqICdsZWdhY3knIG9yICdyZWdpbmFsJy5cbiAqIEBwYXJhbSBvcmlnaW5hbENvbmZpZyB1c2VyLXN1cHBsaWVkIGNvbmZpZyBvYmplY3QgdG8gcmVzb2x2ZVxuICogQHBhcmFtIG9wdGlvbnMgYSBtYXAgb2YgY29uZmlnIHByb3BlcnR5IG5hbWVzIGZyb20gaW5kaXZpZHVhbCBjb25maWd1cmF0aW9uIHNvdXJjZVxuICogIC0gZW52OiBuYW1lIG9mIGVudmlyb25tZW50YWwgdmFyaWFibGUgdGhhdCByZWZlcnMgdG8gdGhlIGNvbmZpZ1xuICogIC0gc2hhcmVkQ29uZmlnOiBuYW1lIG9mIHNoYXJlZCBjb25maWd1cmF0aW9uIGZpbGUgcHJvcGVydHkgdGhhdCByZWZlcnMgdG8gdGhlIGNvbmZpZ1xuICogIC0gY2xpZW50Q29uZmlnOiBuYW1lIG9mIGNsaWVudCBjb25maWd1cmF0aW9uIHByb3BlcnR5IHRoYXQgcmVmZXJzIHRvIHRoZSBjb25maWdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZyhvcmlnaW5hbENvbmZpZywgb3B0aW9ucykge1xuICBvcmlnaW5hbENvbmZpZyA9IG9yaWdpbmFsQ29uZmlnIHx8IHt9O1xuICAvL3ZhbGlkYXRlIGNvbmZpZyB2YWx1ZVxuICB2YXIgcmVzb2x2ZWQ7XG4gIGlmIChvcmlnaW5hbENvbmZpZ1tvcHRpb25zLmNsaWVudENvbmZpZ10pIHtcbiAgICByZXNvbHZlZCA9IHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUob3JpZ2luYWxDb25maWdbb3B0aW9ucy5jbGllbnRDb25maWddLCB7XG4gICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgbWVzc2FnZTogJ2ludmFsaWQgXCInICsgb3B0aW9ucy5jbGllbnRDb25maWcgKyAnXCIgY29uZmlndXJhdGlvbi4gRXhwZWN0IFwibGVnYWN5XCIgJyArXG4gICAgICAnIG9yIFwicmVnaW9uYWxcIi4gR290IFwiJyArIG9yaWdpbmFsQ29uZmlnW29wdGlvbnMuY2xpZW50Q29uZmlnXSArICdcIi4nXG4gICAgfSk7XG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgaWYgKCFBV1MudXRpbC5pc05vZGUoKSkgcmV0dXJuIHJlc29sdmVkO1xuICAvL3ZhbGlkYXRlIGVudmlyb25tZW50YWwgdmFyaWFibGVcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzLmVudiwgb3B0aW9ucy5lbnYpKSB7XG4gICAgdmFyIGVudkZsYWcgPSBwcm9jZXNzLmVudltvcHRpb25zLmVudl07XG4gICAgcmVzb2x2ZWQgPSB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKGVudkZsYWcsIHtcbiAgICAgIGNvZGU6ICdJbnZhbGlkRW52aXJvbm1lbnRhbFZhcmlhYmxlJyxcbiAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkICcgKyBvcHRpb25zLmVudiArICcgZW52aXJvbm1lbnRhbCB2YXJpYWJsZS4gRXhwZWN0IFwibGVnYWN5XCIgJyArXG4gICAgICAnIG9yIFwicmVnaW9uYWxcIi4gR290IFwiJyArIHByb2Nlc3MuZW52W29wdGlvbnMuZW52XSArICdcIi4nXG4gICAgfSk7XG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgLy92YWxpZGF0ZSBzaGFyZWQgY29uZmlnIGZpbGVcbiAgdmFyIHByb2ZpbGUgPSB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoQVdTLnV0aWwuaW5pTG9hZGVyKTtcbiAgICBwcm9maWxlID0gcHJvZmlsZXNbcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGVdO1xuICB9IGNhdGNoIChlKSB7fTtcbiAgaWYgKHByb2ZpbGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2ZpbGUsIG9wdGlvbnMuc2hhcmVkQ29uZmlnKSkge1xuICAgIHZhciBmaWxlRmxhZyA9IHByb2ZpbGVbb3B0aW9ucy5zaGFyZWRDb25maWddO1xuICAgIHJlc29sdmVkID0gdmFsaWRhdGVSZWdpb25hbEVuZHBvaW50c0ZsYWdWYWx1ZShmaWxlRmxhZywge1xuICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkICcgKyBvcHRpb25zLnNoYXJlZENvbmZpZyArICcgcHJvZmlsZSBjb25maWcuIEV4cGVjdCBcImxlZ2FjeVwiICcgK1xuICAgICAgJyBvciBcInJlZ2lvbmFsXCIuIEdvdCBcIicgKyBwcm9maWxlW29wdGlvbnMuc2hhcmVkQ29uZmlnXSArICdcIi4nXG4gICAgfSk7XG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWc7XG4iLCIvKipcbiAqIFRoZSBtYWluIEFXUyBuYW1lc3BhY2VcbiAqL1xudmFyIEFXUyA9IHsgdXRpbDogcmVxdWlyZSgnLi91dGlsJykgfTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEAhbWFjcm8gW25ld10gbm9icm93c2VyXG4gKiAgIEBub3RlIFRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9mIHRoZSBTREsuXG4gKi9cbnZhciBfaGlkZGVuID0ge307IF9oaWRkZW4udG9TdHJpbmcoKTsgLy8gaGFjayB0byBwYXJzZSBtYWNyb1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUztcblxuQVdTLnV0aWwudXBkYXRlKEFXUywge1xuXG4gIC8qKlxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFZFUlNJT046ICcyLjEwNTguMCcsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgU2lnbmVyczoge30sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgUHJvdG9jb2w6IHtcbiAgICBKc29uOiByZXF1aXJlKCcuL3Byb3RvY29sL2pzb24nKSxcbiAgICBRdWVyeTogcmVxdWlyZSgnLi9wcm90b2NvbC9xdWVyeScpLFxuICAgIFJlc3Q6IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdCcpLFxuICAgIFJlc3RKc29uOiByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfanNvbicpLFxuICAgIFJlc3RYbWw6IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF94bWwnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIFhNTDoge1xuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4veG1sL2J1aWxkZXInKSxcbiAgICBQYXJzZXI6IG51bGwgLy8gY29uZGl0aW9uYWxseSBzZXQgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBKU09OOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi9qc29uL2J1aWxkZXInKSxcbiAgICBQYXJzZXI6IHJlcXVpcmUoJy4vanNvbi9wYXJzZXInKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIE1vZGVsOiB7XG4gICAgQXBpOiByZXF1aXJlKCcuL21vZGVsL2FwaScpLFxuICAgIE9wZXJhdGlvbjogcmVxdWlyZSgnLi9tb2RlbC9vcGVyYXRpb24nKSxcbiAgICBTaGFwZTogcmVxdWlyZSgnLi9tb2RlbC9zaGFwZScpLFxuICAgIFBhZ2luYXRvcjogcmVxdWlyZSgnLi9tb2RlbC9wYWdpbmF0b3InKSxcbiAgICBSZXNvdXJjZVdhaXRlcjogcmVxdWlyZSgnLi9tb2RlbC9yZXNvdXJjZV93YWl0ZXInKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaUxvYWRlcjogcmVxdWlyZSgnLi9hcGlfbG9hZGVyJyksXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgRW5kcG9pbnRDYWNoZTogcmVxdWlyZSgnLi4vdmVuZG9yL2VuZHBvaW50LWNhY2hlJykuRW5kcG9pbnRDYWNoZVxufSk7XG5yZXF1aXJlKCcuL3NlcXVlbnRpYWxfZXhlY3V0b3InKTtcbnJlcXVpcmUoJy4vc2VydmljZScpO1xucmVxdWlyZSgnLi9jb25maWcnKTtcbnJlcXVpcmUoJy4vaHR0cCcpO1xucmVxdWlyZSgnLi9ldmVudF9saXN0ZW5lcnMnKTtcbnJlcXVpcmUoJy4vcmVxdWVzdCcpO1xucmVxdWlyZSgnLi9yZXNwb25zZScpO1xucmVxdWlyZSgnLi9yZXNvdXJjZV93YWl0ZXInKTtcbnJlcXVpcmUoJy4vc2lnbmVycy9yZXF1ZXN0X3NpZ25lcicpO1xucmVxdWlyZSgnLi9wYXJhbV92YWxpZGF0b3InKTtcblxuLyoqXG4gKiBAcmVhZG9ubHlcbiAqIEByZXR1cm4gW0FXUy5TZXF1ZW50aWFsRXhlY3V0b3JdIGEgY29sbGVjdGlvbiBvZiBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzIHRoYXRcbiAqICAgYXJlIGF0dGFjaGVkIHRvIGV2ZXJ5IHNlbnQgcmVxdWVzdC5cbiAqIEBzZWUgQVdTLlJlcXVlc3QgQVdTLlJlcXVlc3QgZm9yIGEgbGlzdCBvZiBldmVudHMgdG8gbGlzdGVuIGZvclxuICogQGV4YW1wbGUgTG9nZ2luZyB0aGUgdGltZSB0YWtlbiB0byBzZW5kIGEgcmVxdWVzdFxuICogICBBV1MuZXZlbnRzLm9uKCdzZW5kJywgZnVuY3Rpb24gc3RhcnRTZW5kKHJlc3ApIHtcbiAqICAgICByZXNwLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICogICB9KS5vbignY29tcGxldGUnLCBmdW5jdGlvbiBjYWxjdWxhdGVUaW1lKHJlc3ApIHtcbiAqICAgICB2YXIgdGltZSA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHJlc3Auc3RhcnRUaW1lKSAvIDEwMDA7XG4gKiAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgdG9vayAnICsgdGltZSArICcgc2Vjb25kcycpO1xuICogICB9KTtcbiAqXG4gKiAgIG5ldyBBV1MuUzMoKS5saXN0QnVja2V0cygpOyAvLyBwcmludHMgJ1JlcXVlc3QgdG9vayAwLjI4NSBzZWNvbmRzJ1xuICovXG5BV1MuZXZlbnRzID0gbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKTtcblxuLy9jcmVhdGUgZW5kcG9pbnQgY2FjaGUgbGF6aWx5XG5BV1MudXRpbC5tZW1vaXplZFByb3BlcnR5KEFXUywgJ2VuZHBvaW50Q2FjaGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBBV1MuRW5kcG9pbnRDYWNoZShBV1MuY29uZmlnLmVuZHBvaW50Q2FjaGVTaXplKTtcbn0sIHRydWUpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgeW91ciBBV1Mgc2VjdXJpdHkgY3JlZGVudGlhbHMsIHNwZWNpZmljYWxseSB0aGVcbiAqIHthY2Nlc3NLZXlJZH0sIHtzZWNyZXRBY2Nlc3NLZXl9LCBhbmQgb3B0aW9uYWwge3Nlc3Npb25Ub2tlbn0uXG4gKiBDcmVhdGluZyBhIGBDcmVkZW50aWFsc2Agb2JqZWN0IGFsbG93cyB5b3UgdG8gcGFzcyBhcm91bmQgeW91clxuICogc2VjdXJpdHkgaW5mb3JtYXRpb24gdG8gY29uZmlndXJhdGlvbiBhbmQgc2VydmljZSBvYmplY3RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGNsYXNzIHR5cGljYWxseSBkb2VzIG5vdCBuZWVkIHRvIGJlIGNvbnN0cnVjdGVkIG1hbnVhbGx5LFxuICogYXMgdGhlIHtBV1MuQ29uZmlnfSBhbmQge0FXUy5TZXJ2aWNlfSBjbGFzc2VzIGJvdGggYWNjZXB0IHNpbXBsZVxuICogb3B0aW9ucyBoYXNoZXMgd2l0aCB0aGUgdGhyZWUga2V5cy4gVGhlc2Ugc3RydWN0dXJlcyB3aWxsIGJlIGNvbnZlcnRlZFxuICogaW50byBDcmVkZW50aWFscyBvYmplY3RzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogIyMgRXhwaXJpbmcgYW5kIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHNcbiAqXG4gKiBPY2Nhc2lvbmFsbHkgY3JlZGVudGlhbHMgY2FuIGV4cGlyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbG9uZy1ydW5uaW5nXG4gKiBhcHBsaWNhdGlvbi4gSW4gdGhpcyBjYXNlLCB0aGUgU0RLIHdpbGwgYXV0b21hdGljYWxseSBhdHRlbXB0IHRvXG4gKiByZWZyZXNoIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSBzdG9yYWdlIGxvY2F0aW9uIGlmIHRoZSBDcmVkZW50aWFsc1xuICogY2xhc3MgaW1wbGVtZW50cyB0aGUge3JlZnJlc2h9IG1ldGhvZC5cbiAqXG4gKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGNyZWRlbnRpYWwgc3RvcmFnZSBsb2NhdGlvbiwgeW91XG4gKiB3aWxsIHdhbnQgdG8gY3JlYXRlIGEgc3ViY2xhc3Mgb2YgdGhlIGBDcmVkZW50aWFsc2AgY2xhc3MgYW5kXG4gKiBvdmVycmlkZSB0aGUge3JlZnJlc2h9IG1ldGhvZC4gVGhpcyBtZXRob2QgYWxsb3dzIGNyZWRlbnRpYWxzIHRvIGJlXG4gKiByZXRyaWV2ZWQgZnJvbSB0aGUgYmFja2luZyBzdG9yZSwgYmUgaXQgYSBmaWxlIHN5c3RlbSwgZGF0YWJhc2UsIG9yXG4gKiBzb21lIG5ldHdvcmsgc3RvcmFnZS4gVGhlIG1ldGhvZCBzaG91bGQgcmVzZXQgdGhlIGNyZWRlbnRpYWwgYXR0cmlidXRlc1xuICogb24gdGhlIG9iamVjdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBleHBpcmVkXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIGhhdmUgYmVlbiBleHBpcmVkIGFuZFxuICogICAgIHJlcXVpcmUgYSByZWZyZXNoLiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGgge2V4cGlyZVRpbWV9LlxuICogQCFhdHRyaWJ1dGUgZXhwaXJlVGltZVxuICogICBAcmV0dXJuIFtEYXRlXSBhIHRpbWUgd2hlbiBjcmVkZW50aWFscyBzaG91bGQgYmUgY29uc2lkZXJlZCBleHBpcmVkLiBVc2VkXG4gKiAgICAgaW4gY29uanVuY3Rpb24gd2l0aCB7ZXhwaXJlZH0uXG4gKiBAIWF0dHJpYnV0ZSBhY2Nlc3NLZXlJZFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBBV1MgYWNjZXNzIGtleSBJRFxuICogQCFhdHRyaWJ1dGUgc2VjcmV0QWNjZXNzS2V5XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleVxuICogQCFhdHRyaWJ1dGUgc2Vzc2lvblRva2VuXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gYW4gb3B0aW9uYWwgQVdTIHNlc3Npb24gdG9rZW5cbiAqL1xuQVdTLkNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBBIGNyZWRlbnRpYWxzIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB1c2luZyBwb3NpdGlvbmFsIGFyZ3VtZW50cyBvciBhbiBvcHRpb25zXG4gICAqIGhhc2guXG4gICAqXG4gICAqIEBvdmVybG9hZCBBV1MuQ3JlZGVudGlhbHMoYWNjZXNzS2V5SWQsIHNlY3JldEFjY2Vzc0tleSwgc2Vzc2lvblRva2VuPW51bGwpXG4gICAqICAgQ3JlYXRlcyBhIENyZWRlbnRpYWxzIG9iamVjdCB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGNyZWRlbnRpYWwgaW5mb3JtYXRpb25cbiAgICogICBhcyBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICogICBAcGFyYW0gYWNjZXNzS2V5SWQgW1N0cmluZ10gdGhlIEFXUyBhY2Nlc3Mga2V5IElEXG4gICAqICAgQHBhcmFtIHNlY3JldEFjY2Vzc0tleSBbU3RyaW5nXSB0aGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5XG4gICAqICAgQHBhcmFtIHNlc3Npb25Ub2tlbiBbU3RyaW5nXSB0aGUgb3B0aW9uYWwgQVdTIHNlc3Npb24gdG9rZW5cbiAgICogICBAZXhhbXBsZSBDcmVhdGUgYSBjcmVkZW50aWFscyBvYmplY3Qgd2l0aCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBjcmVkcyA9IG5ldyBBV1MuQ3JlZGVudGlhbHMoJ2FraWQnLCAnc2VjcmV0JywgJ3Nlc3Npb24nKTtcbiAgICogQG92ZXJsb2FkIEFXUy5DcmVkZW50aWFscyhvcHRpb25zKVxuICAgKiAgIENyZWF0ZXMgYSBDcmVkZW50aWFscyBvYmplY3Qgd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFsIGluZm9ybWF0aW9uXG4gICAqICAgYXMgYW4gb3B0aW9ucyBoYXNoLlxuICAgKiAgIEBvcHRpb24gb3B0aW9ucyBhY2Nlc3NLZXlJZCBbU3RyaW5nXSB0aGUgQVdTIGFjY2VzcyBrZXkgSURcbiAgICogICBAb3B0aW9uIG9wdGlvbnMgc2VjcmV0QWNjZXNzS2V5IFtTdHJpbmddIHRoZSBBV1Mgc2VjcmV0IGFjY2VzcyBrZXlcbiAgICogICBAb3B0aW9uIG9wdGlvbnMgc2Vzc2lvblRva2VuIFtTdHJpbmddIHRoZSBvcHRpb25hbCBBV1Mgc2Vzc2lvbiB0b2tlblxuICAgKiAgIEBleGFtcGxlIENyZWF0ZSBhIGNyZWRlbnRpYWxzIG9iamVjdCB3aXRoIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIGNyZWRzID0gbmV3IEFXUy5DcmVkZW50aWFscyh7XG4gICAqICAgICAgIGFjY2Vzc0tleUlkOiAnYWtpZCcsIHNlY3JldEFjY2Vzc0tleTogJ3NlY3JldCcsIHNlc3Npb25Ub2tlbjogJ3Nlc3Npb24nXG4gICAqICAgICB9KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDcmVkZW50aWFscygpIHtcbiAgICAvLyBoaWRlIHNlY3JldEFjY2Vzc0tleSBmcm9tIGJlaW5nIGRpc3BsYXllZCB3aXRoIHV0aWwuaW5zcGVjdFxuICAgIEFXUy51dGlsLmhpZGVQcm9wZXJ0aWVzKHRoaXMsIFsnc2VjcmV0QWNjZXNzS2V5J10pO1xuXG4gICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgdGhpcy5leHBpcmVUaW1lID0gbnVsbDtcbiAgICB0aGlzLnJlZnJlc2hDYWxsYmFja3MgPSBbXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNyZWRzID0gYXJndW1lbnRzWzBdLmNyZWRlbnRpYWxzIHx8IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuYWNjZXNzS2V5SWQgPSBjcmVkcy5hY2Nlc3NLZXlJZDtcbiAgICAgIHRoaXMuc2VjcmV0QWNjZXNzS2V5ID0gY3JlZHMuc2VjcmV0QWNjZXNzS2V5O1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBjcmVkcy5zZXNzaW9uVG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZXNzS2V5SWQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSB7ZXhwaXJlVGltZX0gZHVyaW5nIHdoaWNoXG4gICAqICAgdGhlIGNyZWRlbnRpYWxzIHdpbGwgYmUgY29uc2lkZXJlZCBleHBpcmVkLlxuICAgKi9cbiAgZXhwaXJ5V2luZG93OiAxNSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IHNob3VsZCBjYWxsIHtyZWZyZXNofVxuICAgKiBAbm90ZSBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGN1c3RvbSByZWZyZXNoXG4gICAqICAgbG9naWMuXG4gICAqL1xuICBuZWVkc1JlZnJlc2g6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaCgpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGFkanVzdGVkVGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lICsgdGhpcy5leHBpcnlXaW5kb3cgKiAxMDAwKTtcblxuICAgIGlmICh0aGlzLmV4cGlyZVRpbWUgJiYgYWRqdXN0ZWRUaW1lID4gdGhpcy5leHBpcmVUaW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwaXJlZCB8fCAhdGhpcy5hY2Nlc3NLZXlJZCB8fCAhdGhpcy5zZWNyZXRBY2Nlc3NLZXk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBleGlzdGluZyBjcmVkZW50aWFscywgcmVmcmVzaGluZyB0aGVtIGlmIHRoZXkgYXJlIG5vdCB5ZXQgbG9hZGVkXG4gICAqIG9yIGhhdmUgZXhwaXJlZC4gVXNlcnMgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIHtyZWZyZXNofSxcbiAgICogYXMgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBjcmVkZW50aWFscyB3aGVuIHRoZXkgYXJlIGFscmVhZHlcbiAgICogbG9hZGVkIGludG8gdGhlIG9iamVjdC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIGVpdGhlciBjcmVkZW50aWFsc1xuICAgKiAgIGRvIG5vdCBuZWVkIHRvIGJlIHJlZnJlc2hlZCBvciByZWZyZXNoZWQgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzXG4gICAqICAgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsXG4gICAqICAgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKCkpIHtcbiAgICAgIHRoaXMucmVmcmVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHNlbGYuZXhwaXJlZCA9IGZhbHNlOyAvLyByZXNldCBleHBpcmVkIGZsYWdcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBnZXRQcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKiAgIEdldHMgdGhlIGV4aXN0aW5nIGNyZWRlbnRpYWxzLCByZWZyZXNoaW5nIHRoZW0gaWYgdGhleSBhcmUgbm90IHlldCBsb2FkZWRcbiAgICogICBvciBoYXZlIGV4cGlyZWQuIFVzZXJzIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyB7cmVmcmVzaH0sXG4gICAqICAgYXMgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBjcmVkZW50aWFscyB3aGVuIHRoZXkgYXJlIGFscmVhZHlcbiAgICogICBsb2FkZWQgaW50byB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKClcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQsIGl0XG4gICAqICAgICBtZWFucyBlaXRoZXIgY3JlZGVudGlhbHMgZG8gbm90IG5lZWQgdG8gYmUgcmVmcmVzaGVkIG9yIHJlZnJlc2hlZFxuICAgKiAgICAgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlXG4gICAqICAgICBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgZ2V0YCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGBnZXRQcm9taXNlYCBtZXRob2QuXG4gICAqICAgICB2YXIgcHJvbWlzZSA9IGNyZWRQcm92aWRlci5nZXRQcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogQCFtZXRob2QgIHJlZnJlc2hQcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKiAgIFJlZnJlc2hlcyB0aGUgY3JlZGVudGlhbHMuIFVzZXJzIHNob3VsZCBjYWxsIHtnZXR9IGJlZm9yZSBhdHRlbXB0aW5nXG4gICAqICAgdG8gZm9yY2libHkgcmVmcmVzaCBjcmVkZW50aWFscy5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbigpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLiBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkLCBpdFxuICAgKiAgICAgbWVhbnMgcmVmcmVzaGVkIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3RcbiAgICogICAgIChhcyB0aGUgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlZnJlc2hgIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgQ2FsbGluZyB0aGUgYHJlZnJlc2hQcm9taXNlYCBtZXRob2QuXG4gICAqICAgICB2YXIgcHJvbWlzZSA9IGNyZWRQcm92aWRlci5yZWZyZXNoUHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyB0aGUgY3JlZGVudGlhbHMuIFVzZXJzIHNob3VsZCBjYWxsIHtnZXR9IGJlZm9yZSBhdHRlbXB0aW5nXG4gICAqIHRvIGZvcmNpYmx5IHJlZnJlc2ggY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyByZWZyZXNoZWRcbiAgICogICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGVcbiAgICogICBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAbm90ZSBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIGNsYXNzIHRvIHJlc2V0IHRoZVxuICAgKiAgIHthY2Nlc3NLZXlJZH0sIHtzZWNyZXRBY2Nlc3NLZXl9IGFuZCBvcHRpb25hbCB7c2Vzc2lvblRva2VufVxuICAgKiAgIG9uIHRoZSBjcmVkZW50aWFscyBvYmplY3QgYW5kIHRoZW4gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aFxuICAgKiAgIGFueSBlcnJvciBpbmZvcm1hdGlvbi5cbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICBjYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjb2FsZXNjZVJlZnJlc2g6IGZ1bmN0aW9uIGNvYWxlc2NlUmVmcmVzaChjYWxsYmFjaywgc3luYykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5yZWZyZXNoQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spID09PSAxKSB7XG4gICAgICBzZWxmLmxvYWQoZnVuY3Rpb24gb25Mb2FkKGVycikge1xuICAgICAgICBBV1MudXRpbC5hcnJheUVhY2goc2VsZi5yZWZyZXNoQ2FsbGJhY2tzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYWxsYmFjayBjb3VsZCB0aHJvdywgc28gZGVmZXIgdG8gZW5zdXJlIGFsbCBjYWxsYmFja3MgYXJlIG5vdGlmaWVkXG4gICAgICAgICAgICBBV1MudXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnJlZnJlc2hDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuQ3JlZGVudGlhbHMuYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLmdldFByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ2dldCcsIFByb21pc2VEZXBlbmRlbmN5KTtcbiAgdGhpcy5wcm90b3R5cGUucmVmcmVzaFByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ3JlZnJlc2gnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuQ3JlZGVudGlhbHMuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLmdldFByb21pc2U7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5yZWZyZXNoUHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5DcmVkZW50aWFscyk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20ge0FXUy5TVFN9LiBXaXRob3V0IGFueVxuICogZXh0cmEgcGFyYW1ldGVycywgY3JlZGVudGlhbHMgd2lsbCBiZSBmZXRjaGVkIGZyb20gdGhlXG4gKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbi4gSWYgYW4gSUFNIHJvbGUgaXMgcHJvdmlkZWQsIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3BlcmF0aW9uIHdpbGwgYmUgdXNlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiByb2xlIGluc3RlYWQuXG4gKlxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIGRpZmZlcnMgZnJvbSBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgaW5cbiAqIHRoZSB3YXkgbWFzdGVyQ3JlZGVudGlhbHMgYW5kIHJlZnJlc2hlcyBhcmUgaGFuZGxlZC5cbiAqIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyByZWZyZXNoZXMgZXhwaXJlZCBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIG1hc3RlckNyZWRlbnRpYWxzIHBhc3NlZCBieSB0aGUgdXNlciB0byBzdXBwb3J0IGNoYWluaW5nIG9mIFNUUyBjcmVkZW50aWFscy5cbiAqIEhvd2V2ZXIsIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyByZWN1cnNpdmVseSBjb2xsYXBzZXMgdGhlIG1hc3RlckNyZWRlbnRpYWxzXG4gKiBkdXJpbmcgaW5zdGFudGlhdGlvbiwgcHJlY2x1ZGluZyB0aGUgYWJpbGl0eSB0byByZWZyZXNoIGNyZWRlbnRpYWxzIHdoaWNoXG4gKiByZXF1aXJlIGludGVybWVkaWF0ZSwgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgYXBwbGljYXRpb24gc2hvdWxkIHVzZSBSb2xlQSwgd2hpY2ggbXVzdCBiZSBhc3N1bWVkIGZyb21cbiAqIFJvbGVCLCBhbmQgdGhlIGVudmlyb25tZW50IHByb3ZpZGVzIGNyZWRlbnRpYWxzIHdoaWNoIGNhbiBhc3N1bWUgUm9sZUIsIHRoZW5cbiAqIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyBtdXN0IGJlIHVzZWQgdG8gc3VwcG9ydCByZWZyZXNoaW5nIHRoZVxuICogdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZvciBSb2xlQTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcm9sZUFDcmVkcyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICogICBwYXJhbXM6IHtSb2xlQXJuOiAnUm9sZUEnfSxcbiAqICAgbWFzdGVyQ3JlZGVudGlhbHM6IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICogICAgIHBhcmFtczoge1JvbGVBcm46ICdSb2xlQid9LFxuICogICAgIG1hc3RlckNyZWRlbnRpYWxzOiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpXG4gKiAgIH0pXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIElmIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyBoYWQgYmVlbiB1c2VkIGluIHRoZSBwcmV2aW91cyBleGFtcGxlLFxuICogYHJvbGVBQ3JlZHNgIHdvdWxkIGZhaWwgdG8gcmVmcmVzaCBiZWNhdXNlIGByb2xlQUNyZWRzYCB3b3VsZFxuICogdXNlIHRoZSBlbnZpcm9ubWVudCBjcmVkZW50aWFscyBmb3IgdGhlIEFzc3VtZVJvbGUgcmVxdWVzdC5cbiAqXG4gKiBBbm90aGVyIGRpZmZlcmVuY2UgaXMgdGhhdCBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgY3JlYXRlcyB0aGUgU1RTXG4gKiBzZXJ2aWNlIGluc3RhbmNlIGR1cmluZyBpbnN0YW50aWF0aW9uIHdoaWxlIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyBjcmVhdGVzXG4gKiB0aGUgU1RTIHNlcnZpY2UgaW5zdGFuY2UgZHVyaW5nIHRoZSBmaXJzdCByZWZyZXNoLiBDcmVhdGluZyB0aGUgc2VydmljZVxuICogaW5zdGFuY2UgZHVyaW5nIGluc3RhbnRpYXRpb24gZWZmZWN0aXZlbHkgY2FwdHVyZXMgdGhlIG1hc3RlciBjcmVkZW50aWFsc1xuICogZnJvbSB0aGUgZ2xvYmFsIGNvbmZpZywgc28gdGhhdCBzdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGdsb2JhbCBjb25maWcgZG9cbiAqIG5vdCBhZmZlY3QgdGhlIG1hc3RlciBjcmVkZW50aWFscyB1c2VkIHRvIHJlZnJlc2ggdGhlIHRlbXBvcmFyeSBjcmVkZW50aWFscy5cbiAqXG4gKiBUaGlzIGFsbG93cyBhbiBpbnN0YW5jZSBvZiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgdG8gYmUgYXNzaWduZWRcbiAqIHRvIEFXUy5jb25maWcuY3JlZGVudGlhbHM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGVudkNyZWRzID0gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTtcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBlbnZDcmVkcztcbiAqIC8vIG1hc3RlckNyZWRlbnRpYWxzIHdpbGwgYmUgZW52Q3JlZHNcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgcGFyYW1zOiB7Um9sZUFybjogJy4uLid9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFNpbWlsYXJseSwgdG8gdXNlIHRoZSBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbidzIGRlZmF1bHQgcHJvdmlkZXJzIGFzIHRoZVxuICogbWFzdGVyIGNyZWRlbnRpYWxzLCBzaW1wbHkgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgIHBhcmFtczoge1JvbGVBcm46ICcuLi4nfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAIWF0dHJpYnV0ZSBzZXJ2aWNlXG4gKiAgIEByZXR1cm4gW0FXUy5TVFNdIHRoZSBTVFMgc2VydmljZSBpbnN0YW5jZSB1c2VkIHRvXG4gKiAgICAgZ2V0IGFuZCByZWZyZXNoIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuXG4gKiBAbm90ZSAoc2VlIGNvbnN0cnVjdG9yKVxuICovXG5BV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXSBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbXMgW21hcF0gKHt9KSBhIG1hcCBvZiBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byB0aGVcbiAgICogICB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvciB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbnMuXG4gICAqICAgSWYgYSBgUm9sZUFybmAgcGFyYW1ldGVyIGlzIHBhc3NlZCBpbiwgY3JlZGVudGlhbHMgd2lsbCBiZSBiYXNlZCBvbiB0aGVcbiAgICogICBJQU0gcm9sZS4gSWYgYSBgU2VyaWFsTnVtYmVyYCBwYXJhbWV0ZXIgaXMgcGFzc2VkIGluLCB7dG9rZW5Db2RlRm59IG11c3RcbiAgICogICBhbHNvIGJlIHBhc3NlZCBpbiBvciBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogQG9wdGlvbiBvcHRpb25zIG1hc3RlckNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBtYXN0ZXIgY3JlZGVudGlhbHNcbiAgICogICB1c2VkIHRvIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLiBCeSBkZWZhdWx0LFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgb3IgQVdTLmNvbmZpZy5jcmVkZW50aWFsUHJvdmlkZXIgd2lsbCBiZSB1c2VkLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgdG9rZW5Db2RlRm4gW0Z1bmN0aW9uXSAobnVsbCkgRnVuY3Rpb24gdG8gcHJvdmlkZVxuICAgKiAgIGBUb2tlbkNvZGVgLCBpZiBgU2VyaWFsTnVtYmVyYCBpcyBwcm92aWRlZCBmb3IgcHJvZmlsZSBpbiB7cGFyYW1zfS4gRnVuY3Rpb25cbiAgICogICBpcyBjYWxsZWQgd2l0aCB2YWx1ZSBvZiBgU2VyaWFsTnVtYmVyYCBhbmQgYGNhbGxiYWNrYCwgYW5kIHNob3VsZCBwcm92aWRlXG4gICAqICAgdGhlIGBUb2tlbkNvZGVgIG9yIGFuIGVycm9yIHRvIHRoZSBjYWxsYmFjayBpbiB0aGUgZm9ybWF0XG4gICAqICAgYGNhbGxiYWNrKGVyciwgdG9rZW4pYC5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBnZW5lcmljIHRlbXBvcmFyeSBjcmVkZW50aWFsc1xuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgYW4gSUFNIHJvbGVcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gICAqICAgICBwYXJhbXM6IHtcbiAgICogICAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvVGVtcG9yYXJ5Q3JlZGVudGlhbHMnXG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlXG4gICAqIEBzZWUgQVdTLlNUUy5nZXRTZXNzaW9uVG9rZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyhvcHRpb25zKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5lcnJvckNvZGUgPSAnQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG4gICAgdGhpcy50b2tlbkNvZGVGbiA9IG51bGw7XG5cbiAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weShvcHRpb25zLnBhcmFtcykgfHwge307XG4gICAgaWYgKHBhcmFtcy5Sb2xlQXJuKSB7XG4gICAgICBwYXJhbXMuUm9sZVNlc3Npb25OYW1lID0gcGFyYW1zLlJvbGVTZXNzaW9uTmFtZSB8fCAndGVtcG9yYXJ5LWNyZWRlbnRpYWxzJztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5TZXJpYWxOdW1iZXIpIHtcbiAgICAgIGlmICghb3B0aW9ucy50b2tlbkNvZGVGbiB8fCAodHlwZW9mIG9wdGlvbnMudG9rZW5Db2RlRm4gIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ3Rva2VuQ29kZUZuIG11c3QgYmUgYSBmdW5jdGlvbiB3aGVuIHBhcmFtcy5TZXJpYWxOdW1iZXIgaXMgZ2l2ZW4nKSxcbiAgICAgICAgICB7Y29kZTogdGhpcy5lcnJvckNvZGV9XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRva2VuQ29kZUZuID0gb3B0aW9ucy50b2tlbkNvZGVGbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNvbmZpZyA9IEFXUy51dGlsLm1lcmdlKFxuICAgICAge1xuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMubWFzdGVyQ3JlZGVudGlhbHMgfHwgQVdTLmNvbmZpZy5jcmVkZW50aWFsc1xuICAgICAgfSxcbiAgICAgIG9wdGlvbnMuc3RzQ29uZmlnIHx8IHt9XG4gICAgKTtcbiAgICB0aGlzLnNlcnZpY2UgPSBuZXcgU1RTKGNvbmZpZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBjcmVkZW50aWFscyB1c2luZyB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvclxuICAgKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59LCBkZXBlbmRpbmcgb24gd2hldGhlciBhbiBJQU0gcm9sZSBBUk4gd2FzIHBhc3NlZFxuICAgKiB0byB0aGUgY3JlZGVudGlhbHMge2NvbnN0cnVjdG9yfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBBV1MuQ3JlZGVudGlhbHMuZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jb2FsZXNjZVJlZnJlc2goY2FsbGJhY2sgfHwgQVdTLnV0aWwuZm4uY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcGVyYXRpb24gPSBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5Sb2xlQXJuID8gJ2Fzc3VtZVJvbGUnIDogJ2dldFNlc3Npb25Ub2tlbic7XG4gICAgdGhpcy5nZXRUb2tlbkNvZGUoZnVuY3Rpb24gKGVyciwgdG9rZW5Db2RlKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbkNvZGUpIHtcbiAgICAgICAgcGFyYW1zLlRva2VuQ29kZSA9IHRva2VuQ29kZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2VydmljZVtvcGVyYXRpb25dKHBhcmFtcywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFRva2VuQ29kZTogZnVuY3Rpb24gZ2V0VG9rZW5Db2RlKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLnRva2VuQ29kZUZuKSB7XG4gICAgICB0aGlzLnRva2VuQ29kZUZuKHRoaXMuc2VydmljZS5jb25maWcucGFyYW1zLlNlcmlhbE51bWJlciwgZnVuY3Rpb24gKGVyciwgdG9rZW4pIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyO1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgIEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0Vycm9yIGZldGNoaW5nIE1GQSB0b2tlbjogJyArIG1lc3NhZ2UpLFxuICAgICAgICAgICAgICB7IGNvZGU6IHNlbGYuZXJyb3JDb2RlfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBDb2duaXRvSWRlbnRpdHkgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL2NvZ25pdG9pZGVudGl0eScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgV2ViIElkZW50aXR5IEZlZGVyYXRpb24gdXNpbmdcbiAqIHRoZSBBbWF6b24gQ29nbml0byBJZGVudGl0eSBzZXJ2aWNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eX0gc2VydmljZSBvcGVyYXRpb24sIHdoaWNoXG4gKiByZXF1aXJlcyBlaXRoZXIgYW4gYElkZW50aXR5SWRgIG9yIGFuIGBJZGVudGl0eVBvb2xJZGAgKEFtYXpvbiBDb2duaXRvXG4gKiBJZGVudGl0eSBQb29sIElEKSwgd2hpY2ggaXMgdXNlZCB0byBjYWxsIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldElkfSB0b1xuICogb2J0YWluIGFuIGBJZGVudGl0eUlkYC4gSWYgdGhlIGlkZW50aXR5IG9yIGlkZW50aXR5IHBvb2wgaXMgbm90IGNvbmZpZ3VyZWQgaW5cbiAqIHRoZSBBbWF6b24gQ29nbml0byBDb25zb2xlIHRvIHVzZSBJQU0gcm9sZXMgd2l0aCB0aGUgYXBwcm9wcmlhdGUgcGVybWlzc2lvbnMsXG4gKiB0aGVuIGFkZGl0aW9uYWxseSBhIGBSb2xlQXJuYCBpcyByZXF1aXJlZCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdFxuICogcG9saWN5IGZvciB0aGUgQW1hem9uIENvZ25pdG8gcm9sZSB0aGF0IHRoZSB1c2VyIHdpbGwgbG9nIGludG8uIElmIGEgYFJvbGVBcm5gXG4gKiBpcyBwcm92aWRlZCwgdGhlbiB0aGlzIHByb3ZpZGVyIGdldHMgY3JlZGVudGlhbHMgdXNpbmcgdGhlXG4gKiB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fSBzZXJ2aWNlIG9wZXJhdGlvbiwgYWZ0ZXIgZmlyc3QgZ2V0dGluZyBhblxuICogT3BlbiBJRCB0b2tlbiBmcm9tIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VufS5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgaWYgdGhpcyBjcmVkZW50aWFsIHByb3ZpZGVyIGlzIHVzZWQgdG8gcHJvdmlkZSBhdXRoZW50aWNhdGVkXG4gKiBsb2dpbiwgdGhlIGBMb2dpbnNgIG1hcCBtYXkgYmUgc2V0IHRvIHRoZSB0b2tlbnMgcHJvdmlkZWQgYnkgdGhlIHJlc3BlY3RpdmVcbiAqIGlkZW50aXR5IHByb3ZpZGVycy4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIHByb3BlcnR5IHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBXZWJJZGVudGl0eVRva2VuLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuTG9naW5zWydncmFwaC5mYWNlYm9vay5jb20nXSA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJZH0sXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LCBhbmRcbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVG8gdXBkYXRlIHRoZSB0b2tlbiwgc2V0IHRoZVxuICogICAgIGBwYXJhbXMuV2ViSWRlbnRpdHlUb2tlbmAgcHJvcGVydHkuXG4gKiBAIWF0dHJpYnV0ZSBkYXRhXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIHJhdyBkYXRhIHJlc3BvbnNlIGZyb20gdGhlIGNhbGwgdG9cbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5fSwgb3JcbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gZ2V0XG4gKiAgICAgYWNjZXNzIHRvIG90aGVyIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gKiBAIWF0dHJpYnV0ZSBpZGVudGl0eUlkXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIENvZ25pdG8gSUQgcmV0dXJuZWQgYnkgdGhlIGxhc3QgY2FsbCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VufS4gVGhpcyBJRCByZXByZXNlbnRzIHRoZSBhY3R1YWxcbiAqICAgICBmaW5hbCByZXNvbHZlZCBpZGVudGl0eSBJRCBmcm9tIEFtYXpvbiBDb2duaXRvLlxuICovXG5BV1MuQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2NhbFN0b3JhZ2VLZXk6IHtcbiAgICBpZDogJ2F3cy5jb2duaXRvLmlkZW50aXR5LWlkLicsXG4gICAgcHJvdmlkZXJzOiAnYXdzLmNvZ25pdG8uaWRlbnRpdHktcHJvdmlkZXJzLidcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QuXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzKHtcbiAgICpcbiAgICogICAgIC8vIGVpdGhlciBJZGVudGl0eVBvb2xJZCBvciBJZGVudGl0eUlkIGlzIHJlcXVpcmVkXG4gICAqICAgICAvLyBTZWUgdGhlIElkZW50aXR5UG9vbElkIHBhcmFtIGZvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldElEIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICAvLyBTZWUgdGhlIElkZW50aXR5SWQgcGFyYW0gZm9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eVxuICAgKiAgICAgLy8gb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbiAobGlua2VkIGJlbG93KVxuICAgKiAgICAgSWRlbnRpdHlQb29sSWQ6ICd1cy1lYXN0LTE6MTY5OWViYzAtNzkwMC00MDk5LWI5MTAtMmRmOTRmNTJhMDMwJyxcbiAgICogICAgIElkZW50aXR5SWQ6ICd1cy1lYXN0LTE6MTI4ZDBhNzQtYzgyZi00NTUzLTkxNmQtOTAwNTNlNGE4YjBmJ1xuICAgKlxuICAgKiAgICAgLy8gb3B0aW9uYWwsIG9ubHkgbmVjZXNzYXJ5IHdoZW4gdGhlIGlkZW50aXR5IHBvb2wgaXMgbm90IGNvbmZpZ3VyZWRcbiAgICogICAgIC8vIHRvIHVzZSBJQU0gcm9sZXMgaW4gdGhlIEFtYXpvbiBDb2duaXRvIENvbnNvbGVcbiAgICogICAgIC8vIFNlZSB0aGUgUm9sZUFybiBwYXJhbSBmb3IgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5IChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9NWUFQUC1Db2duaXRvSWRlbnRpdHknLFxuICAgKlxuICAgKiAgICAgLy8gb3B0aW9uYWwgdG9rZW5zLCB1c2VkIGZvciBhdXRoZW50aWNhdGVkIGxvZ2luXG4gICAqICAgICAvLyBTZWUgdGhlIExvZ2lucyBwYXJhbSBmb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJRCAobGlua2VkIGJlbG93KVxuICAgKiAgICAgTG9naW5zOiB7XG4gICAqICAgICAgICdncmFwaC5mYWNlYm9vay5jb20nOiAnRkJUT0tFTicsXG4gICAqICAgICAgICd3d3cuYW1hem9uLmNvbSc6ICdBTUFaT05UT0tFTicsXG4gICAqICAgICAgICdhY2NvdW50cy5nb29nbGUuY29tJzogJ0dPT0dMRVRPS0VOJyxcbiAgICogICAgICAgJ2FwaS50d2l0dGVyLmNvbSc6ICdUV0lUVEVSVE9LRU4nLFxuICAgKiAgICAgICAnd3d3LmRpZ2l0cy5jb20nOiAnRElHSVRTVE9LRU4nXG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgLy8gb3B0aW9uYWwgbmFtZSwgZGVmYXVsdHMgdG8gd2ViLWlkZW50aXR5XG4gICAqICAgICAvLyBTZWUgdGhlIFJvbGVTZXNzaW9uTmFtZSBwYXJhbSBmb3IgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5IChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBSb2xlU2Vzc2lvbk5hbWU6ICd3ZWInLFxuICAgKlxuICAgKiAgICAgLy8gb3B0aW9uYWwsIG9ubHkgbmVjZXNzYXJ5IHdoZW4gYXBwbGljYXRpb24gcnVucyBpbiBhIGJyb3dzZXJcbiAgICogICAgIC8vIGFuZCBtdWx0aXBsZSB1c2VycyBhcmUgc2lnbmVkIGluIGF0IG9uY2UsIHVzZWQgZm9yIGNhY2hpbmdcbiAgICogICAgIExvZ2luSWQ6ICdleGFtcGxlQGdtYWlsLmNvbSdcbiAgICpcbiAgICogICB9LCB7XG4gICAqICAgICAgLy8gb3B0aW9uYWxseSBwcm92aWRlIGNvbmZpZ3VyYXRpb24gdG8gYXBwbHkgdG8gdGhlIHVuZGVybHlpbmcgc2VydmljZSBjbGllbnRzXG4gICAqICAgICAgLy8gaWYgY29uZmlndXJhdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZW4gY29uZmlndXJhdGlvbiB3aWxsIGJlIHB1bGxlZCBmcm9tIEFXUy5jb25maWdcbiAgICpcbiAgICogICAgICAvLyByZWdpb24gc2hvdWxkIG1hdGNoIHRoZSByZWdpb24geW91ciBpZGVudGl0eSBwb29sIGlzIGxvY2F0ZWQgaW5cbiAgICogICAgICByZWdpb246ICd1cy1lYXN0LTEnLFxuICAgKlxuICAgKiAgICAgIC8vIHNwZWNpZnkgdGltZW91dCBvcHRpb25zXG4gICAqICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICogICAgICAgIHRpbWVvdXQ6IDEwMFxuICAgKiAgICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldElkXG4gICAqIEBzZWUgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5XG4gICAqIEBzZWUgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlblxuICAgKiBAc2VlIEFXUy5Db25maWdcbiAgICogQG5vdGUgSWYgYSByZWdpb24gaXMgbm90IHByb3ZpZGVkIGluIHRoZSBnbG9iYWwgQVdTLmNvbmZpZywgb3JcbiAgICogICBzcGVjaWZpZWQgaW4gdGhlIGBjbGllbnRDb25maWdgIHRvIHRoZSBDb2duaXRvSWRlbnRpdHlDcmVkZW50aWFsc1xuICAgKiAgIGNvbnN0cnVjdG9yLCB5b3UgbWF5IGVuY291bnRlciBhICdNaXNzaW5nIGNyZWRlbnRpYWxzIGluIGNvbmZpZycgZXJyb3JcbiAgICogICB3aGVuIGNhbGxpbmcgbWFraW5nIGEgc2VydmljZSBjYWxsLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzKHBhcmFtcywgY2xpZW50Q29uZmlnKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuX2lkZW50aXR5SWQgPSBudWxsO1xuICAgIHRoaXMuX2NsaWVudENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY2xpZW50Q29uZmlnIHx8IHt9KTtcbiAgICB0aGlzLmxvYWRDYWNoZWRJZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkZW50aXR5SWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmxvYWRDYWNoZWRJZCgpO1xuICAgICAgICByZXR1cm4gc2VsZi5faWRlbnRpdHlJZCB8fCBzZWxmLnBhcmFtcy5JZGVudGl0eUlkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaWRlbnRpdHlJZCkge1xuICAgICAgICBzZWxmLl9pZGVudGl0eUlkID0gaWRlbnRpdHlJZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHl9LFxuICAgKiBvciB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBBV1MuQ3JlZGVudGlhbHMuZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jb2FsZXNjZVJlZnJlc2goY2FsbGJhY2sgfHwgQVdTLnV0aWwuZm4uY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuY3JlYXRlQ2xpZW50cygpO1xuICAgIHNlbGYuZGF0YSA9IG51bGw7XG4gICAgc2VsZi5faWRlbnRpdHlJZCA9IG51bGw7XG4gICAgc2VsZi5nZXRJZChmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGlmICghc2VsZi5wYXJhbXMuUm9sZUFybikge1xuICAgICAgICAgIHNlbGYuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eShjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5nZXRDcmVkZW50aWFsc0Zyb21TVFMoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBjYWNoZWQgQ29nbml0byBJRCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBjb25maWd1cmVkXG4gICAqIGlkZW50aXR5IHBvb2wgSUQuIFVzZSB0aGlzIHRvIG1hbnVhbGx5IGludmFsaWRhdGUgeW91ciBjYWNoZSBpZlxuICAgKiB0aGUgaWRlbnRpdHkgcG9vbCBJRCB3YXMgZGVsZXRlZC5cbiAgICovXG4gIGNsZWFyQ2FjaGVkSWQ6IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5faWRlbnRpdHlJZCA9IG51bGw7XG4gICAgZGVsZXRlIHRoaXMucGFyYW1zLklkZW50aXR5SWQ7XG5cbiAgICB2YXIgcG9vbElkID0gdGhpcy5wYXJhbXMuSWRlbnRpdHlQb29sSWQ7XG4gICAgdmFyIGxvZ2luSWQgPSB0aGlzLnBhcmFtcy5Mb2dpbklkIHx8ICcnO1xuICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXkuaWQgKyBwb29sSWQgKyBsb2dpbklkXTtcbiAgICBkZWxldGUgdGhpcy5zdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5LnByb3ZpZGVycyArIHBvb2xJZCArIGxvZ2luSWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsZWFySWRPbk5vdEF1dGhvcml6ZWQ6IGZ1bmN0aW9uIGNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlcnIuY29kZSA9PSAnTm90QXV0aG9yaXplZEV4Y2VwdGlvbicpIHtcbiAgICAgIHNlbGYuY2xlYXJDYWNoZWRJZCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgQ29nbml0byBJRCwgbG9hZGluZyBmcm9tIGNhY2hlIGlmIGl0IHdhcyBhbHJlYWR5IHJldHJpZXZlZFxuICAgKiBvbiB0aGlzIGRldmljZS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgaWRlbnRpdHlJZClcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvciwgbnVsbF0gYW4gZXJyb3Igb2JqZWN0IGlmIHRoZSBjYWxsIGZhaWxlZCBvciBudWxsIGlmXG4gICAqICAgICBpdCBzdWNjZWVkZWQuXG4gICAqICAgQHBhcmFtIGlkZW50aXR5SWQgW1N0cmluZywgbnVsbF0gaWYgc3VjY2Vzc2Z1bCwgdGhlIGNhbGxiYWNrIHdpbGwgcmV0dXJuXG4gICAqICAgICB0aGUgQ29nbml0byBJRC5cbiAgICogQG5vdGUgSWYgbm90IGxvYWRlZCBleHBsaWNpdGx5LCB0aGUgQ29nbml0byBJRCBpcyBsb2FkZWQgYW5kIHN0b3JlZCBpblxuICAgKiAgIGxvY2FsU3RvcmFnZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvZiBhIGRldmljZS5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRJZDogZnVuY3Rpb24gZ2V0SWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNlbGYucGFyYW1zLklkZW50aXR5SWQpO1xuICAgIH1cblxuICAgIHNlbGYuY29nbml0by5nZXRJZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyICYmIGRhdGEuSWRlbnRpdHlJZCkge1xuICAgICAgICBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID0gZGF0YS5JZGVudGl0eUlkO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhLklkZW50aXR5SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRDcmVkZW50aWFsczogZnVuY3Rpb24gbG9hZENyZWRlbnRpYWxzKGRhdGEsIGNyZWRlbnRpYWxzKSB7XG4gICAgaWYgKCFkYXRhIHx8ICFjcmVkZW50aWFscykgcmV0dXJuO1xuICAgIGNyZWRlbnRpYWxzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCA9IGRhdGEuQ3JlZGVudGlhbHMuQWNjZXNzS2V5SWQ7XG4gICAgY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5ID0gZGF0YS5DcmVkZW50aWFscy5TZWNyZXRLZXk7XG4gICAgY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuID0gZGF0YS5DcmVkZW50aWFscy5TZXNzaW9uVG9rZW47XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlVGltZSA9IGRhdGEuQ3JlZGVudGlhbHMuRXhwaXJhdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5OiBmdW5jdGlvbiBnZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuY29nbml0by5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5jYWNoZUlkKGRhdGEpO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLmxvYWRDcmVkZW50aWFscyhzZWxmLmRhdGEsIHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jbGVhcklkT25Ob3RBdXRob3JpemVkKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldENyZWRlbnRpYWxzRnJvbVNUUzogZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGcm9tU1RTKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuY29nbml0by5nZXRPcGVuSWRUb2tlbihmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuY2FjaGVJZChkYXRhKTtcbiAgICAgICAgc2VsZi5wYXJhbXMuV2ViSWRlbnRpdHlUb2tlbiA9IGRhdGEuVG9rZW47XG4gICAgICAgIHNlbGYud2ViSWRlbnRpdHlDcmVkZW50aWFscy5yZWZyZXNoKGZ1bmN0aW9uKHdlYkVycikge1xuICAgICAgICAgIGlmICghd2ViRXJyKSB7XG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBzZWxmLndlYklkZW50aXR5Q3JlZGVudGlhbHMuZGF0YTtcbiAgICAgICAgICAgIHNlbGYuc3RzLmNyZWRlbnRpYWxzRnJvbShzZWxmLmRhdGEsIHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayh3ZWJFcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRDYWNoZWRJZDogZnVuY3Rpb24gbG9hZENhY2hlZElkKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGluIHRoZSBicm93c2VyIHdlIHNvdXJjZSBkZWZhdWx0IElkZW50aXR5SWQgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkgJiYgIXNlbGYucGFyYW1zLklkZW50aXR5SWQpIHtcbiAgICAgIHZhciBpZCA9IHNlbGYuZ2V0U3RvcmFnZSgnaWQnKTtcbiAgICAgIGlmIChpZCAmJiBzZWxmLnBhcmFtcy5Mb2dpbnMpIHtcbiAgICAgICAgdmFyIGFjdHVhbFByb3ZpZGVycyA9IE9iamVjdC5rZXlzKHNlbGYucGFyYW1zLkxvZ2lucyk7XG4gICAgICAgIHZhciBjYWNoZWRQcm92aWRlcnMgPVxuICAgICAgICAgIChzZWxmLmdldFN0b3JhZ2UoJ3Byb3ZpZGVycycpIHx8ICcnKS5zcGxpdCgnLCcpO1xuXG4gICAgICAgIC8vIG9ubHkgbG9hZCBJRCBpZiBhdCBsZWFzdCBvbmUgcHJvdmlkZXIgdXNlZCB0aGlzIElEIGJlZm9yZVxuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gY2FjaGVkUHJvdmlkZXJzLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdHVhbFByb3ZpZGVycy5pbmRleE9mKG4pICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9IGlkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkKSB7XG4gICAgICAgIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPSBpZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsaWVudENvbmZpZyA9IHRoaXMuX2NsaWVudENvbmZpZztcbiAgICB0aGlzLndlYklkZW50aXR5Q3JlZGVudGlhbHMgPSB0aGlzLndlYklkZW50aXR5Q3JlZGVudGlhbHMgfHxcbiAgICAgIG5ldyBBV1MuV2ViSWRlbnRpdHlDcmVkZW50aWFscyh0aGlzLnBhcmFtcywgY2xpZW50Q29uZmlnKTtcbiAgICBpZiAoIXRoaXMuY29nbml0bykge1xuICAgICAgdmFyIGNvZ25pdG9Db25maWcgPSBBV1MudXRpbC5tZXJnZSh7fSwgY2xpZW50Q29uZmlnKTtcbiAgICAgIGNvZ25pdG9Db25maWcucGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLmNvZ25pdG8gPSBuZXcgQ29nbml0b0lkZW50aXR5KGNvZ25pdG9Db25maWcpO1xuICAgIH1cbiAgICB0aGlzLnN0cyA9IHRoaXMuc3RzIHx8IG5ldyBTVFMoY2xpZW50Q29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjYWNoZUlkOiBmdW5jdGlvbiBjYWNoZUlkKGRhdGEpIHtcbiAgICB0aGlzLl9pZGVudGl0eUlkID0gZGF0YS5JZGVudGl0eUlkO1xuICAgIHRoaXMucGFyYW1zLklkZW50aXR5SWQgPSB0aGlzLl9pZGVudGl0eUlkO1xuXG4gICAgLy8gY2FjaGUgdGhpcyBJZGVudGl0eUlkIGluIGJyb3dzZXIgbG9jYWxTdG9yYWdlIGlmIHBvc3NpYmxlXG4gICAgaWYgKEFXUy51dGlsLmlzQnJvd3NlcigpKSB7XG4gICAgICB0aGlzLnNldFN0b3JhZ2UoJ2lkJywgZGF0YS5JZGVudGl0eUlkKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLkxvZ2lucykge1xuICAgICAgICB0aGlzLnNldFN0b3JhZ2UoJ3Byb3ZpZGVycycsIE9iamVjdC5rZXlzKHRoaXMucGFyYW1zLkxvZ2lucykuam9pbignLCcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U3RvcmFnZTogZnVuY3Rpb24gZ2V0U3RvcmFnZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5W2tleV0gKyB0aGlzLnBhcmFtcy5JZGVudGl0eVBvb2xJZCArICh0aGlzLnBhcmFtcy5Mb2dpbklkIHx8ICcnKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0U3RvcmFnZTogZnVuY3Rpb24gc2V0U3RvcmFnZShrZXksIHZhbCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXlba2V5XSArIHRoaXMucGFyYW1zLklkZW50aXR5UG9vbElkICsgKHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJycpXSA9IHZhbDtcbiAgICB9IGNhdGNoIChfKSB7fVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHN0b3JhZ2U6IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHN0b3JhZ2UgPSBBV1MudXRpbC5pc0Jyb3dzZXIoKSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZSA6IHt9O1xuXG4gICAgICAvLyBUZXN0IHNldC9yZW1vdmUgd2hpY2ggd291bGQgdGhyb3cgYW4gZXJyb3IgaW4gU2FmYXJpJ3MgcHJpdmF0ZSBicm93c2luZ1xuICAgICAgc3RvcmFnZVsnYXdzLnRlc3Qtc3RvcmFnZSddID0gJ2Zvb2Jhcic7XG4gICAgICBkZWxldGUgc3RvcmFnZVsnYXdzLnRlc3Qtc3RvcmFnZSddO1xuXG4gICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9KSgpXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgcHJvdmlkZXIgY2hhaW4gdGhhdCBzZWFyY2hlcyBmb3IgQVdTIGNyZWRlbnRpYWxzXG4gKiBpbiBhIGxpc3Qgb2YgY3JlZGVudGlhbCBwcm92aWRlcnMgc3BlY2lmaWVkIGJ5IHRoZSB7cHJvdmlkZXJzfSBwcm9wZXJ0eS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgY2hhaW4gd2lsbCB1c2UgdGhlIHtkZWZhdWx0UHJvdmlkZXJzfSB0byByZXNvbHZlIGNyZWRlbnRpYWxzLlxuICogVGhlc2UgcHJvdmlkZXJzIHdpbGwgbG9vayBpbiB0aGUgZW52aXJvbm1lbnQgdXNpbmcgdGhlXG4gKiB7QVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHN9IGNsYXNzIHdpdGggdGhlICdBV1MnIGFuZCAnQU1BWk9OJyBwcmVmaXhlcy5cbiAqXG4gKiAjIyBTZXR0aW5nIFByb3ZpZGVyc1xuICpcbiAqIEVhY2ggcHJvdmlkZXIgaW4gdGhlIHtwcm92aWRlcnN9IGxpc3Qgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gKiBhIHtBV1MuQ3JlZGVudGlhbHN9IG9iamVjdCwgb3IgYSBoYXJkY29kZWQgY3JlZGVudGlhbHMgb2JqZWN0LiBUaGUgZnVuY3Rpb25cbiAqIGZvcm0gYWxsb3dzIGZvciBkZWxheWVkIGV4ZWN1dGlvbiBvZiB0aGUgY3JlZGVudGlhbCBjb25zdHJ1Y3Rpb24uXG4gKlxuICogIyMgUmVzb2x2aW5nIENyZWRlbnRpYWxzIGZyb20gYSBDaGFpblxuICpcbiAqIENhbGwge3Jlc29sdmV9IHRvIHJldHVybiB0aGUgZmlyc3QgdmFsaWQgY3JlZGVudGlhbCBvYmplY3QgdGhhdCBjYW4gYmVcbiAqIGxvYWRlZCBieSB0aGUgcHJvdmlkZXIgY2hhaW4uXG4gKlxuICogRm9yIGV4YW1wbGUsIHRvIHJlc29sdmUgYSBjaGFpbiB3aXRoIGEgY3VzdG9tIHByb3ZpZGVyIHRoYXQgY2hlY2tzIGEgZmlsZVxuICogb24gZGlzayBhZnRlciB0aGUgc2V0IG9mIHtkZWZhdWx0UHJvdmlkZXJzfTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgZGlza1Byb3ZpZGVyID0gbmV3IEFXUy5GaWxlU3lzdGVtQ3JlZGVudGlhbHMoJy4vY3JlZHMuanNvbicpO1xuICogdmFyIGNoYWluID0gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbigpO1xuICogY2hhaW4ucHJvdmlkZXJzLnB1c2goZGlza1Byb3ZpZGVyKTtcbiAqIGNoYWluLnJlc29sdmUoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBjb2RlIHdpbGwgcmV0dXJuIHRoZSBgZGlza1Byb3ZpZGVyYCBvYmplY3QgaWYgdGhlXG4gKiBmaWxlIGNvbnRhaW5zIGNyZWRlbnRpYWxzIGFuZCB0aGUgYGRlZmF1bHRQcm92aWRlcnNgIGRvIG5vdCBjb250YWluXG4gKiBhbnkgY3JlZGVudGlhbCBzZXR0aW5ncy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwcm92aWRlcnNcbiAqICAgQHJldHVybiBbQXJyYXk8QVdTLkNyZWRlbnRpYWxzLCBGdW5jdGlvbj5dXG4gKiAgICAgYSBsaXN0IG9mIGNyZWRlbnRpYWxzIG9iamVjdHMgb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIGNyZWRlbnRpYWxzXG4gKiAgICAgb2JqZWN0cy4gSWYgdGhlIHByb3ZpZGVyIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiB3aWxsIGJlXG4gKiAgICAgZXhlY3V0ZWQgbGF6aWx5IHdoZW4gdGhlIHByb3ZpZGVyIG5lZWRzIHRvIGJlIGNoZWNrZWQgZm9yIHZhbGlkXG4gKiAgICAgY3JlZGVudGlhbHMuIEJ5IGRlZmF1bHQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgc2V0IHRvIHRoZVxuICogICAgIHtkZWZhdWx0UHJvdmlkZXJzfS5cbiAqICAgQHNlZSBkZWZhdWx0UHJvdmlkZXJzXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbiA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4gd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHByb3ZpZGVyc1xuICAgKiBzcGVjaWZpZWQgYnkge2RlZmF1bHRQcm92aWRlcnN9LlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENyZWRlbnRpYWxQcm92aWRlckNoYWluKHByb3ZpZGVycykge1xuICAgIGlmIChwcm92aWRlcnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3ZpZGVycyA9IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzLnNsaWNlKDApO1xuICAgIH1cbiAgICB0aGlzLnJlc29sdmVDYWxsYmFja3MgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIHJlc29sdmVQcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKiAgIFJlc29sdmVzIHRoZSBwcm92aWRlciBjaGFpbiBieSBzZWFyY2hpbmcgZm9yIHRoZSBmaXJzdCBzZXQgb2ZcbiAgICogICBjcmVkZW50aWFscyBpbiB7cHJvdmlkZXJzfS5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbihjcmVkZW50aWFscylcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgYW5kIHRoZSBwcm92aWRlciByZXNvbHZlcyB0aGUgY2hhaW5cbiAgICogICAgIHRvIGEgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgICBAcGFyYW0gY3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCByZXNvbHZlZFxuICAgKiAgICAgICBieSB0aGUgcHJvdmlkZXIgY2hhaW4uXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyb3IpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBpZiBubyBjcmVkZW50aWFscyBhcmUgZm91bmQuXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGByZXNvbHZlYCBtZXRob2QgY2FsbC5cbiAgICogICBAZXhhbXBsZSBDYWxsaW5nIHRoZSBgcmVzb2x2ZVByb21pc2VgIG1ldGhvZC5cbiAgICogICAgIHZhciBwcm9taXNlID0gY2hhaW4ucmVzb2x2ZVByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbihjcmVkZW50aWFscykgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBwcm92aWRlciBjaGFpbiBieSBzZWFyY2hpbmcgZm9yIHRoZSBmaXJzdCBzZXQgb2ZcbiAgICogY3JlZGVudGlhbHMgaW4ge3Byb3ZpZGVyc30uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGNyZWRlbnRpYWxzKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBwcm92aWRlciByZXNvbHZlcyB0aGUgY2hhaW4gdG8gYSBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICBvciBudWxsIGlmIG5vIGNyZWRlbnRpYWxzIGNhbiBiZSBmb3VuZC5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBpZiBubyBjcmVkZW50aWFscyBhcmVcbiAgICogICAgIGZvdW5kLlxuICAgKiAgIEBwYXJhbSBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IHJlc29sdmVkXG4gICAqICAgICBieSB0aGUgcHJvdmlkZXIgY2hhaW4uXG4gICAqIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbl0gdGhlIHByb3ZpZGVyLCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnByb3ZpZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignTm8gcHJvdmlkZXJzJykpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYucmVzb2x2ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKSA9PT0gMSkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBwcm92aWRlcnMgPSBzZWxmLnByb3ZpZGVycy5zbGljZSgwKTtcblxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZU5leHQoZXJyLCBjcmVkcykge1xuICAgICAgICBpZiAoKCFlcnIgJiYgY3JlZHMpIHx8IGluZGV4ID09PSBwcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKHNlbGYucmVzb2x2ZUNhbGxiYWNrcywgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIGNyZWRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLnJlc29sdmVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvdmlkZXIgPSBwcm92aWRlcnNbaW5kZXgrK107XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVkcyA9IHByb3ZpZGVyLmNhbGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcmVkcyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyZWRzLmdldCkge1xuICAgICAgICAgIGNyZWRzLmdldChmdW5jdGlvbiAoZ2V0RXJyKSB7XG4gICAgICAgICAgICByZXNvbHZlTmV4dChnZXRFcnIsIGdldEVyciA/IG51bGwgOiBjcmVkcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZU5leHQobnVsbCwgY3JlZHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmVOZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHNldCBvZiBwcm92aWRlcnMgdXNlZCBieSBhIHZhbmlsbGEgQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uXG4gKlxuICogSW4gdGhlIGJyb3dzZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXVxuICogYGBgXG4gKlxuICogSW4gTm9kZS5qczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyA9IFtcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FQ1NDcmVkZW50aWFscygpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlByb2Nlc3NDcmVkZW50aWFscygpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlRva2VuRmlsZVdlYklkZW50aXR5Q3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzKCkgfVxuICogXVxuICogYGBgXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW107XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUucmVzb2x2ZVByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ3Jlc29sdmUnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnJlc29sdmVQcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5yZXF1aXJlKCcuLi9tZXRhZGF0YV9zZXJ2aWNlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZWNlaXZlZCBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2aWNlIG9uIGFuIEVDMiBpbnN0YW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNsYXNzIHdpbGwgY29ubmVjdCB0byB0aGUgbWV0YWRhdGEgc2VydmljZSB1c2luZ1xuICoge0FXUy5NZXRhZGF0YVNlcnZpY2V9IGFuZCBhdHRlbXB0IHRvIGxvYWQgYW55IGF2YWlsYWJsZSBjcmVkZW50aWFscy4gSWYgaXRcbiAqIGNhbiBjb25uZWN0LCBhbmQgY3JlZGVudGlhbHMgYXJlIGF2YWlsYWJsZSwgdGhlc2Ugd2lsbCBiZSB1c2VkIHdpdGggemVyb1xuICogY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUaGlzIGNyZWRlbnRpYWxzIGNsYXNzIHdpbGwgYnkgZGVmYXVsdCB0aW1lb3V0IGFmdGVyIDEgc2Vjb25kIG9mIGluYWN0aXZpdHlcbiAqIGFuZCByZXRyeSAzIHRpbWVzLlxuICogSWYgeW91ciByZXF1ZXN0cyB0byB0aGUgRUMyIG1ldGFkYXRhIHNlcnZpY2UgYXJlIHRpbWluZyBvdXQsIHlvdSBjYW4gaW5jcmVhc2VcbiAqIHRoZXNlIHZhbHVlcyBieSBjb25maWd1cmluZyB0aGVtIGRpcmVjdGx5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoe1xuICogICBodHRwT3B0aW9uczogeyB0aW1lb3V0OiA1MDAwIH0sIC8vIDUgc2Vjb25kIHRpbWVvdXRcbiAqICAgbWF4UmV0cmllczogMTAsIC8vIHJldHJ5IDEwIHRpbWVzXG4gKiAgIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDIwMCB9IC8vIHNlZSBBV1MuQ29uZmlnIGZvciBpbmZvcm1hdGlvblxuICogfSk7XG4gKlxuICogSWYgeW91ciByZXF1ZXN0cyBhcmUgdGltaW5nIG91dCBpbiBjb25uZWN0aW5nIHRvIHRoZSBtZXRhZGF0YSBzZXJ2aWNlLCBzdWNoXG4gKiBhcyB3aGVuIHRlc3Rpbmcgb24gYSBkZXZlbG9wbWVudCBtYWNoaW5lLCB5b3UgY2FuIHVzZSB0aGUgY29ubmVjdFRpbWVvdXRcbiAqIG9wdGlvbiwgc3BlY2lmaWVkIGluIG1pbGxpc2Vjb25kcywgd2hpY2ggYWxzbyBkZWZhdWx0cyB0byAxIHNlY29uZC5cbiAqIGBgYFxuICpcbiAqIEBzZWUgQVdTLkNvbmZpZy5yZXRyeURlbGF5T3B0aW9uc1xuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEVDMk1ldGFkYXRhQ3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBBV1MudXRpbC5jb3B5KG9wdGlvbnMpIDoge307XG4gICAgb3B0aW9ucyA9IEFXUy51dGlsLm1lcmdlKFxuICAgICAge21heFJldHJpZXM6IHRoaXMuZGVmYXVsdE1heFJldHJpZXN9LCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMuaHR0cE9wdGlvbnMpIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zLmh0dHBPcHRpb25zID0gQVdTLnV0aWwubWVyZ2UoXG4gICAgICB7dGltZW91dDogdGhpcy5kZWZhdWx0VGltZW91dCxcbiAgICAgICAgY29ubmVjdFRpbWVvdXQ6IHRoaXMuZGVmYXVsdENvbm5lY3RUaW1lb3V0fSxcbiAgICAgICBvcHRpb25zLmh0dHBPcHRpb25zKTtcblxuICAgIHRoaXMubWV0YWRhdGFTZXJ2aWNlID0gbmV3IEFXUy5NZXRhZGF0YVNlcnZpY2Uob3B0aW9ucyk7XG4gICAgdGhpcy5tZXRhZGF0YSA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRUaW1lb3V0OiAxMDAwLFxuXG4gICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZhdWx0Q29ubmVjdFRpbWVvdXQ6IDEwMDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdE1heFJldHJpZXM6IDMsXG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSBpbnN0YW5jZSBtZXRhZGF0YSBzZXJ2aWNlXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIGluc3RhbmNlIG1ldGFkYXRhIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5tZXRhZGF0YVNlcnZpY2UubG9hZENyZWRlbnRpYWxzKGZ1bmN0aW9uKGVyciwgY3JlZHMpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB2YXIgZXhwaXJlVGltZSA9IG5ldyBEYXRlKGNyZWRzLkV4cGlyYXRpb24pO1xuICAgICAgICBpZiAoZXhwaXJlVGltZSA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgZXJyID0gQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ0VDMiBJbnN0YW5jZSBNZXRhZGF0YSBTZXJpdmNlIHByb3ZpZGVkIGV4cGlyZWQgY3JlZGVudGlhbHMnKSxcbiAgICAgICAgICAgIHsgY29kZTogJ0VDMk1ldGFkYXRhQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZXhwaXJlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYubWV0YWRhdGEgPSBjcmVkcztcbiAgICAgICAgICBzZWxmLmFjY2Vzc0tleUlkID0gY3JlZHMuQWNjZXNzS2V5SWQ7XG4gICAgICAgICAgc2VsZi5zZWNyZXRBY2Nlc3NLZXkgPSBjcmVkcy5TZWNyZXRBY2Nlc3NLZXk7XG4gICAgICAgICAgc2VsZi5zZXNzaW9uVG9rZW4gPSBjcmVkcy5Ub2tlbjtcbiAgICAgICAgICBzZWxmLmV4cGlyZVRpbWUgPSBleHBpcmVUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZWNlaXZlZCBmcm9tIHJlbGF0aXZlIFVSSSBzcGVjaWZpZWQgaW4gdGhlIEVDUyBjb250YWluZXIuXG4gKlxuICogVGhpcyBjbGFzcyB3aWxsIHJlcXVlc3QgcmVmcmVzaGFibGUgY3JlZGVudGlhbHMgZnJvbSB0aGUgcmVsYXRpdmUgVVJJXG4gKiBzcGVjaWZpZWQgYnkgdGhlIEFXU19DT05UQUlORVJfQ1JFREVOVElBTFNfUkVMQVRJVkVfVVJJIG9yIHRoZVxuICogQVdTX0NPTlRBSU5FUl9DUkVERU5USUFMU19GVUxMX1VSSSBlbnZpcm9ubWVudCB2YXJpYWJsZS4gSWYgdmFsaWQgY3JlZGVudGlhbHNcbiAqIGFyZSByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UsIHRoZXNlIHdpbGwgYmUgdXNlZCB3aXRoIHplcm8gY29uZmlndXJhdGlvbi5cbiAqXG4gKiBUaGlzIGNyZWRlbnRpYWxzIGNsYXNzIHdpbGwgYnkgZGVmYXVsdCB0aW1lb3V0IGFmdGVyIDEgc2Vjb25kIG9mIGluYWN0aXZpdHlcbiAqIGFuZCByZXRyeSAzIHRpbWVzLlxuICogSWYgeW91ciByZXF1ZXN0cyB0byB0aGUgcmVsYXRpdmUgVVJJIGFyZSB0aW1pbmcgb3V0LCB5b3UgY2FuIGluY3JlYXNlXG4gKiB0aGUgdmFsdWUgYnkgY29uZmlndXJpbmcgdGhlbSBkaXJlY3RseTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5FQ1NDcmVkZW50aWFscyh7XG4gKiAgIGh0dHBPcHRpb25zOiB7IHRpbWVvdXQ6IDUwMDAgfSwgLy8gNSBzZWNvbmQgdGltZW91dFxuICogICBtYXhSZXRyaWVzOiAxMCwgLy8gcmV0cnkgMTAgdGltZXNcbiAqICAgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMjAwIH0gLy8gc2VlIEFXUy5Db25maWcgZm9yIGluZm9ybWF0aW9uXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWUgQVdTLkNvbmZpZy5yZXRyeURlbGF5T3B0aW9uc1xuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5FQ1NDcmVkZW50aWFscyA9IEFXUy5SZW1vdGVDcmVkZW50aWFscztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNsYXNzIHdpbGwgbG9vayBmb3IgdGhlIG1hdGNoaW5nIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogcHJlZml4ZWQgYnkgYSBnaXZlbiB7ZW52UHJlZml4fS4gVGhlIHVuLXByZWZpeGVkIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVzXG4gKiBmb3IgZWFjaCBjcmVkZW50aWFsIHZhbHVlIGlzIGxpc3RlZCBiZWxvdzpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBhY2Nlc3NLZXlJZDogQUNDRVNTX0tFWV9JRFxuICogc2VjcmV0QWNjZXNzS2V5OiBTRUNSRVRfQUNDRVNTX0tFWVxuICogc2Vzc2lvblRva2VuOiBTRVNTSU9OX1RPS0VOXG4gKiBgYGBcbiAqXG4gKiBXaXRoIHRoZSBkZWZhdWx0IHByZWZpeCBvZiAnQVdTJywgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3b3VsZCBiZTpcbiAqXG4gKiAgICAgQVdTX0FDQ0VTU19LRVlfSUQsIEFXU19TRUNSRVRfQUNDRVNTX0tFWSwgQVdTX1NFU1NJT05fVE9LRU5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBlbnZQcmVmaXhcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHByZWZpeCBmb3IgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVzIGV4Y2x1ZGluZ1xuICogICAgIHRoZSBzZXBhcmF0aW5nIHVuZGVyc2NvcmUgKCdfJykuXG4gKi9cbkFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFbnZpcm9ubWVudENyZWRlbnRpYWxzIGNsYXNzIHdpdGggYSBnaXZlbiB2YXJpYWJsZVxuICAgKiBwcmVmaXgge2VudlByZWZpeH0uIEZvciBleGFtcGxlLCB0byBsb2FkIGNyZWRlbnRpYWxzIHVzaW5nIHRoZSAnQVdTJ1xuICAgKiBwcmVmaXg6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIGNyZWRzID0gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTtcbiAgICogY3JlZHMuYWNjZXNzS2V5SWQgPT0gJ0FLSUQnIC8vIGZyb20gQVdTX0FDQ0VTU19LRVlfSUQgZW52IHZhclxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGVudlByZWZpeCBbU3RyaW5nXSB0aGUgcHJlZml4IHRvIHVzZSAoZS5nLiwgJ0FXUycpIGZvciBlbnZpcm9ubWVudFxuICAgKiAgIHZhcmlhYmxlcy4gRG8gbm90IGluY2x1ZGUgdGhlIHNlcGFyYXRpbmcgdW5kZXJzY29yZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBFbnZpcm9ubWVudENyZWRlbnRpYWxzKGVudlByZWZpeCkge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW52UHJlZml4ID0gZW52UHJlZml4O1xuICAgIHRoaXMuZ2V0KGZ1bmN0aW9uKCkge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudCB1c2luZyB0aGUgcHJlZml4ZWRcbiAgICogZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCBhZnRlciB0aGUgKHByZWZpeGVkKSBBQ0NFU1NfS0VZX0lELCBTRUNSRVRfQUNDRVNTX0tFWSwgYW5kXG4gICAqICAgU0VTU0lPTl9UT0tFTiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHJlYWQuIFdoZW4gdGhpcyBjYWxsYmFjayBpc1xuICAgKiAgIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXNcbiAgICogICBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCxcbiAgICogICBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBBV1MudXRpbC5mbi5jYWxsYmFjaztcblxuICAgIGlmICghcHJvY2VzcyB8fCAhcHJvY2Vzcy5lbnYpIHtcbiAgICAgIGNhbGxiYWNrKEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ05vIHByb2Nlc3MgaW5mbyBvciBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXZhaWxhYmxlJyksXG4gICAgICAgIHsgY29kZTogJ0Vudmlyb25tZW50Q3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gWydBQ0NFU1NfS0VZX0lEJywgJ1NFQ1JFVF9BQ0NFU1NfS0VZJywgJ1NFU1NJT05fVE9LRU4nXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcmVmaXggPSAnJztcbiAgICAgIGlmICh0aGlzLmVudlByZWZpeCkgcHJlZml4ID0gdGhpcy5lbnZQcmVmaXggKyAnXyc7XG4gICAgICB2YWx1ZXNbaV0gPSBwcm9jZXNzLmVudltwcmVmaXggKyBrZXlzW2ldXTtcbiAgICAgIGlmICghdmFsdWVzW2ldICYmIGtleXNbaV0gIT09ICdTRVNTSU9OX1RPS0VOJykge1xuICAgICAgICBjYWxsYmFjayhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ1ZhcmlhYmxlICcgKyBwcmVmaXggKyBrZXlzW2ldICsgJyBub3Qgc2V0LicpLFxuICAgICAgICB7IGNvZGU6ICdFbnZpcm9ubWVudENyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJyB9XG4gICAgICAgICkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyBmcm9tIGEgSlNPTiBmaWxlIG9uIGRpc2suXG4gKiBJZiB0aGUgY3JlZGVudGlhbHMgZXhwaXJlLCB0aGUgU0RLIGNhbiB7cmVmcmVzaH0gdGhlIGNyZWRlbnRpYWxzXG4gKiBmcm9tIHRoZSBmaWxlLlxuICpcbiAqIFRoZSBmb3JtYXQgb2YgdGhlIGZpbGUgc2hvdWxkIGJlIHNpbWlsYXIgdG8gdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG4gKiB7QVdTLkNvbmZpZ306XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICoge2FjY2Vzc0tleUlkOiAnYWtpZCcsIHNlY3JldEFjY2Vzc0tleTogJ3NlY3JldCcsIHNlc3Npb25Ub2tlbjogJ29wdGlvbmFsJ31cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIExvYWRpbmcgY3JlZGVudGlhbHMgZnJvbSBkaXNrXG4gKiAgIHZhciBjcmVkcyA9IG5ldyBBV1MuRmlsZVN5c3RlbUNyZWRlbnRpYWxzKCcuL2NvbmZpZ3VyYXRpb24uanNvbicpO1xuICogICBjcmVkcy5hY2Nlc3NLZXlJZCA9PSAnQUtJRCdcbiAqXG4gKiBAIWF0dHJpYnV0ZSBmaWxlbmFtZVxuICogICBAcmVhZG9ubHlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcGF0aCB0byB0aGUgSlNPTiBmaWxlIG9uIGRpc2sgY29udGFpbmluZyB0aGVcbiAqICAgICBjcmVkZW50aWFscy5cbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5GaWxlU3lzdGVtQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscyhmaWxlbmFtZSlcbiAgICogICBDcmVhdGVzIGEgbmV3IEZpbGVTeXN0ZW1DcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIGZpbGVuYW1lXG4gICAqXG4gICAqICAgQHBhcmFtIGZpbGVuYW1lIFtTdHJpbmddIHRoZSBwYXRoIG9uIGRpc2sgdG8gdGhlIEpTT04gZmlsZSB0byBsb2FkLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEZpbGVTeXN0ZW1DcmVkZW50aWFscyhmaWxlbmFtZSkge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICB0aGlzLmdldChmdW5jdGlvbigpIHt9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIHtmaWxlbmFtZX0gb24gZGlzay5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgYWZ0ZXIgdGhlIEpTT04gZmlsZSBvbiBkaXNrIGlzIHJlYWQgYW5kIHBhcnNlZC4gV2hlbiB0aGlzIGNhbGxiYWNrXG4gICAqICAgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uXG4gICAqICAgaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLFxuICAgKiAgIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IEFXUy51dGlsLmZuLmNhbGxiYWNrO1xuICAgIHRyeSB7XG4gICAgICB2YXIgY3JlZHMgPSBKU09OLnBhcnNlKEFXUy51dGlsLnJlYWRGaWxlU3luYyh0aGlzLmZpbGVuYW1lKSk7XG4gICAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzLCBjcmVkcyk7XG4gICAgICBpZiAoIXRoaXMuYWNjZXNzS2V5SWQgfHwgIXRoaXMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignQ3JlZGVudGlhbHMgbm90IHNldCBpbiAnICsgdGhpcy5maWxlbmFtZSksXG4gICAgICAgIHsgY29kZTogJ0ZpbGVTeXN0ZW1DcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHByb2MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG52YXIgaW5pTG9hZGVyID0gQVdTLnV0aWwuaW5pTG9hZGVyO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgbG9hZGVkIGZyb20gc2hhcmVkIGNyZWRlbnRpYWxzIGZpbGVcbiAqIChkZWZhdWx0aW5nIHRvIH4vLmF3cy9jcmVkZW50aWFscyBvciBkZWZpbmVkIGJ5IHRoZVxuICogYEFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRWAgZW52aXJvbm1lbnQgdmFyaWFibGUpLlxuICpcbiAqICMjIFVzaW5nIHByb2Nlc3MgY3JlZGVudGlhbHNcbiAqXG4gKiBUaGUgY3JlZGVudGlhbHMgZmlsZSBjYW4gc3BlY2lmeSBhIGNyZWRlbnRpYWwgcHJvdmlkZXIgdGhhdCBleGVjdXRlc1xuICogYSBnaXZlbiBwcm9jZXNzIGFuZCBhdHRlbXB0cyB0byByZWFkIGl0cyBzdGRvdXQgdG8gcmVjaWV2ZSBhIEpTT04gcGF5bG9hZFxuICogY29udGFpbmluZyB0aGUgY3JlZGVudGlhbHM6XG4gKlxuICogICAgIFtkZWZhdWx0XVxuICogICAgIGNyZWRlbnRpYWxfcHJvY2VzcyA9IC91c3IvYmluL2NyZWRlbnRpYWxfcHJvY1xuICpcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyByZWZyZXNoaW5nIGNyZWRlbnRpYWxzIGlmIGFuIEV4cGlyYXRpb24gdGltZSBpc1xuICogcHJvdmlkZWQgaW4gdGhlIGNyZWRlbnRpYWxzIHBheWxvYWQuIENyZWRlbnRpYWxzIHN1cHBsaWVkIGluIHRoZSBzYW1lIHByb2ZpbGVcbiAqIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhlIGNyZWRlbnRpYWxfcHJvY2Vzcy5cbiAqXG4gKiBTb3VyY2luZyBjcmVkZW50aWFscyBmcm9tIGFuIGV4dGVybmFsIHByb2Nlc3MgY2FuIHBvdGVudGlhbGx5IGJlIGRhbmdlcm91cyxcbiAqIHNvIHByb2NlZWQgd2l0aCBjYXV0aW9uLiBPdGhlciBjcmVkZW50aWFsIHByb3ZpZGVycyBzaG91bGQgYmUgcHJlZmVycmVkIGlmXG4gKiBhdCBhbGwgcG9zc2libGUuIElmIHVzaW5nIHRoaXMgb3B0aW9uLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0aGF0IHRoZSBzaGFyZWRcbiAqIGNyZWRlbnRpYWxzIGZpbGUgaXMgYXMgbG9ja2VkIGRvd24gYXMgcG9zc2libGUgdXNpbmcgc2VjdXJpdHkgYmVzdCBwcmFjdGljZXNcbiAqIGZvciB5b3VyIG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogIyMgVXNpbmcgY3VzdG9tIHByb2ZpbGVzXG4gKlxuICogVGhlIFNESyBzdXBwb3J0cyBsb2FkaW5nIGNyZWRlbnRpYWxzIGZvciBzZXBhcmF0ZSBwcm9maWxlcy4gVGhpcyBjYW4gYmUgZG9uZVxuICogaW4gdHdvIHdheXM6XG4gKlxuICogMS4gU2V0IHRoZSBgQVdTX1BST0ZJTEVgIGVudmlyb25tZW50IHZhcmlhYmxlIGluIHlvdXIgcHJvY2VzcyBwcmlvciB0b1xuICogICAgbG9hZGluZyB0aGUgU0RLLlxuICogMi4gRGlyZWN0bHkgbG9hZCB0aGUgQVdTLlByb2Nlc3NDcmVkZW50aWFscyBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgY3JlZHMgPSBuZXcgQVdTLlByb2Nlc3NDcmVkZW50aWFscyh7cHJvZmlsZTogJ215cHJvZmlsZSd9KTtcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAqIGBgYFxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5Qcm9jZXNzQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQcm9jZXNzQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXSBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwcm9maWxlIFtTdHJpbmddIChBV1NfUFJPRklMRSBlbnYgdmFyIG9yICdkZWZhdWx0JylcbiAgICogICB0aGUgbmFtZSBvZiB0aGUgcHJvZmlsZSB0byBsb2FkLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZmlsZW5hbWUgW1N0cmluZ10gKCd+Ly5hd3MvY3JlZGVudGlhbHMnIG9yIGRlZmluZWQgYnlcbiAgICogICBBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgcHJvY2VzcyBlbnYgdmFyKVxuICAgKiAgIHRoZSBmaWxlbmFtZSB0byB1c2Ugd2hlbiBsb2FkaW5nIGNyZWRlbnRpYWxzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY2FsbGJhY2sgW0Z1bmN0aW9uXSAoZXJyKSBDcmVkZW50aWFscyBhcmUgZWFnZXJseSBsb2FkZWRcbiAgICogICBieSB0aGUgY29uc3RydWN0b3IuIFdoZW4gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCB0aGVcbiAgICogICBjcmVkZW50aWFscyBoYXZlIGJlZW4gbG9hZGVkIHN1Y2Nlc3NmdWxseS5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBQcm9jZXNzQ3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICB0aGlzLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGU7XG4gICAgdGhpcy5nZXQob3B0aW9ucy5jYWxsYmFjayB8fCBBV1MudXRpbC5mbi5ub29wKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoaW5pTG9hZGVyLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgIHZhciBwcm9maWxlID0gcHJvZmlsZXNbdGhpcy5wcm9maWxlXSB8fCB7fTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHByb2ZpbGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ1Byb2ZpbGUgJyArIHRoaXMucHJvZmlsZSArICcgbm90IGZvdW5kJyksXG4gICAgICAgICAgeyBjb2RlOiAnUHJvY2Vzc0NyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJyB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9maWxlWydjcmVkZW50aWFsX3Byb2Nlc3MnXSkge1xuICAgICAgICB0aGlzLmxvYWRWaWFDcmVkZW50aWFsUHJvY2Vzcyhwcm9maWxlLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmV4cGlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuYWNjZXNzS2V5SWQgPSBkYXRhLkFjY2Vzc0tleUlkO1xuICAgICAgICAgICAgc2VsZi5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLlNlY3JldEFjY2Vzc0tleTtcbiAgICAgICAgICAgIHNlbGYuc2Vzc2lvblRva2VuID0gZGF0YS5TZXNzaW9uVG9rZW47XG4gICAgICAgICAgICBpZiAoZGF0YS5FeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICAgIHNlbGYuZXhwaXJlVGltZSA9IG5ldyBEYXRlKGRhdGEuRXhwaXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdQcm9maWxlICcgKyB0aGlzLnByb2ZpbGUgKyAnIGRpZCBub3QgaW5jbHVkZSBjcmVkZW50aWFsIHByb2Nlc3MnKSxcbiAgICAgICAgICB7IGNvZGU6ICdQcm9jZXNzQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEV4ZWN1dGVzIHRoZSBjcmVkZW50aWFsX3Byb2Nlc3MgYW5kIHJldHJpZXZlc1xuICAqIGNyZWRlbnRpYWxzIGZyb20gdGhlIG91dHB1dFxuICAqIEBhcGkgcHJpdmF0ZVxuICAqIEBwYXJhbSBwcm9maWxlIFttYXBdIGNyZWRlbnRpYWxzIHByb2ZpbGVcbiAgKiBAdGhyb3dzIFByb2Nlc3NDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZVxuICAqL1xuICBsb2FkVmlhQ3JlZGVudGlhbFByb2Nlc3M6IGZ1bmN0aW9uIGxvYWRWaWFDcmVkZW50aWFsUHJvY2Vzcyhwcm9maWxlLCBjYWxsYmFjaykge1xuICAgIHByb2MuZXhlYyhwcm9maWxlWydjcmVkZW50aWFsX3Byb2Nlc3MnXSwgeyBlbnY6IHByb2Nlc3MuZW52IH0sIGZ1bmN0aW9uKGVyciwgc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCdjcmVkZW50aWFsX3Byb2Nlc3MgcmV0dXJuZWQgZXJyb3InKSxcbiAgICAgICAgICB7IGNvZGU6ICdQcm9jZXNzQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnfVxuICAgICAgICApLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNyZWREYXRhID0gSlNPTi5wYXJzZShzdGRPdXQpO1xuICAgICAgICAgIGlmIChjcmVkRGF0YS5FeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBleHBpcmVUaW1lID0gbmV3IERhdGUoY3JlZERhdGEuRXhwaXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZXhwaXJlVGltZSA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdjcmVkZW50aWFsX3Byb2Nlc3MgcmV0dXJuZWQgZXhwaXJlZCBjcmVkZW50aWFscycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjcmVkRGF0YS5WZXJzaW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignY3JlZGVudGlhbF9wcm9jZXNzIGRvZXMgbm90IHJldHVybiBWZXJzaW9uID09IDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgY3JlZERhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgIG5ldyBFcnJvcihlcnIubWVzc2FnZSksXG4gICAgICAgICAgICB7IGNvZGU6ICdQcm9jZXNzQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnfVxuICAgICAgICAgICksIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSBjcmVkZW50aWFsIHByb2Nlc3NcbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgYWZ0ZXIgdGhlIGNyZWRlbnRpYWwgcHJvY2VzcyBoYXMgYmVlbiBleGVjdXRlZC4gV2hlbiB0aGlzXG4gICAqICAgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICBpbmlMb2FkZXIuY2xlYXJDYWNoZWRGaWxlcygpO1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpLFxuICBFTlZfUkVMQVRJVkVfVVJJID0gJ0FXU19DT05UQUlORVJfQ1JFREVOVElBTFNfUkVMQVRJVkVfVVJJJyxcbiAgRU5WX0ZVTExfVVJJID0gJ0FXU19DT05UQUlORVJfQ1JFREVOVElBTFNfRlVMTF9VUkknLFxuICBFTlZfQVVUSF9UT0tFTiA9ICdBV1NfQ09OVEFJTkVSX0FVVEhPUklaQVRJT05fVE9LRU4nLFxuICBGVUxMX1VSSV9VTlJFU1RSSUNURURfUFJPVE9DT0xTID0gWydodHRwczonXSxcbiAgRlVMTF9VUklfQUxMT1dFRF9QUk9UT0NPTFMgPSBbJ2h0dHA6JywgJ2h0dHBzOiddLFxuICBGVUxMX1VSSV9BTExPV0VEX0hPU1ROQU1FUyA9IFsnbG9jYWxob3N0JywgJzEyNy4wLjAuMSddLFxuICBSRUxBVElWRV9VUklfSE9TVCA9ICcxNjkuMjU0LjE3MC4yJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJlY2VpdmVkIGZyb20gc3BlY2lmaWVkIFVSSS5cbiAqXG4gKiBUaGlzIGNsYXNzIHdpbGwgcmVxdWVzdCByZWZyZXNoYWJsZSBjcmVkZW50aWFscyBmcm9tIHRoZSByZWxhdGl2ZSBVUklcbiAqIHNwZWNpZmllZCBieSB0aGUgQVdTX0NPTlRBSU5FUl9DUkVERU5USUFMU19SRUxBVElWRV9VUkkgb3IgdGhlXG4gKiBBV1NfQ09OVEFJTkVSX0NSRURFTlRJQUxTX0ZVTExfVVJJIGVudmlyb25tZW50IHZhcmlhYmxlLiBJZiB2YWxpZCBjcmVkZW50aWFsc1xuICogYXJlIHJldHVybmVkIGluIHRoZSByZXNwb25zZSwgdGhlc2Ugd2lsbCBiZSB1c2VkIHdpdGggemVybyBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoaXMgY3JlZGVudGlhbHMgY2xhc3Mgd2lsbCBieSBkZWZhdWx0IHRpbWVvdXQgYWZ0ZXIgMSBzZWNvbmQgb2YgaW5hY3Rpdml0eVxuICogYW5kIHJldHJ5IDMgdGltZXMuXG4gKiBJZiB5b3VyIHJlcXVlc3RzIHRvIHRoZSByZWxhdGl2ZSBVUkkgYXJlIHRpbWluZyBvdXQsIHlvdSBjYW4gaW5jcmVhc2VcbiAqIHRoZSB2YWx1ZSBieSBjb25maWd1cmluZyB0aGVtIGRpcmVjdGx5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlJlbW90ZUNyZWRlbnRpYWxzKHtcbiAqICAgaHR0cE9wdGlvbnM6IHsgdGltZW91dDogNTAwMCB9LCAvLyA1IHNlY29uZCB0aW1lb3V0XG4gKiAgIG1heFJldHJpZXM6IDEwLCAvLyByZXRyeSAxMCB0aW1lc1xuICogICByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiAyMDAgfSAvLyBzZWUgQVdTLkNvbmZpZyBmb3IgaW5mb3JtYXRpb25cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlZSBBV1MuQ29uZmlnLnJldHJ5RGVsYXlPcHRpb25zXG4gKlxuICogQCFtYWNybyBub2Jyb3dzZXJcbiAqL1xuQVdTLlJlbW90ZUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlbW90ZUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IEFXUy51dGlsLmNvcHkob3B0aW9ucykgOiB7fTtcbiAgICBpZiAoIW9wdGlvbnMuaHR0cE9wdGlvbnMpIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zLmh0dHBPcHRpb25zID0gQVdTLnV0aWwubWVyZ2UoXG4gICAgICB0aGlzLmh0dHBPcHRpb25zLCBvcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICBBV1MudXRpbC51cGRhdGUodGhpcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaHR0cE9wdGlvbnM6IHsgdGltZW91dDogMTAwMCB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1heFJldHJpZXM6IDMsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNDb25maWd1cmVkRm9yRWNzQ3JlZGVudGlhbHM6IGZ1bmN0aW9uIGlzQ29uZmlndXJlZEZvckVjc0NyZWRlbnRpYWxzKCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgICBwcm9jZXNzICYmXG4gICAgICAgIHByb2Nlc3MuZW52ICYmXG4gICAgICAgIChwcm9jZXNzLmVudltFTlZfUkVMQVRJVkVfVVJJXSB8fCBwcm9jZXNzLmVudltFTlZfRlVMTF9VUkldKVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RUNTRnVsbFVyaTogZnVuY3Rpb24gZ2V0RUNTRnVsbFVyaSgpIHtcbiAgICBpZiAocHJvY2VzcyAmJiBwcm9jZXNzLmVudikge1xuICAgICAgdmFyIHJlbGF0aXZlID0gcHJvY2Vzcy5lbnZbRU5WX1JFTEFUSVZFX1VSSV0sXG4gICAgICAgICAgZnVsbCA9IHByb2Nlc3MuZW52W0VOVl9GVUxMX1VSSV07XG4gICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuICdodHRwOi8vJyArIFJFTEFUSVZFX1VSSV9IT1NUICsgcmVsYXRpdmU7XG4gICAgICB9IGVsc2UgaWYgKGZ1bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IEFXUy51dGlsLnVybFBhcnNlKGZ1bGwpO1xuICAgICAgICBpZiAoRlVMTF9VUklfQUxMT1dFRF9QUk9UT0NPTFMuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpIDwgMCkge1xuICAgICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbDogIEFXUy5SZW1vdGVDcmVkZW50aWFscyBzdXBwb3J0cyAnXG4gICAgICAgICAgICAgICsgRlVMTF9VUklfQUxMT1dFRF9QUk9UT0NPTFMuam9pbignLCcpICsgJyBvbmx5OyAnXG4gICAgICAgICAgICAgICsgcGFyc2VkLnByb3RvY29sICsgJyByZXF1ZXN0ZWQuJyksXG4gICAgICAgICAgICB7IGNvZGU6ICdFQ1NDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRlVMTF9VUklfVU5SRVNUUklDVEVEX1BST1RPQ09MUy5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPCAwICYmXG4gICAgICAgICAgICBGVUxMX1VSSV9BTExPV0VEX0hPU1ROQU1FUy5pbmRleE9mKHBhcnNlZC5ob3N0bmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGhvc3RuYW1lOiBBV1MuUmVtb3RlQ3JlZGVudGlhbHMgb25seSBzdXBwb3J0cyAnXG4gICAgICAgICAgICAgICsgRlVMTF9VUklfQUxMT1dFRF9IT1NUTkFNRVMuam9pbignLCcpICsgJyBmb3IgJyArIHBhcnNlZC5wcm90b2NvbCArICc7ICdcbiAgICAgICAgICAgICAgKyBwYXJzZWQucHJvdG9jb2wgKyAnLy8nICsgcGFyc2VkLmhvc3RuYW1lICsgJyByZXF1ZXN0ZWQuJyksXG4gICAgICAgICAgICB7IGNvZGU6ICdFQ1NDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignVmFyaWFibGUgJyArIEVOVl9SRUxBVElWRV9VUkkgKyAnIG9yICcgKyBFTlZfRlVMTF9VUkkgK1xuICAgICAgICAgICAgJyBtdXN0IGJlIHNldCB0byB1c2UgQVdTLlJlbW90ZUNyZWRlbnRpYWxzLicpLFxuICAgICAgICAgIHsgY29kZTogJ0VDU0NyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJyB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ05vIHByb2Nlc3MgaW5mbyBhdmFpbGFibGUnKSxcbiAgICAgICAgeyBjb2RlOiAnRUNTQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldEVDU0F1dGhUb2tlbjogZnVuY3Rpb24gZ2V0RUNTQXV0aFRva2VuKCkge1xuICAgIGlmIChwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52W0VOVl9GVUxMX1VSSV0pIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudltFTlZfQVVUSF9UT0tFTl07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWRzRm9ybWF0SXNWYWxpZDogZnVuY3Rpb24gY3JlZHNGb3JtYXRJc1ZhbGlkKGNyZWREYXRhKSB7XG4gICAgcmV0dXJuICghIWNyZWREYXRhLmFjY2Vzc0tleUlkICYmICEhY3JlZERhdGEuc2VjcmV0QWNjZXNzS2V5ICYmXG4gICAgICAhIWNyZWREYXRhLnNlc3Npb25Ub2tlbiAmJiAhIWNyZWREYXRhLmV4cGlyZVRpbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZvcm1hdENyZWRzOiBmdW5jdGlvbiBmb3JtYXRDcmVkcyhjcmVkRGF0YSkge1xuICAgIGlmICghIWNyZWREYXRhLmNyZWRlbnRpYWxzKSB7XG4gICAgICBjcmVkRGF0YSA9IGNyZWREYXRhLmNyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHBpcmVkOiBmYWxzZSxcbiAgICAgIGFjY2Vzc0tleUlkOiBjcmVkRGF0YS5hY2Nlc3NLZXlJZCB8fCBjcmVkRGF0YS5BY2Nlc3NLZXlJZCxcbiAgICAgIHNlY3JldEFjY2Vzc0tleTogY3JlZERhdGEuc2VjcmV0QWNjZXNzS2V5IHx8IGNyZWREYXRhLlNlY3JldEFjY2Vzc0tleSxcbiAgICAgIHNlc3Npb25Ub2tlbjogY3JlZERhdGEuc2Vzc2lvblRva2VuIHx8IGNyZWREYXRhLlRva2VuLFxuICAgICAgZXhwaXJlVGltZTogbmV3IERhdGUoY3JlZERhdGEuZXhwaXJhdGlvbiB8fCBjcmVkRGF0YS5FeHBpcmF0aW9uKVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IEFXUy5IdHRwUmVxdWVzdCh1cmwpO1xuICAgIGh0dHBSZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnO1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnMuQWNjZXB0ID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIHZhciB0b2tlbiA9IHRoaXMuZ2V0RUNTQXV0aFRva2VuKCk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSB0b2tlbjtcbiAgICB9XG4gICAgQVdTLnV0aWwuaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzKGh0dHBSZXF1ZXN0LCB0aGlzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSByZWxhdGl2ZSBVUkkgc3BlY2lmaWVkIGJ5IGNvbnRhaW5lclxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHRvIHRoZSByZWxhdGl2ZSBVUkkgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGBzZXNzaW9uVG9rZW5gLCBhbmQgYGV4cGlyZVRpbWVgIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmdWxsVXJpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZ1bGxVcmkgPSB0aGlzLmdldEVDU0Z1bGxVcmkoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0KGZ1bGxVcmksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICB2YXIgY3JlZHMgPSBzZWxmLmZvcm1hdENyZWRzKGRhdGEpO1xuICAgICAgICAgIGlmICghc2VsZi5jcmVkc0Zvcm1hdElzVmFsaWQoY3JlZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdSZXNwb25zZSBkYXRhIGlzIG5vdCBpbiB2YWxpZCBmb3JtYXQnKSxcbiAgICAgICAgICAgICAgeyBjb2RlOiAnRUNTQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEFXUy51dGlsLnVwZGF0ZShzZWxmLCBjcmVkcyk7XG4gICAgICAgIH0gY2F0Y2ggKGRhdGFFcnJvcikge1xuICAgICAgICAgIGVyciA9IGRhdGFFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyLCBjcmVkcyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20gU1RTIFNBTUwgc3VwcG9ydC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH0gc2VydmljZSBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uXG4gKiByZXF1aXJlcyBhIGBSb2xlQXJuYCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdCBwb2xpY3kgZm9yIHRoZVxuICogYXBwbGljYXRpb24gZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHdpbGwgYmUgZ2l2ZW4sIGFzIHdlbGwgYXMgYSBgUHJpbmNpcGFsQXJuYFxuICogcmVwcmVzZW50aW5nIHRoZSBBUk4gZm9yIHRoZSBTQU1MIGlkZW50aXR5IHByb3ZpZGVyLiBJbiBhZGRpdGlvbiwgdGhlXG4gKiBgU0FNTEFzc2VydGlvbmAgbXVzdCBiZSBzZXQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBpZGVudGl0eVxuICogcHJvdmlkZXIuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBgUm9sZUFybmAsIGBQcmluY2lwYWxBcm5gLCBhbmQgYFNBTUxBc3NlcnRpb25gIHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBTQU1MQXNzZXJ0aW9uLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuU0FNTEFzc2VydGlvbiA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUx9LiBUbyB1cGRhdGUgdGhlIHRva2VuLCBzZXQgdGhlXG4gKiAgICAgYHBhcmFtcy5TQU1MQXNzZXJ0aW9uYCBwcm9wZXJ0eS5cbiAqL1xuQVdTLlNBTUxDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQHBhcmFtIChzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUwpXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlNBTUxDcmVkZW50aWFscyh7XG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9TQU1MUm9sZScsXG4gICAqICAgICBQcmluY2lwYWxBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1NBTUxQcmluY2lwYWwnLFxuICAgKiAgICAgU0FNTEFzc2VydGlvbjogJ2Jhc2U2NC10b2tlbicsIC8vIGJhc2U2NC1lbmNvZGVkIHRva2VuIGZyb20gSWRQXG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUxcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTQU1MQ3JlZGVudGlhbHMocGFyYW1zKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH1cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZVdpdGhTQU1MKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG52YXIgaW5pTG9hZGVyID0gQVdTLnV0aWwuaW5pTG9hZGVyO1xuXG52YXIgQVNTVU1FX1JPTEVfREVGQVVMVF9SRUdJT04gPSAndXMtZWFzdC0xJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIGxvYWRlZCBmcm9tIHNoYXJlZCBjcmVkZW50aWFscyBmaWxlXG4gKiAoZGVmYXVsdGluZyB0byB+Ly5hd3MvY3JlZGVudGlhbHMgb3IgZGVmaW5lZCBieSB0aGVcbiAqIGBBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEVgIGVudmlyb25tZW50IHZhcmlhYmxlKS5cbiAqXG4gKiAjIyBVc2luZyB0aGUgc2hhcmVkIGNyZWRlbnRpYWxzIGZpbGVcbiAqXG4gKiBUaGlzIHByb3ZpZGVyIGlzIGNoZWNrZWQgYnkgZGVmYXVsdCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudC4gVG8gdXNlIHRoZVxuICogY3JlZGVudGlhbHMgZmlsZSBwcm92aWRlciwgc2ltcGx5IGFkZCB5b3VyIGFjY2VzcyBhbmQgc2VjcmV0IGtleXMgdG8gdGhlXG4gKiB+Ly5hd3MvY3JlZGVudGlhbHMgZmlsZSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAqXG4gKiAgICAgW2RlZmF1bHRdXG4gKiAgICAgYXdzX2FjY2Vzc19rZXlfaWQgPSBBS0lELi4uXG4gKiAgICAgYXdzX3NlY3JldF9hY2Nlc3Nfa2V5ID0gWU9VUl9TRUNSRVRfS0VZXG4gKlxuICogIyMgVXNpbmcgY3VzdG9tIHByb2ZpbGVzXG4gKlxuICogVGhlIFNESyBzdXBwb3J0cyBsb2FkaW5nIGNyZWRlbnRpYWxzIGZvciBzZXBhcmF0ZSBwcm9maWxlcy4gVGhpcyBjYW4gYmUgZG9uZVxuICogaW4gdHdvIHdheXM6XG4gKlxuICogMS4gU2V0IHRoZSBgQVdTX1BST0ZJTEVgIGVudmlyb25tZW50IHZhcmlhYmxlIGluIHlvdXIgcHJvY2VzcyBwcmlvciB0b1xuICogICAgbG9hZGluZyB0aGUgU0RLLlxuICogMi4gRGlyZWN0bHkgbG9hZCB0aGUgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgY3JlZHMgPSBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyh7cHJvZmlsZTogJ215cHJvZmlsZSd9KTtcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAqIGBgYFxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXSBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwcm9maWxlIFtTdHJpbmddIChBV1NfUFJPRklMRSBlbnYgdmFyIG9yICdkZWZhdWx0JylcbiAgICogICB0aGUgbmFtZSBvZiB0aGUgcHJvZmlsZSB0byBsb2FkLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZmlsZW5hbWUgW1N0cmluZ10gKCd+Ly5hd3MvY3JlZGVudGlhbHMnIG9yIGRlZmluZWQgYnlcbiAgICogICBBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgcHJvY2VzcyBlbnYgdmFyKVxuICAgKiAgIHRoZSBmaWxlbmFtZSB0byB1c2Ugd2hlbiBsb2FkaW5nIGNyZWRlbnRpYWxzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZGlzYWJsZUFzc3VtZVJvbGUgW0Jvb2xlYW5dIChmYWxzZSkgVHJ1ZSB0byBkaXNhYmxlXG4gICAqICAgc3VwcG9ydCBmb3IgcHJvZmlsZXMgdGhhdCBhc3N1bWUgYW4gSUFNIHJvbGUuIElmIHRydWUsIGFuZCBhbiBhc3N1bWVcbiAgICogICByb2xlIHByb2ZpbGUgaXMgc2VsZWN0ZWQsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHByZWZlclN0YXRpY0NyZWRlbnRpYWxzIFtCb29sZWFuXSAoZmFsc2UpIFRydWUgdG9cbiAgICogICBwcmVmZXIgc3RhdGljIGNyZWRlbnRpYWxzIHRvIHJvbGVfYXJuIGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB0b2tlbkNvZGVGbiBbRnVuY3Rpb25dIChudWxsKSBGdW5jdGlvbiB0byBwcm92aWRlXG4gICAqICAgU1RTIEFzc3VtZSBSb2xlIFRva2VuQ29kZSwgaWYgbWZhX3NlcmlhbCBpcyBwcm92aWRlZCBmb3IgcHJvZmlsZSBpbiBpbmlcbiAgICogICBmaWxlLiBGdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB2YWx1ZSBvZiBtZmFfc2VyaWFsIGFuZCBjYWxsYmFjaywgYW5kXG4gICAqICAgc2hvdWxkIHByb3ZpZGUgdGhlIFRva2VuQ29kZSBvciBhbiBlcnJvciB0byB0aGUgY2FsbGJhY2sgaW4gdGhlIGZvcm1hdFxuICAgKiAgIGNhbGxiYWNrKGVyciwgdG9rZW4pXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjYWxsYmFjayBbRnVuY3Rpb25dIChlcnIpIENyZWRlbnRpYWxzIGFyZSBlYWdlcmx5IGxvYWRlZFxuICAgKiAgIGJ5IHRoZSBjb25zdHJ1Y3Rvci4gV2hlbiB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIHRoZVxuICAgKiAgIGNyZWRlbnRpYWxzIGhhdmUgYmVlbiBsb2FkZWQgc3VjY2Vzc2Z1bGx5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaHR0cE9wdGlvbnMgW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBsb3ctbGV2ZWxcbiAgICogICBIVFRQIHJlcXVlc3QuIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAqICAgKiAqKnByb3h5KiogW1N0cmluZ10gJm1kYXNoOyB0aGUgVVJMIHRvIHByb3h5IHJlcXVlc3RzIHRocm91Z2hcbiAgICogICAqICoqYWdlbnQqKiBbaHR0cC5BZ2VudCwgaHR0cHMuQWdlbnRdICZtZGFzaDsgdGhlIEFnZW50IG9iamVjdCB0byBwZXJmb3JtXG4gICAqICAgICBIVFRQIHJlcXVlc3RzIHdpdGguIFVzZWQgZm9yIGNvbm5lY3Rpb24gcG9vbGluZy4gRGVmYXVsdHMgdG8gdGhlIGdsb2JhbFxuICAgKiAgICAgYWdlbnQgKGBodHRwLmdsb2JhbEFnZW50YCkgZm9yIG5vbi1TU0wgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBmb3JcbiAgICogICAgIFNTTCBjb25uZWN0aW9ucywgYSBzcGVjaWFsIEFnZW50IG9iamVjdCBpcyB1c2VkIGluIG9yZGVyIHRvIGVuYWJsZVxuICAgKiAgICAgcGVlciBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24uIFRoaXMgZmVhdHVyZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGVcbiAgICogICAgIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAqICAgKiAqKmNvbm5lY3RUaW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXJcbiAgICogICAgIGZhaWxpbmcgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgYWZ0ZXJcbiAgICogICAgIGBjb25uZWN0VGltZW91dGAgbWlsbGlzZWNvbmRzLiBUaGlzIHRpbWVvdXQgaGFzIG5vIGVmZmVjdCBvbmNlIGEgc29ja2V0XG4gICAqICAgICBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgKiAgICogKip0aW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhblxuICAgKiAgICAgdGFrZSBiZWZvcmUgYXV0b21hdGljYWxseSBiZWluZyB0ZXJtaW5hdGVkLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gdHdvIG1pbnV0ZXMgKDEyMDAwMCkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5maWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgdGhpcy5wcm9maWxlID0gb3B0aW9ucy5wcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlO1xuICAgIHRoaXMuZGlzYWJsZUFzc3VtZVJvbGUgPSBCb29sZWFuKG9wdGlvbnMuZGlzYWJsZUFzc3VtZVJvbGUpO1xuICAgIHRoaXMucHJlZmVyU3RhdGljQ3JlZGVudGlhbHMgPSBCb29sZWFuKG9wdGlvbnMucHJlZmVyU3RhdGljQ3JlZGVudGlhbHMpO1xuICAgIHRoaXMudG9rZW5Db2RlRm4gPSBvcHRpb25zLnRva2VuQ29kZUZuIHx8IG51bGw7XG4gICAgdGhpcy5odHRwT3B0aW9ucyA9IG9wdGlvbnMuaHR0cE9wdGlvbnMgfHwgbnVsbDtcbiAgICB0aGlzLmdldChvcHRpb25zLmNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLm5vb3ApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm9maWxlcyA9IEFXUy51dGlsLmdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhpbmlMb2FkZXIsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgdmFyIHByb2ZpbGUgPSBwcm9maWxlc1t0aGlzLnByb2ZpbGVdIHx8IHt9O1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMocHJvZmlsZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignUHJvZmlsZSAnICsgdGhpcy5wcm9maWxlICsgJyBub3QgZm91bmQnKSxcbiAgICAgICAgICB7IGNvZGU6ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEluIHRoZSBDTEksIHRoZSBwcmVzZW5jZSBvZiBib3RoIGEgcm9sZV9hcm4gYW5kIHN0YXRpYyBjcmVkZW50aWFscyBoYXZlXG4gICAgICBkaWZmZXJlbnQgbWVhbmluZ3MgZGVwZW5kaW5nIG9uIGhvdyBtYW55IHByb2ZpbGVzIGhhdmUgYmVlbiB2aXNpdGVkLiBGb3JcbiAgICAgIHRoZSBmaXJzdCBwcm9maWxlIHByb2Nlc3NlZCwgcm9sZV9hcm4gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSBzdGF0aWNcbiAgICAgIGNyZWRlbnRpYWxzLCBidXQgZm9yIGFsbCBzdWJzZXF1ZW50IHByb2ZpbGVzLCBzdGF0aWMgY3JlZGVudGlhbHMgYXJlXG4gICAgICB1c2VkIGlmIHByZXNlbnQsIGFuZCBvbmx5IGluIHRoZWlyIGFic2VuY2Ugd2lsbCB0aGUgcHJvZmlsZSdzXG4gICAgICBzb3VyY2VfcHJvZmlsZSBhbmQgcm9sZV9hcm4ga2V5cyBiZSB1c2VkIHRvIGxvYWQgYW5vdGhlciBzZXQgb2ZcbiAgICAgIGNyZWRlbnRpYWxzLiBUaGlzIHZhciBpcyBpbnRlbmRlZCB0byB5aWVsZCBjb21wYXRpYmxlIGJlaGF2aW91ciBpbiB0aGlzXG4gICAgICBzZGsuXG4gICAgICAqL1xuICAgICAgdmFyIHByZWZlclN0YXRpY0NyZWRlbnRpYWxzVG9Sb2xlQXJuID0gQm9vbGVhbihcbiAgICAgICAgdGhpcy5wcmVmZXJTdGF0aWNDcmVkZW50aWFsc1xuICAgICAgICAmJiBwcm9maWxlWydhd3NfYWNjZXNzX2tleV9pZCddXG4gICAgICAgICYmIHByb2ZpbGVbJ2F3c19zZWNyZXRfYWNjZXNzX2tleSddXG4gICAgICApO1xuXG4gICAgICBpZiAocHJvZmlsZVsncm9sZV9hcm4nXSAmJiAhcHJlZmVyU3RhdGljQ3JlZGVudGlhbHNUb1JvbGVBcm4pIHtcbiAgICAgICAgdGhpcy5sb2FkUm9sZVByb2ZpbGUocHJvZmlsZXMsIHByb2ZpbGUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXhwaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5hY2Nlc3NLZXlJZCA9IGRhdGEuQ3JlZGVudGlhbHMuQWNjZXNzS2V5SWQ7XG4gICAgICAgICAgICBzZWxmLnNlY3JldEFjY2Vzc0tleSA9IGRhdGEuQ3JlZGVudGlhbHMuU2VjcmV0QWNjZXNzS2V5O1xuICAgICAgICAgICAgc2VsZi5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICAgICAgICAgIHNlbGYuZXhwaXJlVGltZSA9IGRhdGEuQ3JlZGVudGlhbHMuRXhwaXJhdGlvbjtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY2Nlc3NLZXlJZCA9IHByb2ZpbGVbJ2F3c19hY2Nlc3Nfa2V5X2lkJ107XG4gICAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IHByb2ZpbGVbJ2F3c19zZWNyZXRfYWNjZXNzX2tleSddO1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBwcm9maWxlWydhd3Nfc2Vzc2lvbl90b2tlbiddO1xuXG4gICAgICBpZiAoIXRoaXMuYWNjZXNzS2V5SWQgfHwgIXRoaXMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignQ3JlZGVudGlhbHMgbm90IHNldCBmb3IgcHJvZmlsZSAnICsgdGhpcy5wcm9maWxlKSxcbiAgICAgICAgICB7IGNvZGU6ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwaXJlZCA9IGZhbHNlO1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIHNoYXJlZCBjcmVkZW50aWFscyBmaWxlXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIGFmdGVyIHRoZSBzaGFyZWQgSU5JIGZpbGUgb24gZGlzayBpcyByZWFkIGFuZCBwYXJzZWQuIFdoZW4gdGhpc1xuICAgKiAgIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgaW5pTG9hZGVyLmNsZWFyQ2FjaGVkRmlsZXMoKTtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChcbiAgICAgIGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrLFxuICAgICAgdGhpcy5kaXNhYmxlQXNzdW1lUm9sZVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFJvbGVQcm9maWxlOiBmdW5jdGlvbiBsb2FkUm9sZVByb2ZpbGUoY3JlZHMsIHJvbGVQcm9maWxlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmRpc2FibGVBc3N1bWVSb2xlKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgbmV3IEVycm9yKCdSb2xlIGFzc3VtcHRpb24gcHJvZmlsZXMgYXJlIGRpc2FibGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gbG9hZCBwcm9maWxlICcgKyB0aGlzLnByb2ZpbGUgK1xuICAgICAgICAgICAgICAgICAgJyBmcm9tICcgKyBjcmVkcy5maWxlbmFtZSksXG4gICAgICAgIHsgY29kZTogJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJvbGVBcm4gPSByb2xlUHJvZmlsZVsncm9sZV9hcm4nXTtcbiAgICB2YXIgcm9sZVNlc3Npb25OYW1lID0gcm9sZVByb2ZpbGVbJ3JvbGVfc2Vzc2lvbl9uYW1lJ107XG4gICAgdmFyIGV4dGVybmFsSWQgPSByb2xlUHJvZmlsZVsnZXh0ZXJuYWxfaWQnXTtcbiAgICB2YXIgbWZhU2VyaWFsID0gcm9sZVByb2ZpbGVbJ21mYV9zZXJpYWwnXTtcbiAgICB2YXIgc291cmNlUHJvZmlsZU5hbWUgPSByb2xlUHJvZmlsZVsnc291cmNlX3Byb2ZpbGUnXTtcblxuICAgIC8vIEZyb20gZXhwZXJpbWVudGF0aW9uLCB0aGUgZm9sbG93aW5nIGJlaGF2aW9yIG1pbWljcyB0aGUgQVdTIENMSTpcbiAgICAvL1xuICAgIC8vIDEuIFVzZSByZWdpb24gZnJvbSB0aGUgcHJvZmlsZSBpZiBwcmVzZW50LlxuICAgIC8vIDIuIE90aGVyd2lzZSBmYWxsIGJhY2sgdG8gTi4gVmlyZ2luaWEgKGdsb2JhbCBlbmRwb2ludCkuXG4gICAgLy9cbiAgICAvLyBJdCBpcyBuZWNlc3NhcnkgdG8gZG8gdGhlIGZhbGxiYWNrIGV4cGxpY2l0bHksIGJlY2F1c2UgaWZcbiAgICAvLyAnQVdTX1NUU19SRUdJT05BTF9FTkRQT0lOVFM9cmVnaW9uYWwnLCB0aGUgdW5kZXJseWluZyBTVFMgY2xpZW50IHdpbGxcbiAgICAvLyBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IgaWYgcmVnaW9uIGlzIGxlZnQgJ3VuZGVmaW5lZCcuXG4gICAgLy9cbiAgICAvLyBFeHBlcmltZW50YXRpb24gc2hvd3MgdGhhdCB0aGUgQVdTIENMSSAodGVzdGVkIGF0IHZlcnNpb24gMS4xOC4xMzYpXG4gICAgLy8gaWdub3JlcyB0aGUgZm9sbG93aW5nIHBvdGVudGlhbCBzb3VyY2VzIG9mIGEgcmVnaW9uIGZvciB0aGUgcHVycG9zZXMgb2ZcbiAgICAvLyB0aGlzIEFzc3VtZVJvbGUgY2FsbDpcbiAgICAvL1xuICAgIC8vIC0gVGhlIFtkZWZhdWx0XSBwcm9maWxlXG4gICAgLy8gLSBUaGUgQVdTX1JFR0lPTiBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIC8vXG4gICAgLy8gSWdub3JpbmcgdGhlIFtkZWZhdWx0XSBwcm9maWxlIGZvciB0aGUgcHVycG9zZXMgb2YgQXNzdW1lUm9sZSBpcyBhcmd1YWJseVxuICAgIC8vIGEgYnVnIGluIHRoZSBDTEkgc2luY2UgaXQgZG9lcyB1c2UgdGhlIFtkZWZhdWx0XSByZWdpb24gZm9yIHNlcnZpY2VcbiAgICAvLyBjYWxscy4uLiBidXQgcmlnaHQgbm93IHdlJ3JlIG1hdGNoaW5nIGJlaGF2aW9yIG9mIHRoZSBvdGhlciB0b29sLlxuICAgIHZhciBwcm9maWxlUmVnaW9uID0gcm9sZVByb2ZpbGVbJ3JlZ2lvbiddIHx8IEFTU1VNRV9ST0xFX0RFRkFVTFRfUkVHSU9OO1xuXG4gICAgaWYgKCFzb3VyY2VQcm9maWxlTmFtZSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgIG5ldyBFcnJvcignc291cmNlX3Byb2ZpbGUgaXMgbm90IHNldCB1c2luZyBwcm9maWxlICcgKyB0aGlzLnByb2ZpbGUpLFxuICAgICAgICB7IGNvZGU6ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVByb2ZpbGVFeGlzdGFuY2VUZXN0ID0gY3JlZHNbc291cmNlUHJvZmlsZU5hbWVdO1xuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9maWxlRXhpc3RhbmNlVGVzdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ3NvdXJjZV9wcm9maWxlICcgKyBzb3VyY2VQcm9maWxlTmFtZSArICcgdXNpbmcgcHJvZmlsZSAnXG4gICAgICAgICAgKyB0aGlzLnByb2ZpbGUgKyAnIGRvZXMgbm90IGV4aXN0JyksXG4gICAgICAgIHsgY29kZTogJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlQ3JlZGVudGlhbHMgPSBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyhcbiAgICAgIEFXUy51dGlsLm1lcmdlKHRoaXMub3B0aW9ucyB8fCB7fSwge1xuICAgICAgICBwcm9maWxlOiBzb3VyY2VQcm9maWxlTmFtZSxcbiAgICAgICAgcHJlZmVyU3RhdGljQ3JlZGVudGlhbHM6IHRydWVcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMucm9sZUFybiA9IHJvbGVBcm47XG4gICAgdmFyIHN0cyA9IG5ldyBTVFMoe1xuICAgICAgY3JlZGVudGlhbHM6IHNvdXJjZUNyZWRlbnRpYWxzLFxuICAgICAgcmVnaW9uOiBwcm9maWxlUmVnaW9uLFxuICAgICAgaHR0cE9wdGlvbnM6IHRoaXMuaHR0cE9wdGlvbnNcbiAgICB9KTtcblxuICAgIHZhciByb2xlUGFyYW1zID0ge1xuICAgICAgUm9sZUFybjogcm9sZUFybixcbiAgICAgIFJvbGVTZXNzaW9uTmFtZTogcm9sZVNlc3Npb25OYW1lIHx8ICdhd3Mtc2RrLWpzLScgKyBEYXRlLm5vdygpXG4gICAgfTtcblxuICAgIGlmIChleHRlcm5hbElkKSB7XG4gICAgICByb2xlUGFyYW1zLkV4dGVybmFsSWQgPSBleHRlcm5hbElkO1xuICAgIH1cblxuICAgIGlmIChtZmFTZXJpYWwgJiYgc2VsZi50b2tlbkNvZGVGbikge1xuICAgICAgcm9sZVBhcmFtcy5TZXJpYWxOdW1iZXIgPSBtZmFTZXJpYWw7XG4gICAgICBzZWxmLnRva2VuQ29kZUZuKG1mYVNlcmlhbCwgZnVuY3Rpb24oZXJyLCB0b2tlbikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgTUZBIHRva2VuOiAnICsgbWVzc2FnZSksXG4gICAgICAgICAgICAgIHsgY29kZTogJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9sZVBhcmFtcy5Ub2tlbkNvZGUgPSB0b2tlbjtcbiAgICAgICAgc3RzLmFzc3VtZVJvbGUocm9sZVBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0cy5hc3N1bWVSb2xlKHJvbGVQYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20ge0FXUy5TVFN9LiBXaXRob3V0IGFueVxuICogZXh0cmEgcGFyYW1ldGVycywgY3JlZGVudGlhbHMgd2lsbCBiZSBmZXRjaGVkIGZyb20gdGhlXG4gKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbi4gSWYgYW4gSUFNIHJvbGUgaXMgcHJvdmlkZWQsIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3BlcmF0aW9uIHdpbGwgYmUgdXNlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiByb2xlIGluc3RlYWQuXG4gKlxuICogQG5vdGUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGlzIGRlcHJlY2F0ZWQsIGJ1dCByZW1haW5zIGF2YWlsYWJsZSBmb3JcbiAqICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIHtBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHN9IGlzIHRoZVxuICogICBwcmVmZXJyZWQgY2xhc3MgZm9yIHRlbXBvcmFyeSBjcmVkZW50aWFscy5cbiAqXG4gKiBUbyBzZXR1cCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMsIGNvbmZpZ3VyZSBhIHNldCBvZiBtYXN0ZXIgY3JlZGVudGlhbHNcbiAqIHVzaW5nIHRoZSBzdGFuZGFyZCBjcmVkZW50aWFscyBwcm92aWRlcnMgKGVudmlyb25tZW50LCBFQzIgaW5zdGFuY2UgbWV0YWRhdGEsXG4gKiBvciBmcm9tIHRoZSBmaWxlc3lzdGVtKSwgdGhlbiBzZXQgdGhlIGdsb2JhbCBjcmVkZW50aWFscyB0byBhIG5ld1xuICogdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBOb3RlIHRoYXQgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMgYXJlIGxvYWRlZCBieSBkZWZhdWx0LFxuICogLy8gdGhlIGZvbGxvd2luZyBsaW5lIGlzIHNob3duIGZvciBjbGFyaXR5OlxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7XG4gKlxuICogLy8gTm93IHNldCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgc2VlZGVkIGZyb20gdGhlIG1hc3RlciBjcmVkZW50aWFsc1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAqXG4gKiAvLyBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgbm93IHVzZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogbmV3IEFXUy5TMygpLmxpc3RCdWNrZXQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IC4uLiB9KTtcbiAqIGBgYFxuICpcbiAqIEAhYXR0cmlidXRlIG1hc3RlckNyZWRlbnRpYWxzXG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gdGhlIG1hc3RlciAobm9uLXRlbXBvcmFyeSkgY3JlZGVudGlhbHMgdXNlZCB0b1xuICogICAgIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogQG5vdGUgKHNlZSBjb25zdHJ1Y3RvcilcbiAqL1xuQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgSW4gb3JkZXIgdG8gY3JlYXRlIHRlbXBvcmFyeSBjcmVkZW50aWFscywgeW91IGZpcnN0IG5lZWQgdG8gaGF2ZVxuICAgKiAgIFwibWFzdGVyXCIgY3JlZGVudGlhbHMgY29uZmlndXJlZCBpbiB7QVdTLkNvbmZpZy5jcmVkZW50aWFsc30uIFRoZXNlXG4gICAqICAgbWFzdGVyIGNyZWRlbnRpYWxzIGFyZSBuZWNlc3NhcnkgdG8gcmV0cmlldmUgdGhlIHRlbXBvcmFyeSBjcmVkZW50aWFscyxcbiAgICogICBhcyB3ZWxsIGFzIHJlZnJlc2ggdGhlIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBleHBpcmUuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlXG4gICAqICAge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3Ige0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb25zLlxuICAgKiAgIElmIGEgYFJvbGVBcm5gIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIGNyZWRlbnRpYWxzIHdpbGwgYmUgYmFzZWQgb24gdGhlXG4gICAqICAgSUFNIHJvbGUuXG4gICAqIEBwYXJhbSBtYXN0ZXJDcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIChub24tdGVtcG9yYXJ5KSBjcmVkZW50aWFsc1xuICAgKiAgdXNlZCB0byBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBnZW5lcmljIHRlbXBvcmFyeSBjcmVkZW50aWFsc1xuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgYW4gSUFNIHJvbGVcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9UZW1wb3JhcnlDcmVkZW50aWFscycsXG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlXG4gICAqIEBzZWUgQVdTLlNUUy5nZXRTZXNzaW9uVG9rZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBUZW1wb3JhcnlDcmVkZW50aWFscyhwYXJhbXMsIG1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sb2FkTWFzdGVyQ3JlZGVudGlhbHMobWFzdGVyQ3JlZGVudGlhbHMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBpZiAodGhpcy5wYXJhbXMuUm9sZUFybikge1xuICAgICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lID1cbiAgICAgICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd0ZW1wb3JhcnktY3JlZGVudGlhbHMnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yXG4gICAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0sIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIElBTSByb2xlIEFSTiB3YXMgcGFzc2VkXG4gICAqIHRvIHRoZSBjcmVkZW50aWFscyB7Y29uc3RydWN0b3J9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZCAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5tYXN0ZXJDcmVkZW50aWFscy5nZXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscyA9IHNlbGYubWFzdGVyQ3JlZGVudGlhbHM7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gc2VsZi5wYXJhbXMuUm9sZUFybiA/XG4gICAgICAgIHNlbGYuc2VydmljZS5hc3N1bWVSb2xlIDogc2VsZi5zZXJ2aWNlLmdldFNlc3Npb25Ub2tlbjtcbiAgICAgIG9wZXJhdGlvbi5jYWxsKHNlbGYuc2VydmljZSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRNYXN0ZXJDcmVkZW50aWFsczogZnVuY3Rpb24gbG9hZE1hc3RlckNyZWRlbnRpYWxzIChtYXN0ZXJDcmVkZW50aWFscykge1xuICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSBtYXN0ZXJDcmVkZW50aWFscyB8fCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzO1xuICAgIHdoaWxlICh0aGlzLm1hc3RlckNyZWRlbnRpYWxzLm1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gdGhpcy5tYXN0ZXJDcmVkZW50aWFscy5tYXN0ZXJDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMuZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gbmV3IEFXUy5DcmVkZW50aWFscyh0aGlzLm1hc3RlckNyZWRlbnRpYWxzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xudmFyIGluaUxvYWRlciA9IEFXUy51dGlsLmluaUxvYWRlcjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIE9JREMgY3JlZGVudGlhbHMgZnJvbSBhIGZpbGUgb24gZGlza1xuICogSWYgdGhlIGNyZWRlbnRpYWxzIGV4cGlyZSwgdGhlIFNESyBjYW4ge3JlZnJlc2h9IHRoZSBjcmVkZW50aWFsc1xuICogZnJvbSB0aGUgZmlsZS5cbiAqXG4gKiAjIyBVc2luZyB0aGUgd2ViIGlkZW50aXR5IHRva2VuIGZpbGVcbiAqXG4gKiBUaGlzIHByb3ZpZGVyIGlzIGNoZWNrZWQgYnkgZGVmYXVsdCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudC4gVG8gdXNlXG4gKiB0aGUgcHJvdmlkZXIgc2ltcGx5IGFkZCB5b3VyIE9JREMgdG9rZW4gdG8gYSBmaWxlIChBU0NJSSBlbmNvZGluZykgYW5kXG4gKiBzaGFyZSB0aGUgZmlsZW5hbWUgaW4gZWl0aGVyIEFXU19XRUJfSURFTlRJVFlfVE9LRU5fRklMRSBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgb3Igd2ViX2lkZW50aXR5X3Rva2VuX2ZpbGUgc2hhcmVkIGNvbmZpZyB2YXJpYWJsZVxuICpcbiAqIFRoZSBmaWxlIGNvbnRhaW5zIGVuY29kZWQgT0lEQyB0b2tlbiBhbmQgdGhlIGNoYXJhY3RlcnMgYXJlXG4gKiBBU0NJSSBlbmNvZGVkLiBPSURDIHRva2VucyBhcmUgSlNPTiBXZWIgVG9rZW5zIChKV1QpLlxuICogSldUJ3MgYXJlIDMgYmFzZTY0IGVuY29kZWQgc3RyaW5ncyBqb2luZWQgYnkgdGhlICcuJyBjaGFyYWN0ZXIuXG4gKlxuICogVGhpcyBjbGFzcyB3aWxsIHJlYWQgZmlsZW5hbWUgZnJvbSBBV1NfV0VCX0lERU5USVRZX1RPS0VOX0ZJTEVcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHdlYl9pZGVudGl0eV90b2tlbl9maWxlIHNoYXJlZCBjb25maWcgdmFyaWFibGUsXG4gKiBhbmQgZ2V0IHRoZSBPSURDIHRva2VuIGZyb20gZmlsZW5hbWUuXG4gKiBJdCB3aWxsIGFsc28gcmVhZCBJQU0gcm9sZSB0byBiZSBhc3N1bWVkIGZyb20gQVdTX1JPTEVfQVJOXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciByb2xlX2FybiBzaGFyZWQgY29uZmlnIHZhcmlhYmxlLlxuICogVGhpcyBwcm92aWRlciBnZXRzIGNyZWRldGlhbHMgdXNpbmcgdGhlIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gKiBzZXJ2aWNlIG9wZXJhdGlvblxuICpcbiAqIEAhbWFjcm8gbm9icm93c2VyXG4gKi9cbkFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzKFxuICAgKiAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIEFXUy5TVFMgc2VydmljZSBjbGllbnRcbiAgICogICAvLyBpZiBjb25maWd1cmF0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBjb25maWd1cmF0aW9uIHdpbGwgYmUgcHVsbGVkIGZyb20gQVdTLmNvbmZpZ1xuICAgKiAgIHtcbiAgICogICAgIC8vIHNwZWNpZnkgdGltZW91dCBvcHRpb25zXG4gICAqICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFscyhjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcmFtcyBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFBhcmFtc0Zyb21FbnY6IGZ1bmN0aW9uIGdldFBhcmFtc0Zyb21FbnYoKSB7XG4gICAgdmFyIEVOVl9UT0tFTl9GSUxFID0gJ0FXU19XRUJfSURFTlRJVFlfVE9LRU5fRklMRScsXG4gICAgICAgIEVOVl9ST0xFX0FSTiA9ICdBV1NfUk9MRV9BUk4nO1xuICAgIGlmIChwcm9jZXNzLmVudltFTlZfVE9LRU5fRklMRV0gJiYgcHJvY2Vzcy5lbnZbRU5WX1JPTEVfQVJOXSkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGVudlRva2VuRmlsZTogcHJvY2Vzcy5lbnZbRU5WX1RPS0VOX0ZJTEVdLFxuICAgICAgICByb2xlQXJuOiBwcm9jZXNzLmVudltFTlZfUk9MRV9BUk5dLFxuICAgICAgICByb2xlU2Vzc2lvbk5hbWU6IHByb2Nlc3MuZW52WydBV1NfUk9MRV9TRVNTSU9OX05BTUUnXVxuICAgICAgfV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcmFtcyBmcm9tIHNoYXJlZCBjb25maWcgdmFyaWFibGVzXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFyYW1zRnJvbVNoYXJlZENvbmZpZzogZnVuY3Rpb24gZ2V0UGFyYW1zRnJvbVNoYXJlZENvbmZpZygpIHtcbiAgICB2YXIgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoaW5pTG9hZGVyKTtcbiAgICB2YXIgcHJvZmlsZU5hbWUgPSBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZTtcbiAgICB2YXIgcHJvZmlsZSA9IHByb2ZpbGVzW3Byb2ZpbGVOYW1lXSB8fCB7fTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhwcm9maWxlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgICBuZXcgRXJyb3IoJ1Byb2ZpbGUgJyArIHByb2ZpbGVOYW1lICsgJyBub3QgZm91bmQnKSxcbiAgICAgICAgeyBjb2RlOiAnVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZScgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zQXJyYXkgPSBbXTtcblxuICAgIHdoaWxlICghcHJvZmlsZVsnd2ViX2lkZW50aXR5X3Rva2VuX2ZpbGUnXSAmJiBwcm9maWxlWydzb3VyY2VfcHJvZmlsZSddKSB7XG4gICAgICBwYXJhbXNBcnJheS51bnNoaWZ0KHtcbiAgICAgICAgcm9sZUFybjogcHJvZmlsZVsncm9sZV9hcm4nXSxcbiAgICAgICAgcm9sZVNlc3Npb25OYW1lOiBwcm9maWxlWydyb2xlX3Nlc3Npb25fbmFtZSddXG4gICAgICB9KTtcbiAgICAgIHZhciBzb3VyY2VQcm9maWxlID0gcHJvZmlsZVsnc291cmNlX3Byb2ZpbGUnXTtcbiAgICAgIHByb2ZpbGUgPSBwcm9maWxlc1tzb3VyY2VQcm9maWxlXTtcbiAgICB9XG5cbiAgICBwYXJhbXNBcnJheS51bnNoaWZ0KHtcbiAgICAgIGVudlRva2VuRmlsZTogcHJvZmlsZVsnd2ViX2lkZW50aXR5X3Rva2VuX2ZpbGUnXSxcbiAgICAgIHJvbGVBcm46IHByb2ZpbGVbJ3JvbGVfYXJuJ10sXG4gICAgICByb2xlU2Vzc2lvbk5hbWU6IHByb2ZpbGVbJ3JvbGVfc2Vzc2lvbl9uYW1lJ11cbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbXNBcnJheTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgQVdTLkNyZWRlbnRpYWxzLmdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICovXG4gIGFzc3VtZVJvbGVDaGFpbmluZzogZnVuY3Rpb24gYXNzdW1lUm9sZUNoYWluaW5nKHBhcmFtc0FycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAocGFyYW1zQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLnNlcnZpY2UuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyYW1zID0gcGFyYW1zQXJyYXkuc2hpZnQoKTtcbiAgICAgIHNlbGYuc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMgPSBzZWxmLnNlcnZpY2UuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZShcbiAgICAgICAge1xuICAgICAgICAgIFJvbGVBcm46IHBhcmFtcy5yb2xlQXJuLFxuICAgICAgICAgIFJvbGVTZXNzaW9uTmFtZTogcGFyYW1zLnJvbGVTZXNzaW9uTmFtZSB8fCAndG9rZW4tZmlsZS13ZWItaWRlbnRpdHknXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICBzZWxmLmRhdGEgPSBudWxsO1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBzZWxmLmFzc3VtZVJvbGVDaGFpbmluZyhwYXJhbXNBcnJheSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgdmFyIHBhcmFtc0FycmF5ID0gc2VsZi5nZXRQYXJhbXNGcm9tRW52KCk7XG4gICAgICBpZiAoIXBhcmFtc0FycmF5KSB7XG4gICAgICAgIHBhcmFtc0FycmF5ID0gc2VsZi5nZXRQYXJhbXNGcm9tU2hhcmVkQ29uZmlnKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zQXJyYXkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHBhcmFtc0FycmF5LnNoaWZ0KCk7XG4gICAgICAgIHZhciBvaWRjVG9rZW4gPSBmcy5yZWFkRmlsZVN5bmMocGFyYW1zLmVudlRva2VuRmlsZSwge2VuY29kaW5nOiAnYXNjaWknfSk7XG4gICAgICAgIGlmICghc2VsZi5zZXJ2aWNlKSB7XG4gICAgICAgICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkoXG4gICAgICAgICAge1xuICAgICAgICAgICAgV2ViSWRlbnRpdHlUb2tlbjogb2lkY1Rva2VuLFxuICAgICAgICAgICAgUm9sZUFybjogcGFyYW1zLnJvbGVBcm4sXG4gICAgICAgICAgICBSb2xlU2Vzc2lvbk5hbWU6IHBhcmFtcy5yb2xlU2Vzc2lvbk5hbWUgfHwgJ3Rva2VuLWZpbGUtd2ViLWlkZW50aXR5J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgIHNlbGYuYXNzdW1lUm9sZUNoYWluaW5nKHBhcmFtc0FycmF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgIHZhciBzdHNDb25maWcgPSBBV1MudXRpbC5tZXJnZSh7fSwgdGhpcy5jbGllbnRDb25maWcpO1xuICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IFNUUyhzdHNDb25maWcpO1xuXG4gICAgICAvLyBSZXRyeSBpbiBjYXNlIG9mIElEUENvbW11bmljYXRpb25FcnJvckV4Y2VwdGlvbiBvciBJbnZhbGlkSWRlbnRpdHlUb2tlblxuICAgICAgdGhpcy5zZXJ2aWNlLnJldHJ5YWJsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdJRFBDb21tdW5pY2F0aW9uRXJyb3JFeGNlcHRpb24nIHx8IGVycm9yLmNvZGUgPT09ICdJbnZhbGlkSWRlbnRpdHlUb2tlbicpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gQVdTLlNlcnZpY2UucHJvdG90eXBlLnJldHJ5YWJsZUVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgV2ViIElkZW50aXR5IEZlZGVyYXRpb24gc3VwcG9ydC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvblxuICogcmVxdWlyZXMgYSBgUm9sZUFybmAgY29udGFpbmluZyB0aGUgQVJOIG9mIHRoZSBJQU0gdHJ1c3QgcG9saWN5IGZvciB0aGVcbiAqIGFwcGxpY2F0aW9uIGZvciB3aGljaCBjcmVkZW50aWFscyB3aWxsIGJlIGdpdmVuLiBJbiBhZGRpdGlvbiwgdGhlXG4gKiBgV2ViSWRlbnRpdHlUb2tlbmAgbXVzdCBiZSBzZXQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBpZGVudGl0eVxuICogcHJvdmlkZXIuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBgUm9sZUFybmAgYW5kIGBXZWJJZGVudGl0eVRva2VuYCB2YWx1ZXMuXG4gKlxuICogIyMgUmVmcmVzaGluZyBDcmVkZW50aWFscyBmcm9tIElkZW50aXR5IFNlcnZpY2VcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBBV1MgY3JlZGVudGlhbHMgZXhwaXJpbmcgYWZ0ZXIgYSBnaXZlbiBhbW91bnQgb2YgdGltZSwgdGhlXG4gKiBsb2dpbiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlciB3aWxsIGFsc28gZXhwaXJlLiBPbmNlIHRoaXMgdG9rZW5cbiAqIGV4cGlyZXMsIGl0IHdpbGwgbm90IGJlIHVzYWJsZSB0byByZWZyZXNoIEFXUyBjcmVkZW50aWFscywgYW5kIGFub3RoZXJcbiAqIHRva2VuIHdpbGwgYmUgbmVlZGVkLiBUaGUgU0RLIGRvZXMgbm90IG1hbmFnZSByZWZyZXNoaW5nIG9mIHRoZSB0b2tlbiB2YWx1ZSxcbiAqIGJ1dCB0aGlzIGNhbiBiZSBkb25lIHRocm91Z2ggYSBcInJlZnJlc2ggdG9rZW5cIiBzdXBwb3J0ZWQgYnkgbW9zdCBpZGVudGl0eVxuICogcHJvdmlkZXJzLiBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgZm9yIHJlZnJlc2hpbmdcbiAqIHRva2Vucy4gT25jZSB0aGUgcmVmcmVzaGVkIHRva2VuIGlzIGFjcXVpcmVkLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byB1cGRhdGVcbiAqIHRoaXMgbmV3IHRva2VuIGluIHRoZSBjcmVkZW50aWFscyBvYmplY3QncyB7cGFyYW1zfSBwcm9wZXJ0eS4gVGhlIGZvbGxvd2luZ1xuICogY29kZSB3aWxsIHVwZGF0ZSB0aGUgV2ViSWRlbnRpdHlUb2tlbiwgYXNzdW1pbmcgeW91IGhhdmUgcmV0cmlldmVkIGFuIHVwZGF0ZWRcbiAqIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMucGFyYW1zLldlYklkZW50aXR5VG9rZW4gPSB1cGRhdGVkVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBGdXR1cmUgY2FsbHMgdG8gYGNyZWRlbnRpYWxzLnJlZnJlc2goKWAgd2lsbCBub3cgdXNlIHRoZSBuZXcgdG9rZW4uXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1zXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIG1hcCBvZiBwYXJhbXMgcGFzc2VkIHRvXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLldlYklkZW50aXR5VG9rZW5gIHByb3BlcnR5LlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmV0dXJuIFttYXBdIHRoZSByYXcgZGF0YSByZXNwb25zZSBmcm9tIHRoZSBjYWxsIHRvXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGdldFxuICogICAgIGFjY2VzcyB0byBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3BvbnNlLlxuICovXG5BV1MuV2ViSWRlbnRpdHlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQHBhcmFtIChzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5KVxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1dlYklkZW50aXR5JyxcbiAgICogICAgIFdlYklkZW50aXR5VG9rZW46ICdBQkNERUZHSElKS0xNTk9QJywgLy8gdG9rZW4gZnJvbSBpZGVudGl0eSBzZXJ2aWNlXG4gICAqICAgICBSb2xlU2Vzc2lvbk5hbWU6ICd3ZWInIC8vIG9wdGlvbmFsIG5hbWUsIGRlZmF1bHRzIHRvIHdlYi1pZGVudGl0eVxuICAgKiAgIH0sIHtcbiAgICogICAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIEFXUy5TVFMgc2VydmljZSBjbGllbnRcbiAgICogICAgIC8vIGlmIGNvbmZpZ3VyYXRpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBwdWxsZWQgZnJvbSBBV1MuY29uZmlnXG4gICAqXG4gICAqICAgICAvLyBzcGVjaWZ5IHRpbWVvdXQgb3B0aW9uc1xuICAgKiAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICogICAgICAgdGltZW91dDogMTAwXG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5XG4gICAqIEBzZWUgQVdTLkNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFdlYklkZW50aXR5Q3JlZGVudGlhbHMocGFyYW1zLCBjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSA9IHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSB8fCAnd2ViLWlkZW50aXR5JztcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuX2NsaWVudENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY2xpZW50Q29uZmlnIHx8IHt9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jb2FsZXNjZVJlZnJlc2goY2FsbGJhY2sgfHwgQVdTLnV0aWwuZm4uY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlKSB7XG4gICAgICB2YXIgc3RzQ29uZmlnID0gQVdTLnV0aWwubWVyZ2Uoe30sIHRoaXMuX2NsaWVudENvbmZpZyk7XG4gICAgICBzdHNDb25maWcucGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBuZXcgU1RTKHN0c0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzID0gWydBV1NfRU5BQkxFX0VORFBPSU5UX0RJU0NPVkVSWScsICdBV1NfRU5EUE9JTlRfRElTQ09WRVJZX0VOQUJMRUQnXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBrZXkgKGV4Y2VwdCByZXNvdXJjZXMgYW5kIG9wZXJhdGlvbiBwYXJ0KSB0byBpbmRleCB0aGUgZW5kcG9pbnRzIGluIHRoZSBjYWNoZVxuICogSWYgaW5wdXQgc2hhcGUgaGFzIGVuZHBvaW50ZGlzY292ZXJ5aWQgdHJhaXQgdGhlbiB1c2VcbiAqICAgYWNjZXNzS2V5ICsgb3BlcmF0aW9uICsgcmVzb3VyY2VzICsgcmVnaW9uICsgc2VydmljZSBhcyBjYWNoZSBrZXlcbiAqIElmIGlucHV0IHNoYXBlIGRvZXNuJ3QgaGF2ZSBlbmRwb2ludGRpc2NvdmVyeWlkIHRyYWl0IHRoZW4gdXNlXG4gKiAgIGFjY2Vzc0tleSArIHJlZ2lvbiArIHNlcnZpY2UgYXMgY2FjaGUga2V5XG4gKiBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dIG9iamVjdCB3aXRoIGtleXMgdG8gaW5kZXggZW5kcG9pbnRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENhY2hlS2V5KHJlcXVlc3QpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gIHZhciBhcGkgPSBzZXJ2aWNlLmFwaSB8fCB7fTtcbiAgdmFyIG9wZXJhdGlvbnMgPSBhcGkub3BlcmF0aW9ucztcbiAgdmFyIGlkZW50aWZpZXJzID0ge307XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5yZWdpb24pIHtcbiAgICBpZGVudGlmaWVycy5yZWdpb24gPSBzZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gIH1cbiAgaWYgKGFwaS5zZXJ2aWNlSWQpIHtcbiAgICBpZGVudGlmaWVycy5zZXJ2aWNlSWQgPSBhcGkuc2VydmljZUlkO1xuICB9XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCkge1xuICAgIGlkZW50aWZpZXJzLmFjY2Vzc0tleUlkID0gc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMoKS5cbiAqIExvb2tzIGZvciByZXF1aXJlZCBzdHJpbmcgaW5wdXQgbWVtYmVycyB0aGF0IGhhdmUgJ2VuZHBvaW50ZGlzY292ZXJ5aWQnIHRyYWl0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnNIZWxwZXIocmVzdWx0LCBwYXJhbXMsIHNoYXBlKSB7XG4gIGlmICghc2hhcGUgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSByZXR1cm47XG4gIGlmIChzaGFwZS50eXBlID09PSAnc3RydWN0dXJlJyAmJiBzaGFwZS5yZXF1aXJlZCAmJiBzaGFwZS5yZXF1aXJlZC5sZW5ndGggPiAwKSB7XG4gICAgdXRpbC5hcnJheUVhY2goc2hhcGUucmVxdWlyZWQsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgICBpZiAobWVtYmVyU2hhcGUuZW5kcG9pbnREaXNjb3ZlcnlJZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYXRpb25OYW1lID0gbWVtYmVyU2hhcGUuaXNMb2NhdGlvbk5hbWUgPyBtZW1iZXJTaGFwZS5uYW1lIDogbmFtZTtcbiAgICAgICAgcmVzdWx0W2xvY2F0aW9uTmFtZV0gPSBTdHJpbmcocGFyYW1zW25hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnNIZWxwZXIocmVzdWx0LCBwYXJhbXNbbmFtZV0sIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBjdXN0b20gaWRlbnRpZmllcnMgZm9yIGNhY2hlIGtleS5cbiAqIElkZW50aWZpZXMgY3VzdG9tIGlkZW50aWZpZXJzIGJ5IGNoZWNraW5nIGVhY2ggc2hhcGUncyBgZW5kcG9pbnREaXNjb3ZlcnlJZGAgdHJhaXQuXG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSBbb2JqZWN0XSBpbnB1dCBzaGFwZSBvZiB0aGUgZ2l2ZW4gb3BlcmF0aW9uJ3MgYXBpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBzaGFwZSkge1xuICB2YXIgaWRlbnRpZmllcnMgPSB7fTtcbiAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihpZGVudGlmaWVycywgcmVxdWVzdC5wYXJhbXMsIHNoYXBlKTtcbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG4vKipcbiAqIENhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbiB3aGVuIGl0J3Mgb3B0aW9uYWwuXG4gKiBXaGVuIGVuZHBvaW50IGlzIGF2YWlsYWJsZSBpbiBjYWNoZSB0aGVuIHVzZSB0aGUgY2FjaGVkIGVuZHBvaW50cy4gSWYgZW5kcG9pbnRzXG4gKiBhcmUgdW5hdmFpbGFibGUgdGhlbiB1c2UgcmVnaW9uYWwgZW5kcG9pbnRzIGFuZCBjYWxsIGVuZHBvaW50IGRpc2NvdmVyeSBvcGVyYXRpb25cbiAqIGFzeW5jaHJvbm91c2x5LiBUaGlzIGlzIHR1cm5lZCBvZmYgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0KSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICB2YXIgYXBpID0gc2VydmljZS5hcGk7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IGFwaS5vcGVyYXRpb25zID8gYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgaW5wdXRTaGFwZSA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuaW5wdXQgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlkZW50aWZpZXJzID0gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBpbnB1dFNoYXBlKTtcbiAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgIGNhY2hlS2V5ID0gdXRpbC51cGRhdGUoY2FjaGVLZXksIGlkZW50aWZpZXJzKTtcbiAgICBpZiAob3BlcmF0aW9uTW9kZWwpIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLm5hbWU7XG4gIH1cbiAgdmFyIGVuZHBvaW50cyA9IEFXUy5lbmRwb2ludENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBlbmRwb2ludHNbMF0uQWRkcmVzcyA9PT0gJycpIHtcbiAgICAvL2VuZHBvaW50IG9wZXJhdGlvbiBpcyBiZWluZyBtYWRlIGJ1dCByZXNwb25zZSBub3QgeWV0IHJlY2VpdmVkXG4gICAgLy9vciBlbmRwb2ludCBvcGVyYXRpb24ganVzdCBmYWlsZWQgaW4gMSBtaW51dGVcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgLy9mb3VuZCBlbmRwb2ludCByZWNvcmQgZnJvbSBjYWNoZVxuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICB9IGVsc2Uge1xuICAgIC8vZW5kcG9pbnQgcmVjb3JkIG5vdCBpbiBjYWNoZSBvciBvdXRkYXRlZC4gbWFrZSBkaXNjb3Zlcnkgb3BlcmF0aW9uXG4gICAgdmFyIGVuZHBvaW50UmVxdWVzdCA9IHNlcnZpY2UubWFrZVJlcXVlc3QoYXBpLmVuZHBvaW50T3BlcmF0aW9uLCB7XG4gICAgICBPcGVyYXRpb246IG9wZXJhdGlvbk1vZGVsLm5hbWUsXG4gICAgICBJZGVudGlmaWVyczogaWRlbnRpZmllcnMsXG4gICAgfSk7XG4gICAgYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICBlbmRwb2ludFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3JldHJ5JywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuUkVUUllfQ0hFQ0spO1xuICAgIC8vcHV0IGluIGEgcGxhY2Vob2xkZXIgZm9yIGVuZHBvaW50cyBhbHJlYWR5IHJlcXVlc3RlZCwgcHJldmVudFxuICAgIC8vdG9vIG11Y2ggaW4tZmxpZ2h0IGNhbGxzXG4gICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBbe1xuICAgICAgQWRkcmVzczogJycsXG4gICAgICBDYWNoZVBlcmlvZEluTWludXRlczogMVxuICAgIH1dKTtcbiAgICBlbmRwb2ludFJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuRW5kcG9pbnRzKSB7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleSwgZGF0YS5FbmRwb2ludHMpO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBbe1xuICAgICAgICAgIEFkZHJlc3M6ICcnLFxuICAgICAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiAxIC8vbm90IHRvIG1ha2UgbW9yZSBlbmRwb2ludCBvcGVyYXRpb24gaW4gbmV4dCAxIG1pbnV0ZVxuICAgICAgICB9XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIHJlcXVlc3RRdWV1ZSA9IHt9O1xuXG4vKipcbiAqIENhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbiB3aGVuIGl0J3MgcmVxdWlyZWQuXG4gKiBXaGVuIGVuZHBvaW50IGlzIGF2YWlsYWJsZSBpbiBjYWNoZSB0aGVuIHVzZSBjYWNoZWQgb25lcy4gSWYgZW5kcG9pbnRzIGFyZVxuICogdW5hdmFpbGFibGUgdGhlbiBTREsgc2hvdWxkIGNhbGwgZW5kcG9pbnQgb3BlcmF0aW9uIHRoZW4gdXNlIHJldHVybmVkIG5ld1xuICogZW5kcG9pbnQgZm9yIHRoZSBhcGkgY2FsbC4gU0RLIHdpbGwgYXV0b21hdGljYWxseSBhdHRlbXB0IHRvIGRvIGVuZHBvaW50XG4gKiBkaXNjb3ZlcnkuIFRoaXMgaXMgdHVybmVkIG9mZiBieSBkZWZhdWx0XG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZTtcbiAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpO1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBhcGkub3BlcmF0aW9ucyA/IGFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGlucHV0U2hhcGUgPSBvcGVyYXRpb25Nb2RlbCA/IG9wZXJhdGlvbk1vZGVsLmlucHV0IDogdW5kZWZpbmVkO1xuXG4gIHZhciBpZGVudGlmaWVycyA9IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMocmVxdWVzdCwgaW5wdXRTaGFwZSk7XG4gIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KHJlcXVlc3QpO1xuICBpZiAoT2JqZWN0LmtleXMoaWRlbnRpZmllcnMpLmxlbmd0aCA+IDApIHtcbiAgICBjYWNoZUtleSA9IHV0aWwudXBkYXRlKGNhY2hlS2V5LCBpZGVudGlmaWVycyk7XG4gICAgaWYgKG9wZXJhdGlvbk1vZGVsKSBjYWNoZUtleS5vcGVyYXRpb24gPSBvcGVyYXRpb25Nb2RlbC5uYW1lO1xuICB9XG4gIHZhciBjYWNoZUtleVN0ciA9IEFXUy5FbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhjYWNoZUtleSk7XG4gIHZhciBlbmRwb2ludHMgPSBBV1MuZW5kcG9pbnRDYWNoZS5nZXQoY2FjaGVLZXlTdHIpOyAvL2VuZHBvaW50IGNhY2hlIGFsc28gYWNjZXB0cyBzdHJpbmcga2V5c1xuICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPT09IDEgJiYgZW5kcG9pbnRzWzBdLkFkZHJlc3MgPT09ICcnKSB7XG4gICAgLy9lbmRwb2ludCBvcGVyYXRpb24gaXMgYmVpbmcgbWFkZSBidXQgcmVzcG9uc2Ugbm90IHlldCByZWNlaXZlZFxuICAgIC8vcHVzaCByZXF1ZXN0IG9iamVjdCB0byBhIHBlbmRpbmcgcXVldWVcbiAgICBpZiAoIXJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0pIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0gPSBbXTtcbiAgICByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdLnB1c2goe3JlcXVlc3Q6IHJlcXVlc3QsIGNhbGxiYWNrOiBkb25lfSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGVuZHBvaW50cyAmJiBlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICAgIGRvbmUoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5kcG9pbnRSZXF1ZXN0ID0gc2VydmljZS5tYWtlUmVxdWVzdChhcGkuZW5kcG9pbnRPcGVyYXRpb24sIHtcbiAgICAgIE9wZXJhdGlvbjogb3BlcmF0aW9uTW9kZWwubmFtZSxcbiAgICAgIElkZW50aWZpZXJzOiBpZGVudGlmaWVycyxcbiAgICB9KTtcbiAgICBlbmRwb2ludFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUyk7XG4gICAgYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpO1xuXG4gICAgLy9wdXQgaW4gYSBwbGFjZWhvbGRlciBmb3IgZW5kcG9pbnRzIGFscmVhZHkgcmVxdWVzdGVkLCBwcmV2ZW50XG4gICAgLy90b28gbXVjaCBpbi1mbGlnaHQgY2FsbHNcbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXlTdHIsIFt7XG4gICAgICBBZGRyZXNzOiAnJyxcbiAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiA2MCAvL2xvbmctbGl2ZSBjYWNoZVxuICAgIH1dKTtcbiAgICBlbmRwb2ludFJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZS5lcnJvciA9IHV0aWwuZXJyb3IoZXJyLCB7IHJldHJ5YWJsZTogZmFsc2UgfSk7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG5cbiAgICAgICAgLy9mYWlsIGFsbCB0aGUgcGVuZGluZyByZXF1ZXN0cyBpbiBiYXRjaFxuICAgICAgICBpZiAocmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdO1xuICAgICAgICAgIHV0aWwuYXJyYXlFYWNoKHBlbmRpbmdSZXF1ZXN0cywgZnVuY3Rpb24ocmVxdWVzdENvbnRleHQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LnJlcXVlc3QucmVzcG9uc2UuZXJyb3IgPSB1dGlsLmVycm9yKGVyciwgeyByZXRyeWFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleVN0ciwgZGF0YS5FbmRwb2ludHMpO1xuICAgICAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KGRhdGEuRW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuXG4gICAgICAgIC8vdXBkYXRlIHRoZSBlbmRwb2ludCBmb3IgYWxsIHRoZSBwZW5kaW5nIHJlcXVlc3RzIGluIGJhdGNoXG4gICAgICAgIGlmIChyZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgICAgdXRpbC5hcnJheUVhY2gocGVuZGluZ1JlcXVlc3RzLCBmdW5jdGlvbihyZXF1ZXN0Q29udGV4dCkge1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQucmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChkYXRhLkVuZHBvaW50c1swXS5BZGRyZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LmNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIGFkZCBhcGkgdmVyc2lvbiBoZWFkZXIgdG8gZW5kcG9pbnQgb3BlcmF0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpIHtcbiAgdmFyIGFwaSA9IGVuZHBvaW50UmVxdWVzdC5zZXJ2aWNlLmFwaTtcbiAgdmFyIGFwaVZlcnNpb24gPSBhcGkuYXBpVmVyc2lvbjtcbiAgaWYgKGFwaVZlcnNpb24gJiYgIWVuZHBvaW50UmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWyd4LWFtei1hcGktdmVyc2lvbiddKSB7XG4gICAgZW5kcG9pbnRSZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LWFwaS12ZXJzaW9uJ10gPSBhcGlWZXJzaW9uO1xuICB9XG59XG5cbi8qKlxuICogSWYgYXBpIGNhbGwgZ2V0cyBpbnZhbGlkIGVuZHBvaW50IGV4Y2VwdGlvbiwgU0RLIHNob3VsZCBhdHRlbXB0IHRvIHJlbW92ZSB0aGUgaW52YWxpZFxuICogZW5kcG9pbnQgZnJvbSBjYWNoZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnRzKHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICB2YXIgaHR0cFJlc3BvbnNlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlO1xuICBpZiAoZXJyb3IgJiZcbiAgICAoZXJyb3IuY29kZSA9PT0gJ0ludmFsaWRFbmRwb2ludEV4Y2VwdGlvbicgfHwgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyMSlcbiAgKSB7XG4gICAgdmFyIHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb25zID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICAgIHZhciBpbnB1dFNoYXBlID0gb3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0gPyBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXS5pbnB1dCA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaWRlbnRpZmllcnMgPSBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIGlucHV0U2hhcGUpO1xuICAgIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KHJlcXVlc3QpO1xuICAgIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgICAgY2FjaGVLZXkgPSB1dGlsLnVwZGF0ZShjYWNoZUtleSwgaWRlbnRpZmllcnMpO1xuICAgICAgaWYgKG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dKSBjYWNoZUtleS5vcGVyYXRpb24gPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXS5uYW1lO1xuICAgIH1cbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5yZW1vdmUoY2FjaGVLZXkpO1xuICB9XG59XG5cbi8qKlxuICogSWYgZW5kcG9pbnQgaXMgZXhwbGljaXRseSBjb25maWd1cmVkLCBTREsgc2hvdWxkIG5vdCBkbyBlbmRwb2ludCBkaXNjb3ZlcnkgaW4gYW55dGltZS5cbiAqIEBwYXJhbSBbb2JqZWN0XSBjbGllbnQgU2VydmljZSBjbGllbnQgb2JqZWN0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0N1c3RvbUVuZHBvaW50KGNsaWVudCkge1xuICAvL2lmIHNldCBlbmRwb2ludCBpcyBzZXQgZm9yIHNwZWNpZmljIGNsaWVudCwgZW5hYmxlIGVuZHBvaW50IGRpc2NvdmVyeSB3aWxsIHJhaXNlIGFuIGVycm9yLlxuICBpZiAoY2xpZW50Ll9vcmlnaW5hbENvbmZpZyAmJiBjbGllbnQuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50ICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgbWVzc2FnZTogJ0N1c3RvbSBlbmRwb2ludCBpcyBzdXBwbGllZDsgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkIG11c3Qgbm90IGJlIHRydWUuJ1xuICAgIH0pO1xuICB9O1xuICB2YXIgc3ZjQ29uZmlnID0gQVdTLmNvbmZpZ1tjbGllbnQuc2VydmljZUlkZW50aWZpZXJdIHx8IHt9O1xuICByZXR1cm4gQm9vbGVhbihBV1MuY29uZmlnLmVuZHBvaW50IHx8IHN2Y0NvbmZpZy5lbmRwb2ludCB8fCAoY2xpZW50Ll9vcmlnaW5hbENvbmZpZyAmJiBjbGllbnQuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50KSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kodmFsdWUpIHtcbiAgcmV0dXJuIFsnZmFsc2UnLCAnMCddLmluZGV4T2YodmFsdWUpID49IDA7XG59XG5cbi8qKlxuICogSWYgZW5kcG9pbnQgZGlzY292ZXJ5IHNob3VsZCBwZXJmb3JtIGZvciB0aGlzIHJlcXVlc3Qgd2hlbiBubyBvcGVyYXRpb24gcmVxdWlyZXMgZW5kcG9pbnRcbiAqIGRpc2NvdmVyeSBmb3IgdGhlIGdpdmVuIHNlcnZpY2UuXG4gKiBTREsgcGVyZm9ybXMgY29uZmlnIHJlc29sdXRpb24gaW4gb3JkZXIgbGlrZSBiZWxvdzpcbiAqIDEuIElmIHNldCBpbiBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAqIDIuIElmIHNldCBpbiBlbnYgQVdTX0VOQUJMRV9FTkRQT0lOVF9ESVNDT1ZFUlkuXG4gKiAzLiBJZiBzZXQgaW4gc2hhcmVkIGluaSBjb25maWcgZmlsZSB3aXRoIGtleSAnZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQnLlxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3QgcmVxdWVzdCBvYmplY3QuXG4gKiBAcmV0dXJucyBbYm9vbGVhbnx1bmRlZmluZWRdIGlmIGVuZHBvaW50IGRpc2NvdmVyeSBjb25maWcgaXMgbm90IHNldCBpbiBhbnkgc291cmNlLCB0aGlzXG4gKiAgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlRW5kcG9pbnREaXNjb3ZlcnlDb25maWcocmVxdWVzdCkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZSB8fCB7fTtcbiAgaWYgKHNlcnZpY2UuY29uZmlnLmVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHNlcnZpY2UuY29uZmlnLmVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZDtcbiAgfVxuXG4gIC8vc2hhcmVkIGluaSBmaWxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5vZGVcbiAgLy9ub3QgdG8gY2hlY2sgZW52IGluIGJyb3dzZXJcbiAgaWYgKHV0aWwuaXNCcm93c2VyKCkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgYW55IG9mIHJlY29nbml6ZWQgZW5kcG9pbnQgZGlzY292ZXJ5IGNvbmZpZyBlbnYgaXMgc2V0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkRW52cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnYgPSBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzW2ldO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzcy5lbnYsIGVudikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudltlbnZdID09PSAnJyB8fCBwcm9jZXNzLmVudltlbnZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgIGNvZGU6ICdDb25maWd1cmF0aW9uRXhjZXB0aW9uJyxcbiAgICAgICAgICBtZXNzYWdlOiAnZW52aXJvbm1lbnRhbCB2YXJpYWJsZSAnICsgZW52ICsgJyBjYW5ub3QgYmUgc2V0IHRvIG5vdGhpbmcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFpc0ZhbHN5KHByb2Nlc3MuZW52W2Vudl0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb25maWdGaWxlID0ge307XG4gIHRyeSB7XG4gICAgY29uZmlnRmlsZSA9IEFXUy51dGlsLmluaUxvYWRlciA/IEFXUy51dGlsLmluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICBpc0NvbmZpZzogdHJ1ZSxcbiAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudltBV1MudXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgIH0pIDoge307XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHZhciBzaGFyZWRGaWxlQ29uZmlnID0gY29uZmlnRmlsZVtcbiAgICBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZVxuICBdIHx8IHt9O1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNoYXJlZEZpbGVDb25maWcsICdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCcpKSB7XG4gICAgaWYgKHNoYXJlZEZpbGVDb25maWcuZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdjb25maWcgZmlsZSBlbnRyeSBcXCdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZFxcJyBjYW5ub3QgYmUgc2V0IHRvIG5vdGhpbmcnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICFpc0ZhbHN5KHNoYXJlZEZpbGVDb25maWcuZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogYXR0YWNoIGVuZHBvaW50IGRpc2NvdmVyeSBsb2dpYyB0byByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QsIGRvbmUpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2UgfHwge307XG4gIGlmIChoYXNDdXN0b21FbmRwb2ludChzZXJ2aWNlKSB8fCByZXF1ZXN0LmlzUHJlc2lnbmVkKCkpIHJldHVybiBkb25lKCk7XG5cbiAgdmFyIG9wZXJhdGlvbnMgPSBzZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgdmFyIGlzRW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuZW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCA6ICdOVUxMJztcbiAgdmFyIGlzRW5hYmxlZCA9IHJlc29sdmVFbmRwb2ludERpc2NvdmVyeUNvbmZpZyhyZXF1ZXN0KTtcbiAgdmFyIGhhc1JlcXVpcmVkRW5kcG9pbnREaXNjb3ZlcnkgPSBzZXJ2aWNlLmFwaS5oYXNSZXF1aXJlZEVuZHBvaW50RGlzY292ZXJ5O1xuICBpZiAoaXNFbmFibGVkIHx8IGhhc1JlcXVpcmVkRW5kcG9pbnREaXNjb3ZlcnkpIHtcbiAgICAvLyBPbmNlIGEgY3VzdG9tZXIgZW5hYmxlcyBlbmRwb2ludCBkaXNjb3ZlcnksIHRoZSBTREsgc2hvdWxkIHN0YXJ0IGFwcGVuZGluZ1xuICAgIC8vIHRoZSBzdHJpbmcgZW5kcG9pbnQtZGlzY292ZXJ5IHRvIHRoZSB1c2VyLWFnZW50IG9uIGFsbCByZXF1ZXN0cy5cbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdlbmRwb2ludC1kaXNjb3ZlcnknKTtcbiAgfVxuICBzd2l0Y2ggKGlzRW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCkge1xuICAgIGNhc2UgJ09QVElPTkFMJzpcbiAgICAgIGlmIChpc0VuYWJsZWQgfHwgaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSkge1xuICAgICAgICAvLyBGb3IgYSBnaXZlbiBzZXJ2aWNlOyBpZiBhdCBsZWFzdCBvbmUgb3BlcmF0aW9uIHJlcXVpcmVzIGVuZHBvaW50IGRpc2NvdmVyeSB0aGVuIHRoZSBTREsgbXVzdCBlbmFibGUgZW5kcG9pbnQgZGlzY292ZXJ5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgZm9yIGFsbCBvcGVyYXRpb25zIG9mIHRoYXQgc2VydmljZSwgaW5jbHVkaW5nIG9wZXJhdGlvbnMgd2hlcmUgZW5kcG9pbnQgZGlzY292ZXJ5IGlzIG9wdGlvbmFsLlxuICAgICAgICBvcHRpb25hbERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCk7XG4gICAgICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignSU5WQUxJREFURV9DQUNIRURfRU5EUE9JTlRTJywgJ2V4dHJhY3RFcnJvcicsIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMpO1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkVRVUlSRUQnOlxuICAgICAgaWYgKGlzRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gRm9yIGEgZ2l2ZW4gb3BlcmF0aW9uOyBpZiBlbmRwb2ludCBkaXNjb3ZlcnkgaXMgcmVxdWlyZWQgYW5kIGl0IGhhcyBiZWVuIGRpc2FibGVkIG9uIHRoZSBTREsgY2xpZW50LFxuICAgICAgICAvLyB0aGVuIHRoZSBTREsgbXVzdCByZXR1cm4gYSBjbGVhciBhbmQgYWN0aW9uYWJsZSBleGNlcHRpb24uXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2UuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFbmRwb2ludCBEaXNjb3ZlcnkgaXMgZGlzYWJsZWQgYnV0ICcgKyBzZXJ2aWNlLmFwaS5jbGFzc05hbWUgKyAnLicgKyByZXF1ZXN0Lm9wZXJhdGlvbiArXG4gICAgICAgICAgICAgICAgICAgICcoKSByZXF1aXJlcyBpdC4gUGxlYXNlIGNoZWNrIHlvdXIgY29uZmlndXJhdGlvbnMuJ1xuICAgICAgICB9KTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignSU5WQUxJREFURV9DQUNIRURfRU5EUE9JTlRTJywgJ2V4dHJhY3RFcnJvcicsIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMpO1xuICAgICAgcmVxdWlyZWREaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QsIGRvbmUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTlVMTCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGRvbmUoKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkaXNjb3ZlckVuZHBvaW50OiBkaXNjb3ZlckVuZHBvaW50LFxuICByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQ6IHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludCxcbiAgb3B0aW9uYWxEaXNjb3ZlckVuZHBvaW50OiBvcHRpb25hbERpc2NvdmVyRW5kcG9pbnQsXG4gIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnM6IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMsXG4gIGdldENhY2hlS2V5OiBnZXRDYWNoZUtleSxcbiAgaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50OiBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnRzLFxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IEFXUy51dGlsO1xudmFyIHR5cGVPZiA9IHJlcXVpcmUoJy4vdHlwZXMnKS50eXBlT2Y7XG52YXIgRHluYW1vREJTZXQgPSByZXF1aXJlKCcuL3NldCcpO1xudmFyIE51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9udW1iZXJWYWx1ZScpO1xuXG5BV1MuRHluYW1vREIuQ29udmVydGVyID0ge1xuICAvKipcbiAgICogQ29udmVydCBhIEphdmFTY3JpcHQgdmFsdWUgdG8gaXRzIGVxdWl2YWxlbnQgRHluYW1vREIgQXR0cmlidXRlVmFsdWUgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBbYW55XSBUaGUgZGF0YSB0byBjb252ZXJ0IHRvIGEgRHluYW1vREIgQXR0cmlidXRlVmFsdWVcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF1cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbnZlcnRFbXB0eVZhbHVlcyBbQm9vbGVhbl0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnQgZW1wdHkgc3RyaW5ncywgYmxvYnMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzZXRzIHRvIGBudWxsYFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgd3JhcE51bWJlcnMgW0Jvb2xlYW5dICBXaGV0aGVyIHRvIHJldHVybiBudW1iZXJzIGFzIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyVmFsdWUgb2JqZWN0IGluc3RlYWQgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGluZyB0aGVtIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuIFRoaXMgYWxsb3dzIGZvciB0aGUgc2FmZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZC10cmlwIHRyYW5zcG9ydCBvZiBudW1iZXJzIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyeSBzaXplLlxuICAgKiBAcmV0dXJuIFttYXBdIEFuIG9iamVjdCBpbiB0aGUgQW1hem9uIER5bmFtb0RCIEF0dHJpYnV0ZVZhbHVlIGZvcm1hdFxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi5Db252ZXJ0ZXIubWFyc2hhbGwgQVdTLkR5bmFtb0RCLkNvbnZlcnRlci5tYXJzaGFsbCB0b1xuICAgKiAgICBjb252ZXJ0IGVudGlyZSByZWNvcmRzIChyYXRoZXIgdGhhbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMpXG4gICAqL1xuICBpbnB1dDogZnVuY3Rpb24gY29udmVydElucHV0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdHlwZSA9IHR5cGVPZihkYXRhKTtcbiAgICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHJldHVybiBmb3JtYXRNYXAoZGF0YSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgICByZXR1cm4gZm9ybWF0TGlzdChkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdTZXQnKSB7XG4gICAgICByZXR1cm4gZm9ybWF0U2V0KGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiBvcHRpb25zLmNvbnZlcnRFbXB0eVZhbHVlcykge1xuICAgICAgICByZXR1cm4gY29udmVydElucHV0KG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgUzogZGF0YSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicgfHwgdHlwZSA9PT0gJ051bWJlclZhbHVlJykge1xuICAgICAgcmV0dXJuIHsgTjogZGF0YS50b1N0cmluZygpIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIG9wdGlvbnMuY29udmVydEVtcHR5VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0SW5wdXQobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBCOiBkYXRhIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB7IEJPT0w6IGRhdGEgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudWxsJykge1xuICAgICAgcmV0dXJuIHsgTlVMTDogdHJ1ZSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZSAhPT0gJ0Z1bmN0aW9uJykge1xuICAgICAgLy8gdGhpcyB2YWx1ZSBoYXMgYSBjdXN0b20gY29uc3RydWN0b3JcbiAgICAgIHJldHVybiBmb3JtYXRNYXAoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgSmF2YVNjcmlwdCBvYmplY3QgaW50byBhIER5bmFtb0RCIHJlY29yZC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgW2FueV0gVGhlIGRhdGEgdG8gY29udmVydCB0byBhIER5bmFtb0RCIHJlY29yZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBbbWFwXVxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29udmVydEVtcHR5VmFsdWVzIFtCb29sZWFuXSBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydCBlbXB0eSBzdHJpbmdzLCBibG9icyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHNldHMgdG8gYG51bGxgXG4gICAqIEBvcHRpb24gb3B0aW9ucyB3cmFwTnVtYmVycyBbQm9vbGVhbl0gIFdoZXRoZXIgdG8gcmV0dXJuIG51bWJlcnMgYXMgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXJWYWx1ZSBvYmplY3QgaW5zdGVhZCBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0aW5nIHRoZW0gdG8gbmF0aXZlIEphdmFTY3JpcHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycy4gVGhpcyBhbGxvd3MgZm9yIHRoZSBzYWZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kLXRyaXAgdHJhbnNwb3J0IG9mIG51bWJlcnMgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJiaXRyYXJ5IHNpemUuXG4gICAqXG4gICAqIEByZXR1cm4gW21hcF0gQW4gb2JqZWN0IGluIHRoZSBEeW5hbW9EQiByZWNvcmQgZm9ybWF0LlxuICAgKlxuICAgKiBAZXhhbXBsZSBDb252ZXJ0IGEgSmF2YVNjcmlwdCBvYmplY3QgaW50byBhIER5bmFtb0RCIHJlY29yZFxuICAgKiAgdmFyIG1hcnNoYWxsZWQgPSBBV1MuRHluYW1vREIuQ29udmVydGVyLm1hcnNoYWxsKHtcbiAgICogICAgc3RyaW5nOiAnZm9vJyxcbiAgICogICAgbGlzdDogWydmaXp6JywgJ2J1enonLCAncG9wJ10sXG4gICAqICAgIG1hcDoge1xuICAgKiAgICAgIG5lc3RlZE1hcDoge1xuICAgKiAgICAgICAga2V5OiAndmFsdWUnLFxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgbnVtYmVyOiAxMjMsXG4gICAqICAgIG51bGxWYWx1ZTogbnVsbCxcbiAgICogICAgYm9vbFZhbHVlOiB0cnVlLFxuICAgKiAgICBzdHJpbmdTZXQ6IG5ldyBEeW5hbW9EQlNldChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gICAqICB9KTtcbiAgICovXG4gIG1hcnNoYWxsOiBmdW5jdGlvbiBtYXJzaGFsbEl0ZW0oZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBBV1MuRHluYW1vREIuQ29udmVydGVyLmlucHV0KGRhdGEsIG9wdGlvbnMpLk07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBEeW5hbW9EQiBBdHRyaWJ1dGVWYWx1ZSBvYmplY3QgdG8gaXRzIGVxdWl2YWxlbnQgSmF2YVNjcmlwdCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBbbWFwXSBBbiBvYmplY3QgaW4gdGhlIEFtYXpvbiBEeW5hbW9EQiBBdHRyaWJ1dGVWYWx1ZSBmb3JtYXRcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF1cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbnZlcnRFbXB0eVZhbHVlcyBbQm9vbGVhbl0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnQgZW1wdHkgc3RyaW5ncywgYmxvYnMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzZXRzIHRvIGBudWxsYFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgd3JhcE51bWJlcnMgW0Jvb2xlYW5dICBXaGV0aGVyIHRvIHJldHVybiBudW1iZXJzIGFzIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyVmFsdWUgb2JqZWN0IGluc3RlYWQgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGluZyB0aGVtIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuIFRoaXMgYWxsb3dzIGZvciB0aGUgc2FmZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZC10cmlwIHRyYW5zcG9ydCBvZiBudW1iZXJzIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyeSBzaXplLlxuICAgKlxuICAgKiBAcmV0dXJuIFtPYmplY3R8QXJyYXl8U3RyaW5nfE51bWJlcnxCb29sZWFufG51bGxdXG4gICAqXG4gICAqIEBzZWUgQVdTLkR5bmFtb0RCLkNvbnZlcnRlci51bm1hcnNoYWxsIEFXUy5EeW5hbW9EQi5Db252ZXJ0ZXIudW5tYXJzaGFsbCB0b1xuICAgKiAgICBjb252ZXJ0IGVudGlyZSByZWNvcmRzIChyYXRoZXIgdGhhbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMpXG4gICAqL1xuICBvdXRwdXQ6IGZ1bmN0aW9uIGNvbnZlcnRPdXRwdXQoZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBsaXN0LCBtYXAsIGk7XG4gICAgZm9yICh2YXIgdHlwZSBpbiBkYXRhKSB7XG4gICAgICB2YXIgdmFsdWVzID0gZGF0YVt0eXBlXTtcbiAgICAgIGlmICh0eXBlID09PSAnTScpIHtcbiAgICAgICAgbWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICBtYXBba2V5XSA9IGNvbnZlcnRPdXRwdXQodmFsdWVzW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMJykge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2goY29udmVydE91dHB1dCh2YWx1ZXNbaV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1NTJykge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2godmFsdWVzW2ldICsgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1vREJTZXQobGlzdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOUycpIHtcbiAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGNvbnZlcnROdW1iZXIodmFsdWVzW2ldLCBvcHRpb25zLndyYXBOdW1iZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEeW5hbW9EQlNldChsaXN0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0JTJykge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnB1c2goQVdTLnV0aWwuYnVmZmVyLnRvQnVmZmVyKHZhbHVlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1vREJTZXQobGlzdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdTJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzICsgJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOJykge1xuICAgICAgICByZXR1cm4gY29udmVydE51bWJlcih2YWx1ZXMsIG9wdGlvbnMud3JhcE51bWJlcnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnQicpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuYnVmZmVyLnRvQnVmZmVyKHZhbHVlcyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdCT09MJykge1xuICAgICAgICByZXR1cm4gKHZhbHVlcyA9PT0gJ3RydWUnIHx8IHZhbHVlcyA9PT0gJ1RSVUUnIHx8IHZhbHVlcyA9PT0gdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOVUxMJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBEeW5hbW9EQiByZWNvcmQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBbYW55XSBUaGUgRHluYW1vREIgcmVjb3JkXG4gICAqIEBwYXJhbSBvcHRpb25zIFttYXBdXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb252ZXJ0RW1wdHlWYWx1ZXMgW0Jvb2xlYW5dIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0IGVtcHR5IHN0cmluZ3MsIGJsb2JzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2V0cyB0byBgbnVsbGBcbiAgICogQG9wdGlvbiBvcHRpb25zIHdyYXBOdW1iZXJzIFtCb29sZWFuXSAgV2hldGhlciB0byByZXR1cm4gbnVtYmVycyBhcyBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlclZhbHVlIG9iamVjdCBpbnN0ZWFkIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRpbmcgdGhlbSB0byBuYXRpdmUgSmF2YVNjcmlwdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLiBUaGlzIGFsbG93cyBmb3IgdGhlIHNhZmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQtdHJpcCB0cmFuc3BvcnQgb2YgbnVtYmVycyBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmJpdHJhcnkgc2l6ZS5cbiAgICpcbiAgICogQHJldHVybiBbbWFwXSBBbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBoYXZlIGJlZW4gY29udmVydGVkIGZyb21cbiAgICogICAgRHluYW1vREIncyBBdHRyaWJ1dGVWYWx1ZSBmb3JtYXQgaW50byB0aGVpciBjb3JyZXNwb25kaW5nIG5hdGl2ZVxuICAgKiAgICBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBDb252ZXJ0IGEgcmVjb3JkIHJlY2VpdmVkIGZyb20gYSBEeW5hbW9EQiBzdHJlYW1cbiAgICogIHZhciB1bm1hcnNoYWxsZWQgPSBBV1MuRHluYW1vREIuQ29udmVydGVyLnVubWFyc2hhbGwoe1xuICAgKiAgICBzdHJpbmc6IHtTOiAnZm9vJ30sXG4gICAqICAgIGxpc3Q6IHtMOiBbe1M6ICdmaXp6J30sIHtTOiAnYnV6eid9LCB7UzogJ3BvcCd9XX0sXG4gICAqICAgIG1hcDoge1xuICAgKiAgICAgIE06IHtcbiAgICogICAgICAgIG5lc3RlZE1hcDoge1xuICAgKiAgICAgICAgICBNOiB7XG4gICAqICAgICAgICAgICAga2V5OiB7UzogJ3ZhbHVlJ31cbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgbnVtYmVyOiB7TjogJzEyMyd9LFxuICAgKiAgICBudWxsVmFsdWU6IHtOVUxMOiB0cnVlfSxcbiAgICogICAgYm9vbFZhbHVlOiB7Qk9PTDogdHJ1ZX1cbiAgICogIH0pO1xuICAgKi9cbiAgdW5tYXJzaGFsbDogZnVuY3Rpb24gdW5tYXJzaGFsbChkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFXUy5EeW5hbW9EQi5Db252ZXJ0ZXIub3V0cHV0KHtNOiBkYXRhfSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcGFyYW0gZGF0YSBbQXJyYXldXG4gKiBAcGFyYW0gb3B0aW9ucyBbbWFwXVxuICovXG5mdW5jdGlvbiBmb3JtYXRMaXN0KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpc3QgPSB7TDogW119O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0WydMJ10ucHVzaChBV1MuRHluYW1vREIuQ29udmVydGVyLmlucHV0KGRhdGFbaV0sIG9wdGlvbnMpKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXVxuICogQHBhcmFtIHdyYXBOdW1iZXJzIFtCb29sZWFuXVxuICovXG5mdW5jdGlvbiBjb252ZXJ0TnVtYmVyKHZhbHVlLCB3cmFwTnVtYmVycykge1xuICByZXR1cm4gd3JhcE51bWJlcnMgPyBuZXcgTnVtYmVyVmFsdWUodmFsdWUpIDogTnVtYmVyKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwYXJhbSBkYXRhIFttYXBdXG4gKiBAcGFyYW0gb3B0aW9ucyBbbWFwXVxuICovXG5mdW5jdGlvbiBmb3JtYXRNYXAoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgbWFwID0ge006IHt9fTtcbiAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICB2YXIgZm9ybWF0dGVkID0gQVdTLkR5bmFtb0RCLkNvbnZlcnRlci5pbnB1dChkYXRhW2tleV0sIG9wdGlvbnMpO1xuICAgIGlmIChmb3JtYXR0ZWQgIT09IHZvaWQgMCkge1xuICAgICAgbWFwWydNJ11ba2V5XSA9IGZvcm1hdHRlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2V0KGRhdGEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB2YWx1ZXMgPSBkYXRhLnZhbHVlcztcbiAgaWYgKG9wdGlvbnMuY29udmVydEVtcHR5VmFsdWVzKSB7XG4gICAgdmFsdWVzID0gZmlsdGVyRW1wdHlTZXRWYWx1ZXMoZGF0YSk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBBV1MuRHluYW1vREIuQ29udmVydGVyLmlucHV0KG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXAgPSB7fTtcbiAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOiBtYXBbJ1NTJ10gPSB2YWx1ZXM7IGJyZWFrO1xuICAgIGNhc2UgJ0JpbmFyeSc6IG1hcFsnQlMnXSA9IHZhbHVlczsgYnJlYWs7XG4gICAgY2FzZSAnTnVtYmVyJzogbWFwWydOUyddID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckVtcHR5U2V0VmFsdWVzKHNldCkge1xuICAgIHZhciBub25FbXB0eVZhbHVlcyA9IFtdO1xuICAgIHZhciBwb3RlbnRpYWxseUVtcHR5VHlwZXMgPSB7XG4gICAgICAgIFN0cmluZzogdHJ1ZSxcbiAgICAgICAgQmluYXJ5OiB0cnVlLFxuICAgICAgICBOdW1iZXI6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAocG90ZW50aWFsbHlFbXB0eVR5cGVzW3NldC50eXBlXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZXQudmFsdWVzW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9uRW1wdHlWYWx1ZXMucHVzaChzZXQudmFsdWVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub25FbXB0eVZhbHVlcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnZhbHVlcztcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuRHluYW1vREIuQ29udmVydGVyO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBUcmFuc2xhdG9yID0gcmVxdWlyZSgnLi90cmFuc2xhdG9yJyk7XG52YXIgRHluYW1vREJTZXQgPSByZXF1aXJlKCcuL3NldCcpO1xuXG4vKipcbiAqIFRoZSBkb2N1bWVudCBjbGllbnQgc2ltcGxpZmllcyB3b3JraW5nIHdpdGggaXRlbXMgaW4gQW1hem9uIER5bmFtb0RCXG4gKiBieSBhYnN0cmFjdGluZyBhd2F5IHRoZSBub3Rpb24gb2YgYXR0cmlidXRlIHZhbHVlcy4gVGhpcyBhYnN0cmFjdGlvblxuICogYW5ub3RhdGVzIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzIHN1cHBsaWVkIGFzIGlucHV0IHBhcmFtZXRlcnMsIGFzIHdlbGxcbiAqIGFzIGNvbnZlcnRzIGFubm90YXRlZCByZXNwb25zZSBkYXRhIHRvIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICpcbiAqICMjIE1hcnNoYWxsaW5nIElucHV0IGFuZCBVbm1hcnNoYWxsaW5nIFJlc3BvbnNlIERhdGFcbiAqXG4gKiBUaGUgZG9jdW1lbnQgY2xpZW50IGFmZm9yZHMgZGV2ZWxvcGVycyB0aGUgdXNlIG9mIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzXG4gKiBpbnN0ZWFkIG9mIGBBdHRyaWJ1dGVWYWx1ZWBzIHRvIHNpbXBsaWZ5IHRoZSBKYXZhU2NyaXB0IGRldmVsb3BtZW50XG4gKiBleHBlcmllbmNlIHdpdGggQW1hem9uIER5bmFtb0RCLiBKYXZhU2NyaXB0IG9iamVjdHMgcGFzc2VkIGluIGFzIHBhcmFtZXRlcnNcbiAqIGFyZSBtYXJzaGFsbGVkIGludG8gYEF0dHJpYnV0ZVZhbHVlYCBzaGFwZXMgcmVxdWlyZWQgYnkgQW1hem9uIER5bmFtb0RCLlxuICogUmVzcG9uc2VzIGZyb20gRHluYW1vREIgYXJlIHVubWFyc2hhbGxlZCBpbnRvIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0c1xuICogYnkgdGhlIGBEb2N1bWVudENsaWVudGAuIFRoZSBgRG9jdW1lbnRDbGllbnRgLCBkb2VzIG5vdCBhY2NlcHRcbiAqIGBBdHRyaWJ1dGVWYWx1ZWBzIGluIGZhdm9yIG9mIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICpcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEphdmFTY3JpcHQgVHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IER5bmFtb0RCIEF0dHJpYnV0ZVZhbHVlIHxcbiAqIHw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFMgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQm9vbGVhbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJPT0wgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgbnVsbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5VTEwgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgT2JqZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE0gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQnVmZmVyLCBGaWxlLCBCbG9iLCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIGFuZCBKYXZhU2NyaXB0IHR5cGVkIGFycmF5cyB8IEIgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiAjIyBTdXBwb3J0IGZvciBTZXRzXG4gKlxuICogVGhlIGBEb2N1bWVudENsaWVudGAgb2ZmZXJzIGEgY29udmVuaWVudCB3YXkgdG8gY3JlYXRlIHNldHMgZnJvbVxuICogSmF2YVNjcmlwdCBBcnJheXMuIFRoZSB0eXBlIG9mIHNldCBpcyBpbmZlcnJlZCBmcm9tIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBpbiB0aGUgYXJyYXkuIER5bmFtb0RCIHN1cHBvcnRzIHN0cmluZywgbnVtYmVyLCBhbmQgYmluYXJ5IHNldHMuIFRvXG4gKiBsZWFybiBtb3JlIGFib3V0IHN1cHBvcnRlZCB0eXBlcyBzZWUgdGhlXG4gKiBbQW1hem9uIER5bmFtb0RCIERhdGEgTW9kZWwgRG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vYW1hem9uZHluYW1vZGIvbGF0ZXN0L2RldmVsb3Blcmd1aWRlL0RhdGFNb2RlbC5odG1sKVxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIHtBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQuY3JlYXRlU2V0fVxuICpcbiAqL1xuQVdTLkR5bmFtb0RCLkRvY3VtZW50Q2xpZW50ID0gQVdTLnV0aWwuaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEeW5hbW9EQiBkb2N1bWVudCBjbGllbnQgd2l0aCBhIHNldCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbXMgW21hcF0gQW4gb3B0aW9uYWwgbWFwIG9mIHBhcmFtZXRlcnMgdG8gYmluZCB0byBldmVyeVxuICAgKiAgIHJlcXVlc3Qgc2VudCBieSB0aGlzIHNlcnZpY2Ugb2JqZWN0LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2VydmljZSBbQVdTLkR5bmFtb0RCXSBBbiBvcHRpb25hbCBwcmUtY29uZmlndXJlZCBpbnN0YW5jZVxuICAgKiAgb2YgdGhlIEFXUy5EeW5hbW9EQiBzZXJ2aWNlIG9iamVjdCB0byB1c2UgZm9yIHJlcXVlc3RzLiBUaGUgb2JqZWN0IG1heVxuICAgKiAgYm91bmQgcGFyYW1ldGVycyB1c2VkIGJ5IHRoZSBkb2N1bWVudCBjbGllbnQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb252ZXJ0RW1wdHlWYWx1ZXMgW0Jvb2xlYW5dIHNldCB0byB0cnVlIGlmIHlvdSB3b3VsZCBsaWtlXG4gICAqICB0aGUgZG9jdW1lbnQgY2xpZW50IHRvIGNvbnZlcnQgZW1wdHkgdmFsdWVzICgwLWxlbmd0aCBzdHJpbmdzLCBiaW5hcnlcbiAgICogIGJ1ZmZlcnMsIGFuZCBzZXRzKSB0byBiZSBjb252ZXJ0ZWQgdG8gTlVMTCB0eXBlcyB3aGVuIHBlcnNpc3RpbmcgdG9cbiAgICogIER5bmFtb0RCLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgd3JhcE51bWJlcnMgW0Jvb2xlYW5dIFNldCB0byB0cnVlIHRvIHJldHVybiBudW1iZXJzIGFzIGFcbiAgICogIE51bWJlclZhbHVlIG9iamVjdCBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgdGhlbSB0byBuYXRpdmUgSmF2YVNjcmlwdCBudW1iZXJzLlxuICAgKiAgVGhpcyBhbGxvd3MgZm9yIHRoZSBzYWZlIHJvdW5kLXRyaXAgdHJhbnNwb3J0IG9mIG51bWJlcnMgb2YgYXJiaXRyYXJ5IHNpemUuXG4gICAqIEBzZWUgQVdTLkR5bmFtb0RCLmNvbnN0cnVjdG9yXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gRG9jdW1lbnRDbGllbnQob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHNlbGYuY29uZmlndXJlKHNlbGYub3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlndXJlOiBmdW5jdGlvbiBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnNlcnZpY2UgPSBvcHRpb25zLnNlcnZpY2U7XG4gICAgc2VsZi5iaW5kU2VydmljZU9iamVjdChvcHRpb25zKTtcbiAgICBzZWxmLmF0dHJWYWx1ZSA9IG9wdGlvbnMuYXR0clZhbHVlID1cbiAgICAgIHNlbGYuc2VydmljZS5hcGkub3BlcmF0aW9ucy5wdXRJdGVtLmlucHV0Lm1lbWJlcnMuSXRlbS52YWx1ZS5zaGFwZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBiaW5kU2VydmljZU9iamVjdDogZnVuY3Rpb24gYmluZFNlcnZpY2VPYmplY3Qob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghc2VsZi5zZXJ2aWNlKSB7XG4gICAgICBzZWxmLnNlcnZpY2UgPSBuZXcgQVdTLkR5bmFtb0RCKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwuY29weShzZWxmLnNlcnZpY2UuY29uZmlnKTtcbiAgICAgIHNlbGYuc2VydmljZSA9IG5ldyBzZWxmLnNlcnZpY2UuY29uc3RydWN0b3IuX19zdXBlcl9fKGNvbmZpZyk7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcyA9XG4gICAgICAgIEFXUy51dGlsLm1lcmdlKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zIHx8IHt9LCBvcHRpb25zLnBhcmFtcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1ha2VTZXJ2aWNlUmVxdWVzdDogZnVuY3Rpb24ob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXF1ZXN0ID0gc2VsZi5zZXJ2aWNlW29wZXJhdGlvbl0ocGFyYW1zKTtcbiAgICBzZWxmLnNldHVwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBzZWxmLnNldHVwUmVzcG9uc2UocmVxdWVzdCk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2VydmljZUNsaWVudE9wZXJhdGlvbnNNYXA6IHtcbiAgICBiYXRjaEdldDogJ2JhdGNoR2V0SXRlbScsXG4gICAgYmF0Y2hXcml0ZTogJ2JhdGNoV3JpdGVJdGVtJyxcbiAgICBkZWxldGU6ICdkZWxldGVJdGVtJyxcbiAgICBnZXQ6ICdnZXRJdGVtJyxcbiAgICBwdXQ6ICdwdXRJdGVtJyxcbiAgICBxdWVyeTogJ3F1ZXJ5JyxcbiAgICBzY2FuOiAnc2NhbicsXG4gICAgdXBkYXRlOiAndXBkYXRlSXRlbScsXG4gICAgdHJhbnNhY3RHZXQ6ICd0cmFuc2FjdEdldEl0ZW1zJyxcbiAgICB0cmFuc2FjdFdyaXRlOiAndHJhbnNhY3RXcml0ZUl0ZW1zJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIG9mIG9uZSBvciBtb3JlIGl0ZW1zIGZyb20gb25lIG9yIG1vcmUgdGFibGVzXG4gICAqIGJ5IGRlbGVnYXRpbmcgdG8gYEFXUy5EeW5hbW9EQi5iYXRjaEdldEl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIuYmF0Y2hHZXRJdGVtfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi5iYXRjaEdldEl0ZW1cbiAgICogQGV4YW1wbGUgR2V0IGl0ZW1zIGZyb20gbXVsdGlwbGUgdGFibGVzXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBSZXF1ZXN0SXRlbXM6IHtcbiAgICogICAgICAnVGFibGUtMSc6IHtcbiAgICogICAgICAgIEtleXM6IFtcbiAgICogICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBIYXNoS2V5OiAnaGFza2V5JyxcbiAgICogICAgICAgICAgICAgTnVtYmVyUmFuZ2VLZXk6IDFcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICAgXVxuICAgKiAgICAgIH0sXG4gICAqICAgICAgJ1RhYmxlLTInOiB7XG4gICAqICAgICAgICBLZXlzOiBbXG4gICAqICAgICAgICAgIHsgZm9vOiAnYmFyJyB9LFxuICAgKiAgICAgICAgXVxuICAgKiAgICAgIH1cbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LmJhdGNoR2V0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIGJhdGNoR2V0OiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMuc2VydmljZUNsaWVudE9wZXJhdGlvbnNNYXBbJ2JhdGNoR2V0J107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1dHMgb3IgZGVsZXRlcyBtdWx0aXBsZSBpdGVtcyBpbiBvbmUgb3IgbW9yZSB0YWJsZXMgYnkgZGVsZWdhdGluZ1xuICAgKiB0byBgQVdTLkR5bmFtb0RCLmJhdGNoV3JpdGVJdGVtKClgLlxuICAgKlxuICAgKiBTdXBwbHkgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB7QVdTLkR5bmFtb0RCLmJhdGNoV3JpdGVJdGVtfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi5iYXRjaFdyaXRlSXRlbVxuICAgKiBAZXhhbXBsZSBXcml0ZSB0byBhbmQgZGVsZXRlIGZyb20gYSB0YWJsZVxuICAgKiAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgUmVxdWVzdEl0ZW1zOiB7XG4gICAqICAgICAgJ1RhYmxlLTEnOiBbXG4gICAqICAgICAgICB7XG4gICAqICAgICAgICAgIERlbGV0ZVJlcXVlc3Q6IHtcbiAgICogICAgICAgICAgICBLZXk6IHsgSGFzaEtleTogJ3NvbWVLZXknIH1cbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICAgfSxcbiAgICogICAgICAgIHtcbiAgICogICAgICAgICAgUHV0UmVxdWVzdDoge1xuICAgKiAgICAgICAgICAgIEl0ZW06IHtcbiAgICogICAgICAgICAgICAgIEhhc2hLZXk6ICdhbm90aGVyS2V5JyxcbiAgICogICAgICAgICAgICAgIE51bUF0dHJpYnV0ZTogMSxcbiAgICogICAgICAgICAgICAgIEJvb2xBdHRyaWJ1dGU6IHRydWUsXG4gICAqICAgICAgICAgICAgICBMaXN0QXR0cmlidXRlOiBbMSwgJ3R3bycsIGZhbHNlXSxcbiAgICogICAgICAgICAgICAgIE1hcEF0dHJpYnV0ZTogeyBmb286ICdiYXInIH1cbiAgICogICAgICAgICAgICB9XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICAgIH1cbiAgICogICAgICBdXG4gICAqICAgIH1cbiAgICogIH07XG4gICAqXG4gICAqICB2YXIgZG9jdW1lbnRDbGllbnQgPSBuZXcgQVdTLkR5bmFtb0RCLkRvY3VtZW50Q2xpZW50KCk7XG4gICAqXG4gICAqICBkb2N1bWVudENsaWVudC5iYXRjaFdyaXRlKHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIGJhdGNoV3JpdGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsnYmF0Y2hXcml0ZSddO1xuICAgIHJldHVybiB0aGlzLm1ha2VTZXJ2aWNlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc2luZ2xlIGl0ZW0gaW4gYSB0YWJsZSBieSBwcmltYXJ5IGtleSBieSBkZWxlZ2F0aW5nIHRvXG4gICAqIGBBV1MuRHluYW1vREIuZGVsZXRlSXRlbSgpYFxuICAgKlxuICAgKiBTdXBwbHkgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB7QVdTLkR5bmFtb0RCLmRlbGV0ZUl0ZW19IHdpdGhcbiAgICogYEF0dHJpYnV0ZVZhbHVlYHMgc3Vic3RpdHV0ZWQgYnkgbmF0aXZlIEphdmFTY3JpcHQgdHlwZXMuXG4gICAqXG4gICAqIEBzZWUgQVdTLkR5bmFtb0RCLmRlbGV0ZUl0ZW1cbiAgICogQGV4YW1wbGUgRGVsZXRlIGFuIGl0ZW0gZnJvbSBhIHRhYmxlXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUYWJsZU5hbWUgOiAnVGFibGUnLFxuICAgKiAgICBLZXk6IHtcbiAgICogICAgICBIYXNoS2V5OiAnaGFzaGtleScsXG4gICAqICAgICAgTnVtYmVyUmFuZ2VLZXk6IDFcbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LmRlbGV0ZShwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpO1xuICAgKiAgICBlbHNlIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgfSk7XG4gICAqXG4gICAqL1xuICBkZWxldGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsnZGVsZXRlJ107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXQgb2YgYXR0cmlidXRlcyBmb3IgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4gcHJpbWFyeSBrZXlcbiAgICogYnkgZGVsZWdhdGluZyB0byBgQVdTLkR5bmFtb0RCLmdldEl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIuZ2V0SXRlbX0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIuZ2V0SXRlbVxuICAgKiBAZXhhbXBsZSBHZXQgYW4gaXRlbSBmcm9tIGEgdGFibGVcbiAgICogIHZhciBwYXJhbXMgPSB7XG4gICAqICAgIFRhYmxlTmFtZSA6ICdUYWJsZScsXG4gICAqICAgIEtleToge1xuICAgKiAgICAgIEhhc2hLZXk6ICdoYXNoa2V5J1xuICAgKiAgICB9XG4gICAqICB9O1xuICAgKlxuICAgKiAgdmFyIGRvY3VtZW50Q2xpZW50ID0gbmV3IEFXUy5EeW5hbW9EQi5Eb2N1bWVudENsaWVudCgpO1xuICAgKlxuICAgKiAgZG9jdW1lbnRDbGllbnQuZ2V0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIGdldDogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnNlcnZpY2VDbGllbnRPcGVyYXRpb25zTWFwWydnZXQnXTtcbiAgICByZXR1cm4gdGhpcy5tYWtlU2VydmljZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVtLCBvciByZXBsYWNlcyBhbiBvbGQgaXRlbSB3aXRoIGEgbmV3IGl0ZW0gYnlcbiAgICogZGVsZWdhdGluZyB0byBgQVdTLkR5bmFtb0RCLnB1dEl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIucHV0SXRlbX0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIucHV0SXRlbVxuICAgKiBAZXhhbXBsZSBDcmVhdGUgYSBuZXcgaXRlbSBpbiBhIHRhYmxlXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUYWJsZU5hbWUgOiAnVGFibGUnLFxuICAgKiAgICBJdGVtOiB7XG4gICAqICAgICAgIEhhc2hLZXk6ICdoYXNrZXknLFxuICAgKiAgICAgICBOdW1BdHRyaWJ1dGU6IDEsXG4gICAqICAgICAgIEJvb2xBdHRyaWJ1dGU6IHRydWUsXG4gICAqICAgICAgIExpc3RBdHRyaWJ1dGU6IFsxLCAndHdvJywgZmFsc2VdLFxuICAgKiAgICAgICBNYXBBdHRyaWJ1dGU6IHsgZm9vOiAnYmFyJ30sXG4gICAqICAgICAgIE51bGxBdHRyaWJ1dGU6IG51bGxcbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LnB1dChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpO1xuICAgKiAgICBlbHNlIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgfSk7XG4gICAqXG4gICAqL1xuICBwdXQ6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsncHV0J107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVkaXRzIGFuIGV4aXN0aW5nIGl0ZW0ncyBhdHRyaWJ1dGVzLCBvciBhZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIHRhYmxlIGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QgYnkgZGVsZWdhdGluZyB0byBgQVdTLkR5bmFtb0RCLnVwZGF0ZUl0ZW0oKWAuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIudXBkYXRlSXRlbX0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIudXBkYXRlSXRlbVxuICAgKiBAZXhhbXBsZSBVcGRhdGUgYW4gaXRlbSB3aXRoIGV4cHJlc3Npb25zXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUYWJsZU5hbWU6ICdUYWJsZScsXG4gICAqICAgIEtleTogeyBIYXNoS2V5IDogJ2hhc2hrZXknIH0sXG4gICAqICAgIFVwZGF0ZUV4cHJlc3Npb246ICdzZXQgI2EgPSA6eCArIDp5JyxcbiAgICogICAgQ29uZGl0aW9uRXhwcmVzc2lvbjogJyNhIDwgOk1BWCcsXG4gICAqICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczogeycjYScgOiAnU3VtJ30sXG4gICAqICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICogICAgICAnOngnIDogMjAsXG4gICAqICAgICAgJzp5JyA6IDQ1LFxuICAgKiAgICAgICc6TUFYJyA6IDEwMCxcbiAgICogICAgfVxuICAgKiAgfTtcbiAgICpcbiAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICpcbiAgICogIGRvY3VtZW50Q2xpZW50LnVwZGF0ZShwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnNlcnZpY2VDbGllbnRPcGVyYXRpb25zTWFwWyd1cGRhdGUnXTtcbiAgICByZXR1cm4gdGhpcy5tYWtlU2VydmljZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvbmUgb3IgbW9yZSBpdGVtcyBhbmQgaXRlbSBhdHRyaWJ1dGVzIGJ5IGFjY2Vzc2luZyBldmVyeSBpdGVtXG4gICAqIGluIGEgdGFibGUgb3IgYSBzZWNvbmRhcnkgaW5kZXguXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIuc2Nhbn0gd2l0aFxuICAgKiBgQXR0cmlidXRlVmFsdWVgcyBzdWJzdGl0dXRlZCBieSBuYXRpdmUgSmF2YVNjcmlwdCB0eXBlcy5cbiAgICpcbiAgICogQHNlZSBBV1MuRHluYW1vREIuc2NhblxuICAgKiBAZXhhbXBsZSBTY2FuIHRoZSB0YWJsZSB3aXRoIGEgZmlsdGVyIGV4cHJlc3Npb25cbiAgICogIHZhciBwYXJhbXMgPSB7XG4gICAqICAgIFRhYmxlTmFtZSA6ICdUYWJsZScsXG4gICAqICAgIEZpbHRlckV4cHJlc3Npb24gOiAnWWVhciA9IDp0aGlzX3llYXInLFxuICAgKiAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzIDogeyc6dGhpc195ZWFyJyA6IDIwMTV9XG4gICAqICB9O1xuICAgKlxuICAgKiAgdmFyIGRvY3VtZW50Q2xpZW50ID0gbmV3IEFXUy5EeW5hbW9EQi5Eb2N1bWVudENsaWVudCgpO1xuICAgKlxuICAgKiAgZG9jdW1lbnRDbGllbnQuc2NhbihwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICpcbiAgICovXG4gIHNjYW46IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsnc2NhbiddO1xuICAgIHJldHVybiB0aGlzLm1ha2VTZXJ2aWNlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gICAvKipcbiAgICAqIERpcmVjdGx5IGFjY2VzcyBpdGVtcyBmcm9tIGEgdGFibGUgYnkgcHJpbWFyeSBrZXkgb3IgYSBzZWNvbmRhcnkgaW5kZXguXG4gICAgKlxuICAgICogU3VwcGx5IHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMge0FXUy5EeW5hbW9EQi5xdWVyeX0gd2l0aFxuICAgICogYEF0dHJpYnV0ZVZhbHVlYHMgc3Vic3RpdHV0ZWQgYnkgbmF0aXZlIEphdmFTY3JpcHQgdHlwZXMuXG4gICAgKlxuICAgICogQHNlZSBBV1MuRHluYW1vREIucXVlcnlcbiAgICAqIEBleGFtcGxlIFF1ZXJ5IGFuIGluZGV4XG4gICAgKiAgdmFyIHBhcmFtcyA9IHtcbiAgICAqICAgIFRhYmxlTmFtZTogJ1RhYmxlJyxcbiAgICAqICAgIEluZGV4TmFtZTogJ0luZGV4JyxcbiAgICAqICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246ICdIYXNoS2V5ID0gOmhrZXkgYW5kIFJhbmdlS2V5ID4gOnJrZXknLFxuICAgICogICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICogICAgICAnOmhrZXknOiAna2V5JyxcbiAgICAqICAgICAgJzpya2V5JzogMjAxNVxuICAgICogICAgfVxuICAgICogIH07XG4gICAgKlxuICAgICogIHZhciBkb2N1bWVudENsaWVudCA9IG5ldyBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQoKTtcbiAgICAqXG4gICAgKiAgZG9jdW1lbnRDbGllbnQucXVlcnkocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpO1xuICAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAgKiAgfSk7XG4gICAgKlxuICAgICovXG4gIHF1ZXJ5OiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMuc2VydmljZUNsaWVudE9wZXJhdGlvbnNNYXBbJ3F1ZXJ5J107XG4gICAgcmV0dXJuIHRoaXMubWFrZVNlcnZpY2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIHdyaXRlIG9wZXJhdGlvbiB0aGF0IGdyb3VwcyB1cCB0byAyNSBhY3Rpb24gcmVxdWVzdHMuXG4gICAqXG4gICAqIFN1cHBseSB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHtBV1MuRHluYW1vREIudHJhbnNhY3RXcml0ZUl0ZW1zfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi50cmFuc2FjdFdyaXRlSXRlbXNcbiAgICogQGV4YW1wbGUgR2V0IGl0ZW1zIGZyb20gbXVsdGlwbGUgdGFibGVzXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBUcmFuc2FjdEl0ZW1zOiBbe1xuICAgKiAgICAgIFB1dDoge1xuICAgKiAgICAgICAgVGFibGVOYW1lIDogJ1RhYmxlMCcsXG4gICAqICAgICAgICBJdGVtOiB7XG4gICAqICAgICAgICAgIEhhc2hLZXk6ICdoYXNrZXknLFxuICAgKiAgICAgICAgICBOdW1BdHRyaWJ1dGU6IDEsXG4gICAqICAgICAgICAgIEJvb2xBdHRyaWJ1dGU6IHRydWUsXG4gICAqICAgICAgICAgIExpc3RBdHRyaWJ1dGU6IFsxLCAndHdvJywgZmFsc2VdLFxuICAgKiAgICAgICAgICBNYXBBdHRyaWJ1dGU6IHsgZm9vOiAnYmFyJ30sXG4gICAqICAgICAgICAgIE51bGxBdHRyaWJ1dGU6IG51bGxcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sIHtcbiAgICogICAgICBVcGRhdGU6IHtcbiAgICogICAgICAgIFRhYmxlTmFtZTogJ1RhYmxlMScsXG4gICAqICAgICAgICBLZXk6IHsgSGFzaEtleSA6ICdoYXNoa2V5JyB9LFxuICAgKiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ3NldCAjYSA9IDp4ICsgOnknLFxuICAgKiAgICAgICAgQ29uZGl0aW9uRXhwcmVzc2lvbjogJyNhIDwgOk1BWCcsXG4gICAqICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHsnI2EnIDogJ1N1bSd9LFxuICAgKiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgKiAgICAgICAgICAnOngnIDogMjAsXG4gICAqICAgICAgICAgICc6eScgOiA0NSxcbiAgICogICAgICAgICAgJzpNQVgnIDogMTAwLFxuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfV1cbiAgICogIH07XG4gICAqXG4gICAqICBkb2N1bWVudENsaWVudC50cmFuc2FjdFdyaXRlKHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gICAqICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICB9KTtcbiAgICovXG4gIHRyYW5zYWN0V3JpdGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsndHJhbnNhY3RXcml0ZSddO1xuICAgIHJldHVybiB0aGlzLm1ha2VTZXJ2aWNlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdG9taWNhbGx5IHJldHJpZXZlcyBtdWx0aXBsZSBpdGVtcyBmcm9tIG9uZSBvciBtb3JlIHRhYmxlcyAoYnV0IG5vdCBmcm9tIGluZGV4ZXMpXG4gICAqIGluIGEgc2luZ2xlIGFjY291bnQgYW5kIHJlZ2lvbi5cbiAgICpcbiAgICogU3VwcGx5IHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMge0FXUy5EeW5hbW9EQi50cmFuc2FjdEdldEl0ZW1zfSB3aXRoXG4gICAqIGBBdHRyaWJ1dGVWYWx1ZWBzIHN1YnN0aXR1dGVkIGJ5IG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGVzLlxuICAgKlxuICAgKiBAc2VlIEFXUy5EeW5hbW9EQi50cmFuc2FjdEdldEl0ZW1zXG4gICAqIEBleGFtcGxlIEdldCBpdGVtcyBmcm9tIG11bHRpcGxlIHRhYmxlc1xuICAgKiAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgVHJhbnNhY3RJdGVtczogW3tcbiAgICogICAgICBHZXQ6IHtcbiAgICogICAgICAgIFRhYmxlTmFtZSA6ICdUYWJsZTAnLFxuICAgKiAgICAgICAgS2V5OiB7XG4gICAqICAgICAgICAgIEhhc2hLZXk6ICdoYXNoa2V5MCdcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sIHtcbiAgICogICAgICBHZXQ6IHtcbiAgICogICAgICAgIFRhYmxlTmFtZSA6ICdUYWJsZTEnLFxuICAgKiAgICAgICAgS2V5OiB7XG4gICAqICAgICAgICAgIEhhc2hLZXk6ICdoYXNoa2V5MSdcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH1dXG4gICAqICB9O1xuICAgKlxuICAgKiAgZG9jdW1lbnRDbGllbnQudHJhbnNhY3RHZXQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogIH0pO1xuICAgKi9cbiAgdHJhbnNhY3RHZXQ6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5zZXJ2aWNlQ2xpZW50T3BlcmF0aW9uc01hcFsndHJhbnNhY3RHZXQnXTtcbiAgICByZXR1cm4gdGhpcy5tYWtlU2VydmljZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNldCBvZiBlbGVtZW50cyBpbmZlcnJpbmcgdGhlIHR5cGUgb2Ygc2V0IGZyb21cbiAgICogdGhlIHR5cGUgb2YgdGhlIGZpcnN0IGVsZW1lbnQuIEFtYXpvbiBEeW5hbW9EQiBjdXJyZW50bHkgc3VwcG9ydHNcbiAgICogdGhlIG51bWJlciBzZXRzLCBzdHJpbmcgc2V0cywgYW5kIGJpbmFyeSBzZXRzLiBGb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKiBhYm91dCBEeW5hbW9EQiBkYXRhIHR5cGVzIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvbiB0aGVcbiAgICogW0FtYXpvbiBEeW5hbW9EQiBEYXRhIE1vZGVsXShodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9hbWF6b25keW5hbW9kYi9sYXRlc3QvZGV2ZWxvcGVyZ3VpZGUvRGF0YU1vZGVsLmh0bWwjRGF0YU1vZGVsLkRhdGFUeXBlcykuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IFtBcnJheV0gQ29sbGVjdGlvbiB0byByZXByZXNlbnQgeW91ciBEeW5hbW9EQiBTZXRcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF1cbiAgICogICogKip2YWxpZGF0ZSoqIFtCb29sZWFuXSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB2YWxpZGF0ZSB0aGUgdHlwZVxuICAgKiAgICBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBudW1iZXIgc2V0XG4gICAqICB2YXIgZG9jdW1lbnRDbGllbnQgPSBuZXcgQVdTLkR5bmFtb0RCLkRvY3VtZW50Q2xpZW50KCk7XG4gICAqXG4gICAqICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICBJdGVtOiB7XG4gICAqICAgICAgaGFzaGtleTogJ2hhc2hrZXknXG4gICAqICAgICAgbnVtYmVyczogZG9jdW1lbnRDbGllbnQuY3JlYXRlU2V0KFsxLCAyLCAzXSk7XG4gICAqICAgIH1cbiAgICogIH07XG4gICAqXG4gICAqICBkb2N1bWVudENsaWVudC5wdXQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgICogICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogIH0pO1xuICAgKlxuICAgKi9cbiAgY3JlYXRlU2V0OiBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG5ldyBEeW5hbW9EQlNldChsaXN0LCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRUcmFuc2xhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXR1cFJlcXVlc3Q6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0cmFuc2xhdG9yID0gc2VsZi5nZXRUcmFuc2xhdG9yKCk7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlcXVlc3Qub3BlcmF0aW9uO1xuICAgIHZhciBpbnB1dFNoYXBlID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0uaW5wdXQ7XG4gICAgcmVxdWVzdC5fZXZlbnRzLnZhbGlkYXRlLnVuc2hpZnQoZnVuY3Rpb24ocmVxKSB7XG4gICAgICByZXEucmF3UGFyYW1zID0gQVdTLnV0aWwuY29weShyZXEucGFyYW1zKTtcbiAgICAgIHJlcS5wYXJhbXMgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZUlucHV0KHJlcS5yYXdQYXJhbXMsIGlucHV0U2hhcGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVzcG9uc2U6IGZ1bmN0aW9uIHNldHVwUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHJhbnNsYXRvciA9IHNlbGYuZ2V0VHJhbnNsYXRvcigpO1xuICAgIHZhciBvdXRwdXRTaGFwZSA9IHNlbGYuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0ub3V0cHV0O1xuICAgIHJlcXVlc3Qub24oJ2V4dHJhY3REYXRhJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZU91dHB1dChyZXNwb25zZS5kYXRhLCBvdXRwdXRTaGFwZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIHJlc3BvbnNlLm5leHRQYWdlID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciByZXNwID0gdGhpcztcbiAgICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgICB2YXIgY29uZmlnO1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSByZXEub3BlcmF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnID0gc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7IHJlc3AuZXJyb3IgPSBlOyB9XG5cbiAgICAgIGlmICghcmVzcC5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgIGlmIChjYikgY2IocmVzcC5lcnJvciwgbnVsbCk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3AuZXJyb3IpIHRocm93IHJlc3AuZXJyb3I7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weShyZXEucmF3UGFyYW1zKTtcbiAgICAgIGlmICghcmVzcC5uZXh0UGFnZVRva2Vucykge1xuICAgICAgICByZXR1cm4gY2IgPyBjYihudWxsLCBudWxsKSA6IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5wdXRUb2tlbnMgPSBjb25maWcuaW5wdXRUb2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFRva2VucyA9PT0gJ3N0cmluZycpIGlucHV0VG9rZW5zID0gW2lucHV0VG9rZW5zXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcmFtc1tpbnB1dFRva2Vuc1tpXV0gPSByZXNwLm5leHRQYWdlVG9rZW5zW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmW29wZXJhdGlvbl0ocGFyYW1zLCBjYik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuRHluYW1vREIuRG9jdW1lbnRDbGllbnQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xuXG4vKipcbiAqIEFuIG9iamVjdCByZWNvZ25pemFibGUgYXMgYSBudW1lcmljIHZhbHVlIHRoYXQgc3RvcmVzIHRoZSB1bmRlcmx5aW5nIG51bWJlclxuICogYXMgYSBzdHJpbmcuXG4gKlxuICogSW50ZW5kZWQgdG8gYmUgYSBkZXNlcmlhbGl6YXRpb24gdGFyZ2V0IGZvciB0aGUgRHluYW1vREIgRG9jdW1lbnQgQ2xpZW50IHdoZW5cbiAqIHRoZSBgd3JhcE51bWJlcnNgIGZsYWcgaXMgc2V0LiBUaGlzIGFsbG93cyBmb3IgbnVtZXJpYyB2YWx1ZXMgdGhhdCBsb3NlXG4gKiBwcmVjaXNpb24gd2hlbiBjb252ZXJ0ZWQgdG8gSmF2YVNjcmlwdCdzIGBudW1iZXJgIHR5cGUuXG4gKi9cbnZhciBEeW5hbW9EQk51bWJlclZhbHVlID0gdXRpbC5pbmhlcml0KHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIE51bWJlclZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy53cmFwcGVyTmFtZSA9ICdOdW1iZXJWYWx1ZSc7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgdW5kZXJseWluZyB2YWx1ZSBhcyBhIG51bWJlciB3aGVuIGNvbnZlcnRpbmcgdG8gSlNPTi5cbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHVuZGVybHlpbmcgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICovXG4gIHRvTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLnZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdW5hbHRlcmVkIHZhbHVlIHByb3ZpZGVkIHRvIHRoZVxuICAgKiBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtb0RCTnVtYmVyVmFsdWU7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIHR5cGVPZiA9IHJlcXVpcmUoJy4vdHlwZXMnKS50eXBlT2Y7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBtZW1iZXJUeXBlVG9TZXRUeXBlID0ge1xuICAnU3RyaW5nJzogJ1N0cmluZycsXG4gICdOdW1iZXInOiAnTnVtYmVyJyxcbiAgJ051bWJlclZhbHVlJzogJ051bWJlcicsXG4gICdCaW5hcnknOiAnQmluYXJ5J1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIER5bmFtb0RCU2V0ID0gdXRpbC5pbmhlcml0KHtcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2V0KGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLndyYXBwZXJOYW1lID0gJ1NldCc7XG4gICAgdGhpcy5pbml0aWFsaXplKGxpc3QsIG9wdGlvbnMudmFsaWRhdGUpO1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxpc3QsIHZhbGlkYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudmFsdWVzID0gW10uY29uY2F0KGxpc3QpO1xuICAgIHNlbGYuZGV0ZWN0VHlwZSgpO1xuICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgc2VsZi52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICBkZXRlY3RUeXBlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnR5cGUgPSBtZW1iZXJUeXBlVG9TZXRUeXBlW3R5cGVPZih0aGlzLnZhbHVlc1swXSldO1xuICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkU2V0VHlwZScsXG4gICAgICAgIG1lc3NhZ2U6ICdTZXRzIGNhbiBjb250YWluIHN0cmluZywgbnVtYmVyLCBvciBiaW5hcnkgdmFsdWVzJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlbmd0aCA9IHNlbGYudmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gc2VsZi52YWx1ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1lbWJlclR5cGVUb1NldFR5cGVbdHlwZU9mKHZhbHVlc1tpXSldICE9PSBzZWxmLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgIGNvZGU6ICdJbnZhbGlkVHlwZScsXG4gICAgICAgICAgbWVzc2FnZTogc2VsZi50eXBlICsgJyBTZXQgY29udGFpbnMgJyArIHR5cGVPZih2YWx1ZXNbaV0pICsgJyB2YWx1ZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHVuZGVybHlpbmcgdmFsdWVzIG9ubHkgd2hlbiBjb252ZXJ0aW5nIHRvIEpTT04uXG4gICAqL1xuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gc2VsZi52YWx1ZXM7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRHluYW1vREJTZXQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIGNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnRlcicpO1xuXG52YXIgVHJhbnNsYXRvciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuYXR0clZhbHVlID0gb3B0aW9ucy5hdHRyVmFsdWU7XG4gIHRoaXMuY29udmVydEVtcHR5VmFsdWVzID0gQm9vbGVhbihvcHRpb25zLmNvbnZlcnRFbXB0eVZhbHVlcyk7XG4gIHRoaXMud3JhcE51bWJlcnMgPSBCb29sZWFuKG9wdGlvbnMud3JhcE51bWJlcnMpO1xufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlSW5wdXQgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgdGhpcy5tb2RlID0gJ2lucHV0JztcbiAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKHZhbHVlLCBzaGFwZSk7XG59O1xuXG5UcmFuc2xhdG9yLnByb3RvdHlwZS50cmFuc2xhdGVPdXRwdXQgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgdGhpcy5tb2RlID0gJ291dHB1dCc7XG4gIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpO1xufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKCFzaGFwZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGlmIChzaGFwZS5zaGFwZSA9PT0gc2VsZi5hdHRyVmFsdWUpIHtcbiAgICByZXR1cm4gY29udmVydFtzZWxmLm1vZGVdKHZhbHVlLCB7XG4gICAgICBjb252ZXJ0RW1wdHlWYWx1ZXM6IHNlbGYuY29udmVydEVtcHR5VmFsdWVzLFxuICAgICAgd3JhcE51bWJlcnM6IHNlbGYud3JhcE51bWJlcnMsXG4gICAgfSk7XG4gIH1cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHNlbGYudHJhbnNsYXRlU3RydWN0dXJlKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHNlbGYudHJhbnNsYXRlTWFwKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiBzZWxmLnRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gc2VsZi50cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKTtcbiAgfVxufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlU3RydWN0dXJlID0gZnVuY3Rpb24oc3RydWN0dXJlLCBzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzdHJ1Y3R1cmUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgc3RydWN0ID0ge307XG4gIHV0aWwuZWFjaChzdHJ1Y3R1cmUsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1tuYW1lXTtcbiAgICBpZiAobWVtYmVyU2hhcGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBzZWxmLnRyYW5zbGF0ZSh2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBzdHJ1Y3RbbmFtZV0gPSByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cnVjdDtcbn07XG5cblRyYW5zbGF0b3IucHJvdG90eXBlLnRyYW5zbGF0ZUxpc3QgPSBmdW5jdGlvbihsaXN0LCBzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBzZWxmLnRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dC5wdXNoKG51bGwpO1xuICAgIGVsc2Ugb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5UcmFuc2xhdG9yLnByb3RvdHlwZS50cmFuc2xhdGVNYXAgPSBmdW5jdGlvbihtYXAsIHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKG1hcCA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHZhciBvdXQgPSB7fTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBzZWxmLnRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSBudWxsO1xuICAgIGVsc2Ugb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuVHJhbnNsYXRvci5wcm90b3R5cGUudHJhbnNsYXRlU2NhbGFyID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1R5cGUodmFsdWUpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2xhdG9yO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcblxuZnVuY3Rpb24gdHlwZU9mKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSBlbHNlIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgaXNCaW5hcnkoZGF0YSkpIHtcbiAgICByZXR1cm4gJ0JpbmFyeSc7XG4gIH0gZWxzZSBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZGF0YS53cmFwcGVyTmFtZSB8fCB1dGlsLnR5cGVOYW1lKGRhdGEuY29uc3RydWN0b3IpO1xuICB9IGVsc2UgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyB0aGlzIG9iamVjdCBpcyB0aGUgcmVzdWx0IG9mIE9iamVjdC5jcmVhdGUobnVsbCksIGhlbmNlIHRoZSBhYnNlbmNlIG9mIGFcbiAgICAvLyBkZWZpbmVkIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShkYXRhKSB7XG4gIHZhciB0eXBlcyA9IFtcbiAgICAnQnVmZmVyJywgJ0ZpbGUnLCAnQmxvYicsICdBcnJheUJ1ZmZlcicsICdEYXRhVmlldycsXG4gICAgJ0ludDhBcnJheScsICdVaW50OEFycmF5JywgJ1VpbnQ4Q2xhbXBlZEFycmF5JyxcbiAgICAnSW50MTZBcnJheScsICdVaW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ1VpbnQzMkFycmF5JyxcbiAgICAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheSdcbiAgXTtcbiAgaWYgKHV0aWwuaXNOb2RlKCkpIHtcbiAgICB2YXIgU3RyZWFtID0gdXRpbC5zdHJlYW0uU3RyZWFtO1xuICAgIGlmICh1dGlsLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhIGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAodXRpbC5pc1R5cGUoZGF0YSwgdHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh1dGlsLnR5cGVOYW1lKGRhdGEuY29uc3RydWN0b3IpID09PSB0eXBlc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHlwZU9mOiB0eXBlT2YsXG4gIGlzQmluYXJ5OiBpc0JpbmFyeVxufTtcbiIsInZhciBldmVudE1lc3NhZ2VDaHVua2VyID0gcmVxdWlyZSgnLi4vZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlcicpLmV2ZW50TWVzc2FnZUNodW5rZXI7XG52YXIgcGFyc2VFdmVudCA9IHJlcXVpcmUoJy4vcGFyc2UtZXZlbnQnKS5wYXJzZUV2ZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbShib2R5LCBwYXJzZXIsIG1vZGVsKSB7XG4gICAgdmFyIGV2ZW50TWVzc2FnZXMgPSBldmVudE1lc3NhZ2VDaHVua2VyKGJvZHkpO1xuXG4gICAgdmFyIGV2ZW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKHBhcnNlRXZlbnQocGFyc2VyLCBldmVudE1lc3NhZ2VzW2ldLCBtb2RlbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudHM7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUV2ZW50U3RyZWFtOiBjcmVhdGVFdmVudFN0cmVhbVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZScpLnV0aWw7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xudmFyIGFsbG9jQnVmZmVyID0gdXRpbC5idWZmZXIuYWxsb2M7XG5cbi8qKiBAdHlwZSB7VHJhbnNmb3JtfSAqL1xuZnVuY3Rpb24gRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbShvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoID0gMDtcbiAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7QnVmZmVyfSAqL1xuICAgIHRoaXMubWVzc2FnZUxlbmd0aEJ1ZmZlciA9IG51bGw7XG59XG5cbkV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAqL1xuRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB2YXIgY2h1bmtMZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSAwO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRPZmZzZXQgPCBjaHVua0xlbmd0aCkge1xuICAgICAgICAvLyBjcmVhdGUgbmV3IG1lc3NhZ2UgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50TWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gd29ya2luZyBvbiBhIG5ldyBtZXNzYWdlLCBkZXRlcm1pbmUgdG90YWwgbGVuZ3RoXG4gICAgICAgICAgICB2YXIgYnl0ZXNSZW1haW5pbmcgPSBjaHVua0xlbmd0aCAtIGN1cnJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGVkZ2UgY2FzZSB3aGVyZSB0b3RhbCBsZW5ndGggc3BhbnMgMiBjaHVua3NcbiAgICAgICAgICAgIGlmICghdGhpcy5tZXNzYWdlTGVuZ3RoQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlTGVuZ3RoQnVmZmVyID0gYWxsb2NCdWZmZXIoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtQnl0ZXNGb3JUb3RhbCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIDQgLSB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCwgLy8gcmVtYWluaW5nIGJ5dGVzIHRvIGZpbGwgdGhlIG1lc3NhZ2VMZW5ndGhCdWZmZXJcbiAgICAgICAgICAgICAgICBieXRlc1JlbWFpbmluZyAvLyBieXRlcyBsZWZ0IGluIGNodW5rXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjaHVuay5jb3B5KFxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUxlbmd0aEJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXJyZW50T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgKyBudW1CeXRlc0ZvclRvdGFsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCArPSBudW1CeXRlc0ZvclRvdGFsO1xuICAgICAgICAgICAgY3VycmVudE9mZnNldCArPSBudW1CeXRlc0ZvclRvdGFsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhlIGN1cnJlbnQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZU1lc3NhZ2UodGhpcy5tZXNzYWdlTGVuZ3RoQnVmZmVyLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VMZW5ndGhCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JpdGUgZGF0YSBpbnRvIGN1cnJlbnQgbWVzc2FnZVxuICAgICAgICB2YXIgbnVtQnl0ZXNUb1dyaXRlID0gTWF0aC5taW4oXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggLSB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCwgLy8gbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gY29tcGxldGUgbWVzc2FnZVxuICAgICAgICAgICAgY2h1bmtMZW5ndGggLSBjdXJyZW50T2Zmc2V0IC8vIG51bWJlciBvZiBieXRlcyBsZWZ0IGluIHRoZSBvcmlnaW5hbCBjaHVua1xuICAgICAgICApO1xuICAgICAgICBjaHVuay5jb3B5KFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSwgLy8gdGFyZ2V0IGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGgsIC8vIHRhcmdldCBvZmZzZXRcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQsIC8vIGNodW5rIG9mZnNldFxuICAgICAgICAgICAgY3VycmVudE9mZnNldCArIG51bUJ5dGVzVG9Xcml0ZSAvLyBjaHVuayBlbmQgdG8gd3JpdGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggKz0gbnVtQnl0ZXNUb1dyaXRlO1xuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IG51bUJ5dGVzVG9Xcml0ZTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhIG1lc3NhZ2UgaXMgcmVhZHkgdG8gYmUgcHVzaGVkXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggJiYgdGhpcy5jdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID09PSB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCkge1xuICAgICAgICAgICAgLy8gcHVzaCBvdXQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnRNZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG59O1xuXG5FdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lc3NhZ2VUb3RhbExlbmd0aCA9PT0gdGhpcy5jdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuY3VycmVudE1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUcnVuY2F0ZWQgZXZlbnQgbWVzc2FnZSByZWNlaXZlZC4nKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgU2l6ZSBvZiB0aGUgbWVzc2FnZSB0byBiZSBhbGxvY2F0ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuRXZlbnRNZXNzYWdlQ2h1bmtlclN0cmVhbS5wcm90b3R5cGUuYWxsb2NhdGVNZXNzYWdlID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gYWxsb2NhdGUgYW4gZXZlbnQgbWVzc2FnZSB3aGVyZSBzaXplIHdhcyBub3QgYSBudW1iZXI6ICcgKyBzaXplKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID0gc2l6ZTtcbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCA9IDQ7XG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IGFsbG9jQnVmZmVyKHNpemUpO1xuICAgIHRoaXMuY3VycmVudE1lc3NhZ2Uud3JpdGVVSW50MzJCRShzaXplLCAwKTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW06IEV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW1cbn07XG4iLCIvKipcbiAqIFRha2VzIGluIGEgYnVmZmVyIG9mIGV2ZW50IG1lc3NhZ2VzIGFuZCBzcGxpdHMgdGhlbSBpbnRvIGluZGl2aWR1YWwgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRNZXNzYWdlQ2h1bmtlcihidWZmZXIpIHtcbiAgICAvKiogQHR5cGUgQnVmZmVyW10gKi9cbiAgICB2YXIgbWVzc2FnZXMgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IGJ1ZmZlci5yZWFkSW50MzJCRShvZmZzZXQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgYnVmZmVyIGZvciBpbmRpdmlkdWFsIG1lc3NhZ2UgKHNoYXJlcyBtZW1vcnkgd2l0aCBvcmlnaW5hbClcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCB0b3RhbExlbmd0aCArIG9mZnNldCk7XG4gICAgICAgIC8vIGluY3JlbWVudCBvZmZzZXQgdG8gaXQgc3RhcnRzIGF0IHRoZSBuZXh0IG1lc3NhZ2VcbiAgICAgICAgb2Zmc2V0ICs9IHRvdGFsTGVuZ3RoO1xuXG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBldmVudE1lc3NhZ2VDaHVua2VyOiBldmVudE1lc3NhZ2VDaHVua2VyXG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbnZhciBwYXJzZUV2ZW50ID0gcmVxdWlyZSgnLi9wYXJzZS1ldmVudCcpLnBhcnNlRXZlbnQ7XG5cbi8qKiBAdHlwZSB7VHJhbnNmb3JtfSAqL1xuZnVuY3Rpb24gRXZlbnRVbm1hcnNoYWxsZXJTdHJlYW0ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIHNldCBvdXRwdXQgdG8gb2JqZWN0IG1vZGVcbiAgICBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSA9IHRydWU7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG4gICAgdGhpcy5ldmVudFN0cmVhbU1vZGVsID0gb3B0aW9ucy5ldmVudFN0cmVhbU1vZGVsO1xufVxuXG5FdmVudFVubWFyc2hhbGxlclN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICovXG5FdmVudFVubWFyc2hhbGxlclN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZXZlbnQgPSBwYXJzZUV2ZW50KHRoaXMucGFyc2VyLCBjaHVuaywgdGhpcy5ldmVudFN0cmVhbU1vZGVsKTtcbiAgICAgICAgdGhpcy5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXZlbnRVbm1hcnNoYWxsZXJTdHJlYW06IEV2ZW50VW5tYXJzaGFsbGVyU3RyZWFtXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcbnZhciB0b0J1ZmZlciA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgcmVwcmVzZW50YXRpb24gb2YgYSBzaWduZWQsIDY0LWJpdCBpbnRlZ2VyLiBJbnN0YW5jZXMgb2YgdGhpc1xuICogY2xhc3MgbWF5IGJlIHVzZWQgaW4gYXJpdGhtZXRpYyBleHByZXNzaW9ucyBhcyBpZiB0aGV5IHdlcmUgbnVtZXJpY1xuICogcHJpbWl0aXZlcywgYnV0IHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gd2lsbCBiZSBwcmVzZXJ2ZWQgdW5jaGFuZ2VkIGFzIHRoZVxuICogYGJ5dGVzYCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LiBUaGUgYnl0ZXMgc2hvdWxkIGJlIGVuY29kZWQgYXMgYmlnLWVuZGlhbixcbiAqIHR3bydzIGNvbXBsZW1lbnQgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnl0ZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gSW50NjQoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50NjQgYnVmZmVycyBtdXN0IGJlIGV4YWN0bHkgOCBieXRlcycpO1xuICAgIH1cbiAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKSkgYnl0ZXMgPSB0b0J1ZmZlcihieXRlcyk7XG5cbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICogQHJldHVybnMge0ludDY0fVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5JbnQ2NC5mcm9tTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA+IDkyMjMzNzIwMzY4NTQ3NzU4MDcgfHwgbnVtYmVyIDwgLTkyMjMzNzIwMzY4NTQ3NzU4MDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgbnVtYmVyICsgJyBpcyB0b28gbGFyZ2UgKG9yLCBpZiBuZWdhdGl2ZSwgdG9vIHNtYWxsKSB0byByZXByZXNlbnQgYXMgYW4gSW50NjQnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgZm9yIChcbiAgICAgICAgdmFyIGkgPSA3LCByZW1haW5pbmcgPSBNYXRoLmFicyhNYXRoLnJvdW5kKG51bWJlcikpO1xuICAgICAgICBpID4gLTEgJiYgcmVtYWluaW5nID4gMDtcbiAgICAgICAgaS0tLCByZW1haW5pbmcgLz0gMjU2XG4gICAgKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIG5lZ2F0ZShieXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnQ2NChieXRlcyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkludDY0LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcy5zbGljZSgwKTtcbiAgICB2YXIgbmVnYXRpdmUgPSBieXRlc1swXSAmIDEyODtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbmVnYXRlKGJ5dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VJbnQoYnl0ZXMudG9TdHJpbmcoJ2hleCcpLCAxNikgKiAobmVnYXRpdmUgPyAtMSA6IDEpO1xufTtcblxuSW50NjQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBieXRlc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZWdhdGUoYnl0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSBePSAweEZGO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gNzsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgYnl0ZXNbaV0rKztcbiAgICAgICAgaWYgKGJ5dGVzW2ldICE9PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSW50NjQ6IEludDY0XG59O1xuIiwidmFyIHBhcnNlTWVzc2FnZSA9IHJlcXVpcmUoJy4vcGFyc2UtbWVzc2FnZScpLnBhcnNlTWVzc2FnZTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBwYXJzZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0geyp9IHNoYXBlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudChwYXJzZXIsIG1lc3NhZ2UsIHNoYXBlKSB7XG4gICAgdmFyIHBhcnNlZE1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAvLyBjaGVjayBpZiBtZXNzYWdlIGlzIGFuIGV2ZW50IG9yIGVycm9yXG4gICAgdmFyIG1lc3NhZ2VUeXBlID0gcGFyc2VkTWVzc2FnZS5oZWFkZXJzWyc6bWVzc2FnZS10eXBlJ107XG4gICAgaWYgKG1lc3NhZ2VUeXBlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZS52YWx1ZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnJvcihwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZS52YWx1ZSAhPT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgaG93IHRvIHBhcnNlIG5vbi1ldmVudHMvbm9uLWVycm9ycywgaWdub3JlIGZvciBub3dcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBldmVudCB0eXBlXG4gICAgdmFyIGV2ZW50VHlwZSA9IHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1snOmV2ZW50LXR5cGUnXTtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBldmVudCB0eXBlIGlzIG1vZGVsZWRcbiAgICB2YXIgZXZlbnRNb2RlbCA9IHNoYXBlLm1lbWJlcnNbZXZlbnRUeXBlLnZhbHVlXTtcbiAgICBpZiAoIWV2ZW50TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAvLyBjaGVjayBpZiBhbiBldmVudCBwYXlsb2FkIGV4aXN0c1xuICAgIHZhciBldmVudFBheWxvYWRNZW1iZXJOYW1lID0gZXZlbnRNb2RlbC5ldmVudFBheWxvYWRNZW1iZXJOYW1lO1xuICAgIGlmIChldmVudFBheWxvYWRNZW1iZXJOYW1lKSB7XG4gICAgICAgIHZhciBwYXlsb2FkU2hhcGUgPSBldmVudE1vZGVsLm1lbWJlcnNbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV07XG4gICAgICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBiaW5hcnksIHJldHVybiB0aGUgYnl0ZSBhcnJheVxuICAgICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgICByZXN1bHRbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV0gPSBwYXJzZWRNZXNzYWdlLmJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV0gPSBwYXJzZXIucGFyc2UocGFyc2VkTWVzc2FnZS5ib2R5LnRvU3RyaW5nKCksIHBheWxvYWRTaGFwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFkIGV2ZW50IGhlYWRlcnNcbiAgICB2YXIgZXZlbnRIZWFkZXJOYW1lcyA9IGV2ZW50TW9kZWwuZXZlbnRIZWFkZXJNZW1iZXJOYW1lcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SGVhZGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBldmVudEhlYWRlck5hbWVzW2ldO1xuICAgICAgICBpZiAocGFyc2VkTWVzc2FnZS5oZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgaGVhZGVyIVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gZXZlbnRNb2RlbC5tZW1iZXJzW25hbWVdLnRvVHlwZShwYXJzZWRNZXNzYWdlLmhlYWRlcnNbbmFtZV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIG91dHB1dFtldmVudFR5cGUudmFsdWVdID0gcmVzdWx0O1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBlcnJvckNvZGUgPSBtZXNzYWdlLmhlYWRlcnNbJzplcnJvci1jb2RlJ107XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UuaGVhZGVyc1snOmVycm9yLW1lc3NhZ2UnXTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlLnZhbHVlIHx8IGVycm9yTWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLm5hbWUgPSBlcnJvckNvZGUudmFsdWUgfHwgZXJyb3JDb2RlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VFdmVudDogcGFyc2VFdmVudFxufTtcbiIsInZhciBJbnQ2NCA9IHJlcXVpcmUoJy4vaW50NjQnKS5JbnQ2NDtcblxudmFyIHNwbGl0TWVzc2FnZSA9IHJlcXVpcmUoJy4vc3BsaXQtbWVzc2FnZScpLnNwbGl0TWVzc2FnZTtcblxudmFyIEJPT0xFQU5fVEFHID0gJ2Jvb2xlYW4nO1xudmFyIEJZVEVfVEFHID0gJ2J5dGUnO1xudmFyIFNIT1JUX1RBRyA9ICdzaG9ydCc7XG52YXIgSU5UX1RBRyA9ICdpbnRlZ2VyJztcbnZhciBMT05HX1RBRyA9ICdsb25nJztcbnZhciBCSU5BUllfVEFHID0gJ2JpbmFyeSc7XG52YXIgU1RSSU5HX1RBRyA9ICdzdHJpbmcnO1xudmFyIFRJTUVTVEFNUF9UQUcgPSAndGltZXN0YW1wJztcbnZhciBVVUlEX1RBRyA9ICd1dWlkJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHdoaWxlIChwb3NpdGlvbiA8IGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuYW1lTGVuZ3RoID0gaGVhZGVycy5yZWFkVUludDgocG9zaXRpb24rKyk7XG4gICAgICAgIHZhciBuYW1lID0gaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBuYW1lTGVuZ3RoKS50b1N0cmluZygpO1xuICAgICAgICBwb3NpdGlvbiArPSBuYW1lTGVuZ3RoO1xuICAgICAgICBzd2l0Y2ggKGhlYWRlcnMucmVhZFVJbnQ4KHBvc2l0aW9uKyspKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogYm9vbFRydWUgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCT09MRUFOX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIGJvb2xGYWxzZSAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEJPT0xFQU5fVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIGJ5dGUgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCWVRFX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMucmVhZEludDgocG9zaXRpb24rKylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIHNob3J0ICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU0hPUlRfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5yZWFkSW50MTZCRShwb3NpdGlvbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogaW50ZWdlciAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IElOVF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnJlYWRJbnQzMkJFKHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBsb25nICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTE9OR19UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgSW50NjQoaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyA4KSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYgLyogYnl0ZUFycmF5ICovOlxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlMZW5ndGggPSBoZWFkZXJzLnJlYWRVSW50MTZCRShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEJJTkFSWV9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGJpbmFyeUxlbmd0aClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGJpbmFyeUxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBzdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IGhlYWRlcnMucmVhZFVJbnQxNkJFKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU1RSSU5HX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICsgc3RyaW5nTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyaW5nTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4IC8qIHRpbWVzdGFtcCAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRJTUVTVEFNUF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBJbnQ2NChoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiB1dWlkICovOlxuICAgICAgICAgICAgICAgIHZhciB1dWlkQ2hhcnMgPSBoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDE2KVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDE2O1xuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVVVJRF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkQ2hhcnMuc3Vic3RyKDAsIDgpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoOCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigxMiwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigxNiwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigyMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBoZWFkZXIgdHlwZSB0YWcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwYXJzZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHZhciBwYXJzZWQgPSBzcGxpdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgaGVhZGVyczogcGFyc2VIZWFkZXJzKHBhcnNlZC5oZWFkZXJzKSwgYm9keTogcGFyc2VkLmJvZHkgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VNZXNzYWdlOiBwYXJzZU1lc3NhZ2Vcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIHRvQnVmZmVyID0gdXRpbC5idWZmZXIudG9CdWZmZXI7XG5cbi8vIEFsbCBwcmVsdWRlIGNvbXBvbmVudHMgYXJlIHVuc2lnbmVkLCAzMi1iaXQgaW50ZWdlcnNcbnZhciBQUkVMVURFX01FTUJFUl9MRU5HVEggPSA0O1xuLy8gVGhlIHByZWx1ZGUgY29uc2lzdHMgb2YgdHdvIGNvbXBvbmVudHNcbnZhciBQUkVMVURFX0xFTkdUSCA9IFBSRUxVREVfTUVNQkVSX0xFTkdUSCAqIDI7XG4vLyBDaGVja3N1bXMgYXJlIGFsd2F5cyBDUkMzMiBoYXNoZXMuXG52YXIgQ0hFQ0tTVU1fTEVOR1RIID0gNDtcbi8vIE1lc3NhZ2VzIG11c3QgaW5jbHVkZSBhIGZ1bGwgcHJlbHVkZSwgYSBwcmVsdWRlIGNoZWNrc3VtLCBhbmQgYSBtZXNzYWdlIGNoZWNrc3VtXG52YXIgTUlOSU1VTV9NRVNTQUdFX0xFTkdUSCA9IFBSRUxVREVfTEVOR1RIICsgQ0hFQ0tTVU1fTEVOR1RIICogMjtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBzcGxpdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICghdXRpbC5CdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIG1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlKTtcblxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCA8IE1JTklNVU1fTUVTU0FHRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBtZXNzYWdlIHRvbyBzaG9ydCB0byBhY2NvbW1vZGF0ZSBldmVudCBzdHJlYW0gbWVzc2FnZSBvdmVyaGVhZCcpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCAhPT0gbWVzc2FnZS5yZWFkVUludDMyQkUoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXBvcnRlZCBtZXNzYWdlIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCByZWNlaXZlZCBtZXNzYWdlIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RlZFByZWx1ZGVDaGVja3N1bSA9IG1lc3NhZ2UucmVhZFVJbnQzMkJFKFBSRUxVREVfTEVOR1RIKTtcblxuICAgIGlmIChcbiAgICAgICAgZXhwZWN0ZWRQcmVsdWRlQ2hlY2tzdW0gIT09IHV0aWwuY3J5cHRvLmNyYzMyKFxuICAgICAgICAgICAgbWVzc2FnZS5zbGljZSgwLCBQUkVMVURFX0xFTkdUSClcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHByZWx1ZGUgY2hlY2tzdW0gc3BlY2lmaWVkIGluIHRoZSBtZXNzYWdlICgnICtcbiAgICAgICAgICAgIGV4cGVjdGVkUHJlbHVkZUNoZWNrc3VtICtcbiAgICAgICAgICAgICcpIGRvZXMgbm90IG1hdGNoIHRoZSBjYWxjdWxhdGVkIENSQzMyIGNoZWNrc3VtLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwZWN0ZWRNZXNzYWdlQ2hlY2tzdW0gPSBtZXNzYWdlLnJlYWRVSW50MzJCRShtZXNzYWdlLmxlbmd0aCAtIENIRUNLU1VNX0xFTkdUSCk7XG5cbiAgICBpZiAoXG4gICAgICAgIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtICE9PSB1dGlsLmNyeXB0by5jcmMzMihcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2xpY2UoMCwgbWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBtZXNzYWdlIGNoZWNrc3VtIGRpZCBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlIG9mICcgK1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlcnNTdGFydCA9IFBSRUxVREVfTEVOR1RIICsgQ0hFQ0tTVU1fTEVOR1RIO1xuICAgIHZhciBoZWFkZXJzRW5kID0gaGVhZGVyc1N0YXJ0ICsgbWVzc2FnZS5yZWFkVUludDMyQkUoUFJFTFVERV9NRU1CRVJfTEVOR1RIKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcnM6IG1lc3NhZ2Uuc2xpY2UoaGVhZGVyc1N0YXJ0LCBoZWFkZXJzRW5kKSxcbiAgICAgICAgYm9keTogbWVzc2FnZS5zbGljZShoZWFkZXJzRW5kLCBtZXNzYWdlLmxlbmd0aCAtIENIRUNLU1VNX0xFTkdUSCksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3BsaXRNZXNzYWdlOiBzcGxpdE1lc3NhZ2Vcbn07XG4iLCIvKipcbiAqIFdoYXQgaXMgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBhbiBldmVudCBzdHJlYW0gaW4gbm9kZT9cbiAqICAtIGh0dHAgcmVzcG9uc2Ugc3RyZWFtXG4gKiAgLSBwYXJzZXJcbiAqICAtIGV2ZW50IHN0cmVhbSBtb2RlbFxuICovXG5cbnZhciBFdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtID0gcmVxdWlyZSgnLi4vZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlci1zdHJlYW0nKS5FdmVudE1lc3NhZ2VDaHVua2VyU3RyZWFtO1xudmFyIEV2ZW50VW5tYXJzaGFsbGVyU3RyZWFtID0gcmVxdWlyZSgnLi4vZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtdW5tYXJzaGFsbGVyLXN0cmVhbScpLkV2ZW50VW5tYXJzaGFsbGVyU3RyZWFtO1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbShzdHJlYW0sIHBhcnNlciwgbW9kZWwpIHtcbiAgICB2YXIgZXZlbnRTdHJlYW0gPSBuZXcgRXZlbnRVbm1hcnNoYWxsZXJTdHJlYW0oe1xuICAgICAgICBwYXJzZXI6IHBhcnNlcixcbiAgICAgICAgZXZlbnRTdHJlYW1Nb2RlbDogbW9kZWxcbiAgICB9KTtcblxuICAgIHZhciBldmVudE1lc3NhZ2VDaHVua2VyID0gbmV3IEV2ZW50TWVzc2FnZUNodW5rZXJTdHJlYW0oKTtcblxuICAgIHN0cmVhbS5waXBlKFxuICAgICAgICBldmVudE1lc3NhZ2VDaHVua2VyXG4gICAgKS5waXBlKGV2ZW50U3RyZWFtKTtcblxuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgZXZlbnRNZXNzYWdlQ2h1bmtlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICBldmVudE1lc3NhZ2VDaHVua2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBldmVudFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXZlbnRTdHJlYW07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUV2ZW50U3RyZWFtOiBjcmVhdGVFdmVudFN0cmVhbVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBTZXF1ZW50aWFsRXhlY3V0b3IgPSByZXF1aXJlKCcuL3NlcXVlbnRpYWxfZXhlY3V0b3InKTtcbnZhciBESVNDT1ZFUl9FTkRQT0lOVCA9IHJlcXVpcmUoJy4vZGlzY292ZXJfZW5kcG9pbnQnKS5kaXNjb3ZlckVuZHBvaW50O1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIHVzZWQgdG8gcmVnaXN0ZXIgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyBmb3IgcmVxdWVzdCBidWlsZGluZ1xuICogYW5kIHNlbmRpbmcuXG4gKi9cbkFXUy5FdmVudExpc3RlbmVycyA9IHtcbiAgLyoqXG4gICAqIEAhYXR0cmlidXRlIFZBTElEQVRFX0NSRURFTlRJQUxTXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgdmFsaWRhdGVzIHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYmVpbmdcbiAgICogICBzZW50IHdpdGggY3JlZGVudGlhbHMuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnZhbGlkYXRlICd2YWxpZGF0ZScgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRob3V0IHZhbGlkYXRpbmcgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX0NSRURFTlRJQUxTO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBsaXN0ZW5lcik7XG4gICAqICAgQHJlYWRvbmx5XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqIEAhYXR0cmlidXRlIFZBTElEQVRFX1JFR0lPTlxuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHZhbGlkYXRlcyB3aGV0aGVyIHRoZSByZWdpb24gaXMgc2V0XG4gICAqICAgZm9yIGEgcmVxdWVzdC5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+dmFsaWRhdGUgJ3ZhbGlkYXRlJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgdmFsaWRhdGluZyByZWdpb24gY29uZmlndXJhdGlvblxuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBsaXN0ZW5lcik7XG4gICAqICAgQHJlYWRvbmx5XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqIEAhYXR0cmlidXRlIFZBTElEQVRFX1BBUkFNRVRFUlNcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCB2YWxpZGF0ZXMgaW5wdXQgcGFyYW1ldGVycyBpbiBhIHJlcXVlc3QuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnZhbGlkYXRlICd2YWxpZGF0ZScgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRob3V0IHZhbGlkYXRpbmcgcGFyYW1ldGVyc1xuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUztcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgbGlzdGVuZXIpO1xuICAgKiAgIEBleGFtcGxlIERpc2FibGUgcGFyYW1ldGVyIHZhbGlkYXRpb24gZ2xvYmFsbHlcbiAgICogICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsXG4gICAqICAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1JFR0lPTik7XG4gICAqICAgQHJlYWRvbmx5XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqIEAhYXR0cmlidXRlIFNFTkRcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCBpbml0aWF0ZXMgdGhlIEhUVFAgY29ubmVjdGlvbiBmb3IgYVxuICAgKiAgIHJlcXVlc3QgYmVpbmcgc2VudC4gSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnNlbmQgJ3NlbmQnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgUmVwbGFjaW5nIHRoZSBIVFRQIGhhbmRsZXJcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkQ7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdzZW5kJywgbGlzdGVuZXIpO1xuICAgKiAgICAgcmVxdWVzdC5vbignc2VuZCcsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAqICAgICAgIGN1c3RvbUhhbmRsZXIuc2VuZChyZXNwb25zZSk7XG4gICAqICAgICB9KTtcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogICBAcmVhZG9ubHlcbiAgICogQCFhdHRyaWJ1dGUgSFRUUF9EQVRBXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgcmVhZHMgZGF0YSBmcm9tIHRoZSBIVFRQIGNvbm5lY3Rpb24gaW4gb3JkZXJcbiAgICogICB0byBidWlsZCB0aGUgcmVzcG9uc2UgZGF0YS5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+aHR0cERhdGEgJ2h0dHBEYXRhJyBSZXF1ZXN0IGV2ZW50fS5cbiAgICogICBSZW1vdmUgdGhpcyBoYW5kbGVyIGlmIHlvdSBhcmUgb3ZlcnJpZGluZyB0aGUgJ2h0dHBEYXRhJyBldmVudCBhbmRcbiAgICogICBkbyBub3Qgd2FudCBleHRyYSBkYXRhIHByb2Nlc3NpbmcgYW5kIGJ1ZmZlcmluZyBvdmVyaGVhZC5cbiAgICogICBAZXhhbXBsZSBEaXNhYmxpbmcgZGVmYXVsdCBkYXRhIHByb2Nlc3NpbmdcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQTtcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2h0dHBEYXRhJywgbGlzdGVuZXIpO1xuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiAgIEByZWFkb25seVxuICAgKi9cbiAgQ29yZToge30gLyogZG9jIGhhY2sgKi9cbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkF1dGh0eXBlKHJlcSkge1xuICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgcmV0dXJuIG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xufVxuXG5BV1MuRXZlbnRMaXN0ZW5lcnMgPSB7XG4gIENvcmU6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQsIGFkZEFzeW5jKSB7XG4gICAgYWRkQXN5bmMoJ1ZBTElEQVRFX0NSRURFTlRJQUxTJywgJ3ZhbGlkYXRlJyxcbiAgICAgICAgZnVuY3Rpb24gVkFMSURBVEVfQ1JFREVOVElBTFMocmVxLCBkb25lKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uICYmICFyZXEuc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuICAgICAgcmVxLnNlcnZpY2UuY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyLFxuICAgICAgICAgICAge2NvZGU6ICdDcmVkZW50aWFsc0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnLCBpZiB1c2luZyBBV1NfQ09ORklHX0ZJTEUsIHNldCBBV1NfU0RLX0xPQURfQ09ORklHPTEnfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1JFR0lPTicsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIFZBTElEQVRFX1JFR0lPTihyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCkge1xuICAgICAgICB2YXIgZG5zSG9zdFJlZ2V4ID0gbmV3IFJlZ0V4cCgvXihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKSQvKTtcbiAgICAgICAgaWYgKCFyZXEuc2VydmljZS5jb25maWcucmVnaW9uKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAgICB7Y29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgcmVnaW9uIGluIGNvbmZpZyd9KTtcbiAgICAgICAgfSBlbHNlIGlmICghZG5zSG9zdFJlZ2V4LnRlc3QocmVxLnNlcnZpY2UuY29uZmlnLnJlZ2lvbikpIHtcbiAgICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgIHtjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiAnSW52YWxpZCByZWdpb24gaW4gY29uZmlnJ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0JVSUxEX0lERU1QT1RFTkNZX1RPS0VOUycsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIEJVSUxEX0lERU1QT1RFTkNZX1RPS0VOUyhyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICAgICAgaWYgKCFvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlkZW1wb3RlbnRNZW1iZXJzID0gb3BlcmF0aW9uLmlkZW1wb3RlbnRNZW1iZXJzO1xuICAgICAgaWYgKCFpZGVtcG90ZW50TWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlcyBhIGNvcHkgb2YgcGFyYW1zIHNvIHVzZXIncyBwYXJhbSBvYmplY3QgaXNuJ3QgbXV0YXRlZFxuICAgICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocmVxLnBhcmFtcyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGlkZW1wb3RlbnRNZW1iZXJzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICBpZiAoIXBhcmFtc1tpZGVtcG90ZW50TWVtYmVyc1tpXV0pIHtcbiAgICAgICAgICAvLyBhZGQgdGhlIG1lbWJlclxuICAgICAgICAgIHBhcmFtc1tpZGVtcG90ZW50TWVtYmVyc1tpXV0gPSBBV1MudXRpbC51dWlkLnY0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1BBUkFNRVRFUlMnLCAndmFsaWRhdGUnLCBmdW5jdGlvbiBWQUxJREFURV9QQVJBTUVURVJTKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gcmVxLnNlcnZpY2UuY29uZmlnLnBhcmFtVmFsaWRhdGlvbjtcbiAgICAgIG5ldyBBV1MuUGFyYW1WYWxpZGF0b3IodmFsaWRhdGlvbikudmFsaWRhdGUocnVsZXMsIHJlcS5wYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgYWRkKCdDT01QVVRFX0NIRUNLU1VNJywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBDT01QVVRFX0NIRUNLU1VNKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYm9keSA9IHJlcS5odHRwUmVxdWVzdC5ib2R5O1xuICAgICAgdmFyIGlzTm9uU3RyZWFtaW5nUGF5bG9hZCA9IGJvZHkgJiYgKEFXUy51dGlsLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSB8fCB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpO1xuICAgICAgdmFyIGhlYWRlcnMgPSByZXEuaHR0cFJlcXVlc3QuaGVhZGVycztcbiAgICAgIGlmIChcbiAgICAgICAgb3BlcmF0aW9uLmh0dHBDaGVja3N1bVJlcXVpcmVkICYmXG4gICAgICAgIHJlcS5zZXJ2aWNlLmNvbmZpZy5jb21wdXRlQ2hlY2tzdW1zICYmXG4gICAgICAgIGlzTm9uU3RyZWFtaW5nUGF5bG9hZCAmJlxuICAgICAgICAhaGVhZGVyc1snQ29udGVudC1NRDUnXVxuICAgICAgKSB7XG4gICAgICAgIHZhciBtZDUgPSBBV1MudXRpbC5jcnlwdG8ubWQ1KGJvZHksICdiYXNlNjQnKTtcbiAgICAgICAgaGVhZGVyc1snQ29udGVudC1NRDUnXSA9IG1kNTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZEFzeW5jKCdDT01QVVRFX1NIQTI1NicsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gQ09NUFVURV9TSEEyNTYocmVxLCBkb25lKSB7XG4gICAgICByZXEuaGFsdEhhbmRsZXJzT25FcnJvcigpO1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICB2YXIgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb24gJiYgIWF1dGh0eXBlICYmICFyZXEuc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuICAgICAgaWYgKHJlcS5zZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSkgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgICAgIHZhciBib2R5ID0gcmVxLmh0dHBSZXF1ZXN0LmJvZHkgfHwgJyc7XG4gICAgICAgIGlmIChhdXRodHlwZS5pbmRleE9mKCd1bnNpZ25lZC1ib2R5JykgPj0gMCkge1xuICAgICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddID0gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgQVdTLnV0aWwuY29tcHV0ZVNoYTI1Nihib2R5LCBmdW5jdGlvbihlcnIsIHNoYSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9IHNoYTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdTRVRfQ09OVEVOVF9MRU5HVEgnLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIFNFVF9DT05URU5UX0xFTkdUSChyZXEpIHtcbiAgICAgIHZhciBhdXRodHlwZSA9IGdldE9wZXJhdGlvbkF1dGh0eXBlKHJlcSk7XG4gICAgICB2YXIgcGF5bG9hZE1lbWJlciA9IEFXUy51dGlsLmdldFJlcXVlc3RQYXlsb2FkU2hhcGUocmVxKTtcbiAgICAgIGlmIChyZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IEFXUy51dGlsLnN0cmluZy5ieXRlTGVuZ3RoKHJlcS5odHRwUmVxdWVzdC5ib2R5KTtcbiAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGxlbmd0aDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRNZW1iZXIgJiYgcGF5bG9hZE1lbWJlci5pc1N0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKHBheWxvYWRNZW1iZXIucmVxdWlyZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy9zdHJlYW1pbmcgcGF5bG9hZCByZXF1aXJlcyBsZW5ndGgoczMsIGdsYWNpZXIpXG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0aHR5cGUuaW5kZXhPZigndW5zaWduZWQtYm9keScpID49IDApIHtcbiAgICAgICAgICAgICAgLy91bmJvdW5kZWQgc3RyZWFtaW5nIHBheWxvYWQobGV4LCBtZWRpYXN0b3JlKVxuICAgICAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snVHJhbnNmZXItRW5jb2RpbmcnXSA9ICdjaHVua2VkJztcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnU0VUX0hUVFBfSE9TVCcsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gU0VUX0hUVFBfSE9TVChyZXEpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydIb3N0J10gPSByZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICB9KTtcblxuICAgIGFkZCgnUkVTVEFSVCcsICdyZXN0YXJ0JywgZnVuY3Rpb24gUkVTVEFSVCgpIHtcbiAgICAgIHZhciBlcnIgPSB0aGlzLnJlc3BvbnNlLmVycm9yO1xuICAgICAgaWYgKCFlcnIgfHwgIWVyci5yZXRyeWFibGUpIHJldHVybjtcblxuICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QoXG4gICAgICAgIHRoaXMuc2VydmljZS5lbmRwb2ludCxcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnJlZ2lvblxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMucmVzcG9uc2UucmV0cnlDb3VudCA8IHRoaXMuc2VydmljZS5jb25maWcubWF4UmV0cmllcykge1xuICAgICAgICB0aGlzLnJlc3BvbnNlLnJldHJ5Q291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGFkZFRvSGVhZCA9IHRydWU7XG4gICAgYWRkQXN5bmMoJ0RJU0NPVkVSX0VORFBPSU5UJywgJ3NpZ24nLCBESVNDT1ZFUl9FTkRQT0lOVCwgYWRkVG9IZWFkKTtcblxuICAgIGFkZEFzeW5jKCdTSUdOJywgJ3NpZ24nLCBmdW5jdGlvbiBTSUdOKHJlcSwgZG9uZSkge1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciBvcGVyYXRpb25zID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIHZhciBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgICAgaWYgKCFzZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uICYmICFhdXRodHlwZSAmJiAhc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuXG4gICAgICBzZXJ2aWNlLmNvbmZpZy5nZXRDcmVkZW50aWFscyhmdW5jdGlvbiAoZXJyLCBjcmVkZW50aWFscykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkYXRlID0gc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpO1xuICAgICAgICAgIHZhciBTaWduZXJDbGFzcyA9IHNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKTtcbiAgICAgICAgICB2YXIgc2lnbmVyID0gbmV3IFNpZ25lckNsYXNzKHJlcS5odHRwUmVxdWVzdCxcbiAgICAgICAgICAgIHNlcnZpY2UuZ2V0U2lnbmluZ05hbWUocmVxKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlQ2FjaGU6IHNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZUNhY2hlLFxuICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgc2lnbmF0dXJlVmVyc2lvbjogc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgc2lnbmVyLnNldFNlcnZpY2VDbGllbnRJZChzZXJ2aWNlLl9jbGllbnRJZCk7XG5cbiAgICAgICAgICAvLyBjbGVhciBvbGQgYXV0aG9yaXphdGlvbiBoZWFkZXJzXG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ107XG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydEYXRlJ107XG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ107XG5cbiAgICAgICAgICAvLyBhZGQgbmV3IGF1dGhvcml6YXRpb25cbiAgICAgICAgICBzaWduZXIuYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSk7XG4gICAgICAgICAgcmVxLnNpZ25lZEF0ID0gZGF0ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1JFU1BPTlNFJywgJ3ZhbGlkYXRlUmVzcG9uc2UnLCBmdW5jdGlvbiBWQUxJREFURV9SRVNQT05TRShyZXNwKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlLnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwLCB0aGlzKSkge1xuICAgICAgICByZXNwLmRhdGEgPSB7fTtcbiAgICAgICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwLmRhdGEgPSBudWxsO1xuICAgICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAge2NvZGU6ICdVbmtub3duRXJyb3InLCBtZXNzYWdlOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC4nfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRBc3luYygnU0VORCcsICdzZW5kJywgZnVuY3Rpb24gU0VORChyZXNwLCBkb25lKSB7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5fYWJvcnRDYWxsYmFjayA9IGRvbmU7XG4gICAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGh0dHBSZXNwKSB7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbSA9IGh0dHBSZXNwO1xuICAgICAgICB2YXIgc3RyZWFtID0gcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnN0cmVhbTtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSByZXNwLnJlcXVlc3Quc2VydmljZTtcbiAgICAgICAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpO1xuICAgICAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IHJlc3AucmVxdWVzdC5vcGVyYXRpb247XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBhcGkub3BlcmF0aW9uc1tvcGVyYXRpb25OYW1lXSB8fCB7fTtcblxuICAgICAgICBodHRwUmVzcC5vbignaGVhZGVycycsIGZ1bmN0aW9uIG9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoXG4gICAgICAgICAgICAnaHR0cEhlYWRlcnMnLFxuICAgICAgICAgICAgW3N0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3AsIHN0YXR1c01lc3NhZ2VdXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHsgLy8gc3RyZWFtczIgQVBJIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGlmIHdlIGRldGVjdCBldmVudCBzdHJlYW1zLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvXG4gICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQgJiYgc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHJlYWRpbmcgdGhlIEluY29taW5nU3RyZWFtXG4gICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb25lJyk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGh0dHBSZXNwLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uIG9uUmVhZGFibGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBodHRwUmVzcC5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRGF0YScsIFtkYXRhLCByZXNwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGxlZ2FjeSBzdHJlYW1zIEFQSVxuICAgICAgICAgICAgICBodHRwUmVzcC5vbignZGF0YScsIGZ1bmN0aW9uIG9uRGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEYXRhJywgW2RhdGEsIHJlc3BdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBodHRwUmVzcC5vbignZW5kJywgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0gfHwgIXN0cmVhbS5kaWRDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyICYmIChvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQgJiYgc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkpKSB7XG4gICAgICAgICAgICAgIC8vIGRvbid0IGNvbmNhdGVuYXRlIHJlc3BvbnNlIGNodW5rcyB3aGVuIHN0cmVhbWluZyBldmVudCBzdHJlYW0gZGF0YSB3aGVuIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb25lJyk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoaHR0cFJlc3ApIHtcbiAgICAgICAgaHR0cFJlc3Aub24oJ3NlbmRQcm9ncmVzcycsIGZ1bmN0aW9uIG9uU2VuZFByb2dyZXNzKHZhbHVlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBVcGxvYWRQcm9ncmVzcycsIFt2YWx1ZSwgcmVzcF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBodHRwUmVzcC5vbigncmVjZWl2ZVByb2dyZXNzJywgZnVuY3Rpb24gb25SZWNlaXZlUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvd25sb2FkUHJvZ3Jlc3MnLCBbdmFsdWUsIHJlc3BdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdSZXF1ZXN0QWJvcnRlZEVycm9yJykge1xuICAgICAgICAgIHZhciBlcnJDb2RlID0gZXJyLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InID8gZXJyLmNvZGUgOiAnTmV0d29ya2luZ0Vycm9yJztcbiAgICAgICAgICBlcnIgPSBBV1MudXRpbC5lcnJvcihlcnIsIHtcbiAgICAgICAgICAgIGNvZGU6IGVyckNvZGUsXG4gICAgICAgICAgICByZWdpb246IHJlc3AucmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24sXG4gICAgICAgICAgICBob3N0bmFtZTogcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcC5lcnJvciA9IGVycjtcbiAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBFcnJvcicsIFtyZXNwLmVycm9yLCByZXNwXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZVNlbmQoKSB7XG4gICAgICAgIHZhciBodHRwID0gQVdTLkh0dHBDbGllbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIGh0dHBPcHRpb25zID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmh0dHBPcHRpb25zIHx8IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBodHRwLmhhbmRsZVJlcXVlc3QocmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LCBodHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBlcnJvcik7XG4gICAgICAgICAgcHJvZ3Jlc3Moc3RyZWFtKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRpbWVEaWZmID0gKHJlc3AucmVxdWVzdC5zZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkgLSB0aGlzLnNpZ25lZEF0KSAvIDEwMDA7XG4gICAgICBpZiAodGltZURpZmYgPj0gNjAgKiAxMCkgeyAvLyBpZiB3ZSBzaWduZWQgMTBtaW4gYWdvLCByZS1zaWduXG4gICAgICAgIHRoaXMuZW1pdCgnc2lnbicsIFt0aGlzXSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgIGVsc2UgZXhlY3V0ZVNlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRlU2VuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdIVFRQX0hFQURFUlMnLCAnaHR0cEhlYWRlcnMnLFxuICAgICAgICBmdW5jdGlvbiBIVFRQX0hFQURFUlMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCwgc3RhdHVzTWVzc2FnZSkge1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYm9keSA9IEFXUy51dGlsLmJ1ZmZlci50b0J1ZmZlcignJyk7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzID0gW107XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcyA9IDA7XG4gICAgICB2YXIgZGF0ZUhlYWRlciA9IGhlYWRlcnMuZGF0ZSB8fCBoZWFkZXJzLkRhdGU7XG4gICAgICB2YXIgc2VydmljZSA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlO1xuICAgICAgaWYgKGRhdGVIZWFkZXIpIHtcbiAgICAgICAgdmFyIHNlcnZlclRpbWUgPSBEYXRlLnBhcnNlKGRhdGVIZWFkZXIpO1xuICAgICAgICBpZiAoc2VydmljZS5jb25maWcuY29ycmVjdENsb2NrU2tld1xuICAgICAgICAgICAgJiYgc2VydmljZS5pc0Nsb2NrU2tld2VkKHNlcnZlclRpbWUpKSB7XG4gICAgICAgICAgc2VydmljZS5hcHBseUNsb2NrT2Zmc2V0KHNlcnZlclRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0hUVFBfREFUQScsICdodHRwRGF0YScsIGZ1bmN0aW9uIEhUVFBfREFUQShjaHVuaywgcmVzcCkge1xuICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc05vZGUoKSkge1xuICAgICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgIHZhciB0b3RhbCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0geyBsb2FkZWQ6IHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzLCB0b3RhbDogdG90YWwgfTtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvd25sb2FkUHJvZ3Jlc3MnLCBbcHJvZ3Jlc3MsIHJlc3BdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMucHVzaChBV1MudXRpbC5idWZmZXIudG9CdWZmZXIoY2h1bmspKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9ET05FJywgJ2h0dHBEb25lJywgZnVuY3Rpb24gSFRUUF9ET05FKHJlc3ApIHtcbiAgICAgIC8vIGNvbnZlcnQgYnVmZmVycyBhcnJheSBpbnRvIHNpbmdsZSBidWZmZXJcbiAgICAgIGlmIChyZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzICYmIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYm9keSA9IEFXUy51dGlsLmJ1ZmZlci5jb25jYXQocmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycyk7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzO1xuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ0ZJTkFMSVpFX0VSUk9SJywgJ3JldHJ5JywgZnVuY3Rpb24gRklOQUxJWkVfRVJST1IocmVzcCkge1xuICAgICAgaWYgKHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgcmVzcC5lcnJvci5zdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IucmV0cnlhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRoaXMuc2VydmljZS5yZXRyeWFibGVFcnJvcihyZXNwLmVycm9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdJTlZBTElEQVRFX0NSRURFTlRJQUxTJywgJ3JldHJ5JywgZnVuY3Rpb24gSU5WQUxJREFURV9DUkVERU5USUFMUyhyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIHN3aXRjaCAocmVzcC5lcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ1JlcXVlc3RFeHBpcmVkJzogLy8gRUMyIG9ubHlcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJzpcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuJzpcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmV4cGlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdFWFBJUkVEX1NJR05BVFVSRScsICdyZXRyeScsIGZ1bmN0aW9uIEVYUElSRURfU0lHTkFUVVJFKHJlc3ApIHtcbiAgICAgIHZhciBlcnIgPSByZXNwLmVycm9yO1xuICAgICAgaWYgKCFlcnIpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmNvZGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlLm1hdGNoKC9TaWduYXR1cmUvKSAmJiBlcnIubWVzc2FnZS5tYXRjaCgvZXhwaXJlZC8pKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NMT0NLX1NLRVdFRCcsICdyZXRyeScsIGZ1bmN0aW9uIENMT0NLX1NLRVdFRChyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuY2xvY2tTa2V3RXJyb3IocmVzcC5lcnJvcilcbiAgICAgICAgICAmJiB0aGlzLnNlcnZpY2UuY29uZmlnLmNvcnJlY3RDbG9ja1NrZXcpIHtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdSRURJUkVDVCcsICdyZXRyeScsIGZ1bmN0aW9uIFJFRElSRUNUKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLmVycm9yICYmIHJlc3AuZXJyb3Iuc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgICAgICByZXNwLmVycm9yLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSkge1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmVuZHBvaW50ID1cbiAgICAgICAgICBuZXcgQVdTLkVuZHBvaW50KHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2xvY2F0aW9uJ10pO1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0hvc3QnXSA9IHRoaXMuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICAgICAgcmVzcC5lcnJvci5yZWRpcmVjdCA9IHRydWU7XG4gICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbiBSRVRSWV9DSEVDSyhyZXNwKSB7XG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZWRpcmVjdCAmJiByZXNwLnJlZGlyZWN0Q291bnQgPCByZXNwLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlEZWxheSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gdGhpcy5zZXJ2aWNlLnJldHJ5RGVsYXlzKHJlc3AucmV0cnlDb3VudCwgcmVzcC5lcnJvcikgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkQXN5bmMoJ1JFU0VUX1JFVFJZX1NUQVRFJywgJ2FmdGVyUmV0cnknLCBmdW5jdGlvbiBSRVNFVF9SRVRSWV9TVEFURShyZXNwLCBkb25lKSB7XG4gICAgICB2YXIgZGVsYXksIHdpbGxSZXRyeSA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBkZWxheSA9IHJlc3AuZXJyb3IucmV0cnlEZWxheSB8fCAwO1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZXRyeWFibGUgJiYgcmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5yZXRyeUNvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLmVycm9yLnJlZGlyZWN0ICYmIHJlc3AucmVkaXJlY3RDb3VudCA8IHJlc3AubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgcmVzcC5yZWRpcmVjdENvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWxheSA8IDAgaXMgYSBzaWduYWwgZnJvbSBjdXN0b21CYWNrb2ZmIHRvIHNraXAgcmV0cmllc1xuICAgICAgaWYgKHdpbGxSZXRyeSAmJiBkZWxheSA+PSAwKSB7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgQ29yZVBvc3Q6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0VYVFJBQ1RfUkVRVUVTVF9JRCcsICdleHRyYWN0RGF0YScsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuICAgIGFkZCgnRVhUUkFDVF9SRVFVRVNUX0lEJywgJ2V4dHJhY3RFcnJvcicsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuXG4gICAgYWRkKCdFTk9URk9VTkRfRVJST1InLCAnaHR0cEVycm9yJywgZnVuY3Rpb24gRU5PVEZPVU5EX0VSUk9SKGVycikge1xuICAgICAgZnVuY3Rpb24gaXNETlNFcnJvcihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVyci5lcnJubyA9PT0gJ0VOT1RGT1VORCcgfHxcbiAgICAgICAgICB0eXBlb2YgZXJyLmVycm5vID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgIHR5cGVvZiBBV1MudXRpbC5nZXRTeXN0ZW1FcnJvck5hbWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBbJ0VBSV9OT05BTUUnLCAnRUFJX05PREFUQSddLmluZGV4T2YoQVdTLnV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lKGVyci5lcnJubykgPj0gMCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdOZXR3b3JraW5nRXJyb3InICYmIGlzRE5TRXJyb3IoZXJyKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdJbmFjY2Vzc2libGUgaG9zdDogYCcgKyBlcnIuaG9zdG5hbWUgKyAnXFwnIGF0IHBvcnQgYCcgKyBlcnIucG9ydCArXG4gICAgICAgICAgJ1xcJy4gVGhpcyBzZXJ2aWNlIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBgJyArIGVyci5yZWdpb24gK1xuICAgICAgICAgICdcXCcgcmVnaW9uLic7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtcbiAgICAgICAgICBjb2RlOiAnVW5rbm93bkVuZHBvaW50JyxcbiAgICAgICAgICByZWdpb246IGVyci5yZWdpb24sXG4gICAgICAgICAgaG9zdG5hbWU6IGVyci5ob3N0bmFtZSxcbiAgICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBMb2dnZXI6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0xPR19SRVFVRVNUJywgJ2NvbXBsZXRlJywgZnVuY3Rpb24gTE9HX1JFUVVFU1QocmVzcCkge1xuICAgICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICAgIHZhciBsb2dnZXIgPSByZXEuc2VydmljZS5jb25maWcubG9nZ2VyO1xuICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgIGZ1bmN0aW9uIGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLCBzaGFwZSkge1xuICAgICAgICBpZiAoIXNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmlzU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuICcqKipTZW5zaXRpdmVJbmZvcm1hdGlvbioqKic7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpbnB1dFNoYXBlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdHJ1Y3R1cmUnOlxuICAgICAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICAgICAgQVdTLnV0aWwuZWFjaChzaGFwZSwgZnVuY3Rpb24oc3ViU2hhcGVOYW1lLCBzdWJTaGFwZSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0U2hhcGUubWVtYmVycywgc3ViU2hhcGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHN0cnVjdFtzdWJTaGFwZU5hbWVdID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUubWVtYmVyc1tzdWJTaGFwZU5hbWVdLCBzdWJTaGFwZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RydWN0W3N1YlNoYXBlTmFtZV0gPSBzdWJTaGFwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzaGFwZSwgZnVuY3Rpb24oc3ViU2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGxpc3QucHVzaChmaWx0ZXJTZW5zaXRpdmVMb2coaW5wdXRTaGFwZS5tZW1iZXIsIHN1YlNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgICBBV1MudXRpbC5lYWNoKHNoYXBlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSByZXNwLnJlcXVlc3Quc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gKHRpbWUgLSByZXEuc3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgICB2YXIgYW5zaSA9IGxvZ2dlci5pc1RUWSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBjZW5zb3JlZFBhcmFtcyA9IHJlcS5wYXJhbXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucyAmJlxuICAgICAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXSAmJlxuICAgICAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICAgICAgICAgIGNlbnNvcmVkUGFyYW1zID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUsIHJlcS5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdChjZW5zb3JlZFBhcmFtcywgdHJ1ZSwgbnVsbCk7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChhbnNpKSBtZXNzYWdlICs9ICdcXHgxQlszM20nO1xuICAgICAgICBtZXNzYWdlICs9ICdbQVdTICcgKyByZXEuc2VydmljZS5zZXJ2aWNlSWRlbnRpZmllciArICcgJyArIHN0YXR1cztcbiAgICAgICAgbWVzc2FnZSArPSAnICcgKyBkZWx0YS50b1N0cmluZygpICsgJ3MgJyArIHJlc3AucmV0cnlDb3VudCArICcgcmV0cmllc10nO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMDsxbSc7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgQVdTLnV0aWwuc3RyaW5nLmxvd2VyRmlyc3QocmVxLm9wZXJhdGlvbik7XG4gICAgICAgIG1lc3NhZ2UgKz0gJygnICsgcGFyYW1zICsgJyknO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMG0nO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSBidWlsZE1lc3NhZ2UoKTtcbiAgICAgIGlmICh0eXBlb2YgbG9nZ2VyLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKGxpbmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbG9nZ2VyLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci53cml0ZShsaW5lICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBKc29uOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvanNvbicpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0OiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdCcpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0SnNvbjogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfanNvbicpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0WG1sOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF94bWwnKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUXVlcnk6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9xdWVyeScpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBUaGUgZW5kcG9pbnQgdGhhdCBhIHNlcnZpY2Ugd2lsbCB0YWxrIHRvLCBmb3IgZXhhbXBsZSxcbiAqIGAnaHR0cHM6Ly9lYzIuYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbSdgLiBJZlxuICogeW91IG5lZWQgdG8gb3ZlcnJpZGUgYW4gZW5kcG9pbnQgZm9yIGEgc2VydmljZSwgeW91IGNhblxuICogc2V0IHRoZSBlbmRwb2ludCBvbiBhIHNlcnZpY2UgYnkgcGFzc2luZyB0aGUgZW5kcG9pbnRcbiAqIG9iamVjdCB3aXRoIHRoZSBgZW5kcG9pbnRgIG9wdGlvbiBrZXk6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGVwID0gbmV3IEFXUy5FbmRwb2ludCgnYXdzcHJveHkuZXhhbXBsZS5jb20nKTtcbiAqIHZhciBzMyA9IG5ldyBBV1MuUzMoe2VuZHBvaW50OiBlcH0pO1xuICogczMuc2VydmljZS5lbmRwb2ludC5ob3N0bmFtZSA9PSAnYXdzcHJveHkuZXhhbXBsZS5jb20nXG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IGRvIG5vdCBzcGVjaWZ5IGEgcHJvdG9jb2wsIHRoZSBwcm90b2NvbCB3aWxsXG4gKiBiZSBzZWxlY3RlZCBiYXNlZCBvbiB5b3VyIGN1cnJlbnQge0FXUy5jb25maWd9IGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQCFhdHRyaWJ1dGUgcHJvdG9jb2xcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcHJvdG9jb2wgKGh0dHAgb3IgaHR0cHMpIG9mIHRoZSBlbmRwb2ludFxuICogICAgIFVSTFxuICogQCFhdHRyaWJ1dGUgaG9zdG5hbWVcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoZSBlbmRwb2ludCwgZS5nLixcbiAqICAgICBleGFtcGxlLmNvbVxuICogQCFhdHRyaWJ1dGUgaG9zdFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBob3N0IHBvcnRpb24gb2YgdGhlIGVuZHBvaW50IGluY2x1ZGluZ1xuICogICAgIHRoZSBwb3J0LCBlLmcuLCBleGFtcGxlLmNvbTo4MFxuICogQCFhdHRyaWJ1dGUgcG9ydFxuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgcG9ydCBvZiB0aGUgZW5kcG9pbnRcbiAqIEAhYXR0cmlidXRlIGhyZWZcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgZnVsbCBVUkwgb2YgdGhlIGVuZHBvaW50XG4gKi9cbkFXUy5FbmRwb2ludCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgRW5kcG9pbnQoZW5kcG9pbnQpXG4gICAqICAgQ29uc3RydWN0cyBhIG5ldyBlbmRwb2ludCBnaXZlbiBhbiBlbmRwb2ludCBVUkwuIElmIHRoZVxuICAgKiAgIFVSTCBvbWl0cyBhIHByb3RvY29sIChodHRwIG9yIGh0dHBzKSwgdGhlIGRlZmF1bHQgcHJvdG9jb2xcbiAgICogICBzZXQgaW4gdGhlIGdsb2JhbCB7QVdTLmNvbmZpZ30gd2lsbCBiZSB1c2VkLlxuICAgKiAgIEBwYXJhbSBlbmRwb2ludCBbU3RyaW5nXSB0aGUgVVJMIHRvIGNvbnN0cnVjdCBhbiBlbmRwb2ludCBmcm9tXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gRW5kcG9pbnQoZW5kcG9pbnQsIGNvbmZpZykge1xuICAgIEFXUy51dGlsLmhpZGVQcm9wZXJ0aWVzKHRoaXMsIFsnc2xhc2hlcycsICdhdXRoJywgJ2hhc2gnLCAnc2VhcmNoJywgJ3F1ZXJ5J10pO1xuXG4gICAgaWYgKHR5cGVvZiBlbmRwb2ludCA9PT0gJ3VuZGVmaW5lZCcgfHwgZW5kcG9pbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmRwb2ludDogJyArIGVuZHBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmRwb2ludCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBBV1MudXRpbC5jb3B5KGVuZHBvaW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWVuZHBvaW50Lm1hdGNoKC9eaHR0cC8pKSB7XG4gICAgICB2YXIgdXNlU1NMID0gY29uZmlnICYmIGNvbmZpZy5zc2xFbmFibGVkICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBjb25maWcuc3NsRW5hYmxlZCA6IEFXUy5jb25maWcuc3NsRW5hYmxlZDtcbiAgICAgIGVuZHBvaW50ID0gKHVzZVNTTCA/ICdodHRwcycgOiAnaHR0cCcpICsgJzovLycgKyBlbmRwb2ludDtcbiAgICB9XG5cbiAgICBBV1MudXRpbC51cGRhdGUodGhpcywgQVdTLnV0aWwudXJsUGFyc2UoZW5kcG9pbnQpKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgcG9ydCBwcm9wZXJ0eSBpcyBzZXQgYXMgYW4gaW50ZWdlclxuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBhcnNlSW50KHRoaXMucG9ydCwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcnQgPSB0aGlzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG59KTtcblxuLyoqXG4gKiBUaGUgbG93IGxldmVsIEhUVFAgcmVxdWVzdCBvYmplY3QsIGVuY2Fwc3VsYXRpbmcgYWxsIEhUVFAgaGVhZGVyXG4gKiBhbmQgYm9keSBkYXRhIHNlbnQgYnkgYSBzZXJ2aWNlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgbWV0aG9kXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEhUVFAgbWV0aG9kIG9mIHRoZSByZXF1ZXN0XG4gKiBAIWF0dHJpYnV0ZSBwYXRoXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgVVJJLCBlLmcuLFxuICogICAgIFwiL2xpc3QvP3N0YXJ0PTUmbnVtPTEwXCJcbiAqIEAhYXR0cmlidXRlIGhlYWRlcnNcbiAqICAgQHJldHVybiBbbWFwPFN0cmluZyxTdHJpbmc+XVxuICogICAgIGEgbWFwIG9mIGhlYWRlciBrZXlzIGFuZCB0aGVpciByZXNwZWN0aXZlIHZhbHVlc1xuICogQCFhdHRyaWJ1dGUgYm9keVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXF1ZXN0IGJvZHkgcGF5bG9hZFxuICogQCFhdHRyaWJ1dGUgZW5kcG9pbnRcbiAqICAgQHJldHVybiBbQVdTLkVuZHBvaW50XSB0aGUgZW5kcG9pbnQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAIWF0dHJpYnV0ZSByZWdpb25cbiAqICAgQGFwaSBwcml2YXRlXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHJlZ2lvbiwgZm9yIHNpZ25pbmcgcHVycG9zZXMgb25seS5cbiAqL1xuQVdTLkh0dHBSZXF1ZXN0ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KGVuZHBvaW50LCByZWdpb24pIHtcbiAgICBlbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgIHRoaXMubWV0aG9kID0gJ1BPU1QnO1xuICAgIHRoaXMucGF0aCA9IGVuZHBvaW50LnBhdGggfHwgJy8nO1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgIHRoaXMuYm9keSA9ICcnO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSAnJztcbiAgICB0aGlzLnNldFVzZXJBZ2VudCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldFVzZXJBZ2VudDogZnVuY3Rpb24gc2V0VXNlckFnZW50KCkge1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHRoaXMuaGVhZGVyc1t0aGlzLmdldFVzZXJBZ2VudEhlYWRlck5hbWUoKV0gPSBBV1MudXRpbC51c2VyQWdlbnQoKTtcbiAgfSxcblxuICBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lOiBmdW5jdGlvbiBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCkge1xuICAgIHZhciBwcmVmaXggPSBBV1MudXRpbC5pc0Jyb3dzZXIoKSA/ICdYLUFtei0nIDogJyc7XG4gICAgcmV0dXJuIHByZWZpeCArICdVc2VyLUFnZW50JztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcHBlbmRUb1VzZXJBZ2VudDogZnVuY3Rpb24gYXBwZW5kVG9Vc2VyQWdlbnQoYWdlbnRQYXJ0aWFsKSB7XG4gICAgaWYgKHR5cGVvZiBhZ2VudFBhcnRpYWwgPT09ICdzdHJpbmcnICYmIGFnZW50UGFydGlhbCkge1xuICAgICAgdGhpcy5fdXNlckFnZW50ICs9ICcgJyArIGFnZW50UGFydGlhbDtcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzW3RoaXMuZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpXSA9IHRoaXMuX3VzZXJBZ2VudDtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRVc2VyQWdlbnQ6IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckFnZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBwYXJ0IG9mIHRoZSB7cGF0aH0gZXhjbHVkaW5nIHRoZVxuICAgKiAgIHF1ZXJ5IHN0cmluZ1xuICAgKi9cbiAgcGF0aG5hbWU6IGZ1bmN0aW9uIHBhdGhuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGguc3BsaXQoJz8nLCAxKVswXTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIHtwYXRofVxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5wYXRoLnNwbGl0KCc/JywgMilbMV07XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IEFXUy51dGlsLnF1ZXJ5U3RyaW5nUGFyc2UocXVlcnkpO1xuICAgICAgcmV0dXJuIEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiB1cGRhdGUgaHR0cFJlcXVlc3QgZW5kcG9pbnQgd2l0aCBlbmRwb2ludCBzdHJpbmdcbiAgICovXG4gIHVwZGF0ZUVuZHBvaW50OiBmdW5jdGlvbiB1cGRhdGVFbmRwb2ludChlbmRwb2ludFN0cikge1xuICAgIHZhciBuZXdFbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnRTdHIpO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBuZXdFbmRwb2ludDtcbiAgICB0aGlzLnBhdGggPSBuZXdFbmRwb2ludC5wYXRoIHx8ICcvJztcbiAgICBpZiAodGhpcy5oZWFkZXJzWydIb3N0J10pIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snSG9zdCddID0gbmV3RW5kcG9pbnQuaG9zdDtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBsb3cgbGV2ZWwgSFRUUCByZXNwb25zZSBvYmplY3QsIGVuY2Fwc3VsYXRpbmcgYWxsIEhUVFAgaGVhZGVyXG4gKiBhbmQgYm9keSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3RhdHVzQ29kZVxuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgSFRUUCBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIDIwMCwgNDA0KVxuICogQCFhdHRyaWJ1dGUgaGVhZGVyc1xuICogICBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dXG4gKiAgICAgIGEgbWFwIG9mIHJlc3BvbnNlIGhlYWRlciBrZXlzIGFuZCB0aGVpciByZXNwZWN0aXZlIHZhbHVlc1xuICogQCFhdHRyaWJ1dGUgYm9keVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBib2R5IHBheWxvYWRcbiAqIEAhYXR0cmlidXRlIFtyXSBzdHJlYW1pbmdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGlzIHJlc3BvbnNlIGlzIGJlaW5nIHN0cmVhbWVkIGF0IGEgbG93LWxldmVsLlxuICogICAgIERlZmF1bHRzIHRvIGBmYWxzZWAgKGJ1ZmZlcmVkIHJlYWRzKS4gRG8gbm90IG1vZGlmeSB0aGlzIG1hbnVhbGx5LCB1c2VcbiAqICAgICB7Y3JlYXRlVW5idWZmZXJlZFN0cmVhbX0gdG8gY29udmVydCB0aGUgc3RyZWFtIHRvIHVuYnVmZmVyZWQgbW9kZVxuICogICAgIGluc3RlYWQuXG4gKi9cbkFXUy5IdHRwUmVzcG9uc2UgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gSHR0cFJlc3BvbnNlKCkge1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGJ1ZmZlcmluZyBvbiB0aGUgSFRUUCByZXNwb25zZSBhbmQgcmV0dXJucyB0aGUgc3RyZWFtIGZvciByZWFkaW5nLlxuICAgKiBAcmV0dXJuIFtTdHJlYW0sIFhNTEh0dHBSZXF1ZXN0LCBudWxsXSB0aGUgdW5kZXJseWluZyBzdHJlYW0gb2JqZWN0LlxuICAgKiAgIFVzZSB0aGlzIG9iamVjdCB0byBkaXJlY3RseSByZWFkIGRhdGEgb2ZmIG9mIHRoZSBzdHJlYW0uXG4gICAqIEBub3RlIFRoaXMgb2JqZWN0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7QVdTLlJlcXVlc3R+aHR0cEhlYWRlcnN9XG4gICAqICAgZXZlbnQgaGFzIGZpcmVkLiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBwcmlvciB0b1xuICAgKiAgIHtBV1MuUmVxdWVzdH5odHRwRGF0YX0uXG4gICAqIEBleGFtcGxlIFRha2luZyBjb250cm9sIG9mIGEgc3RyZWFtXG4gICAqICAgcmVxdWVzdC5vbignaHR0cEhlYWRlcnMnLCBmdW5jdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKSB7XG4gICAqICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgKiAgICAgICBpZiAoaGVhZGVycy5ldGFnID09PSAneHl6Jykge1xuICAgKiAgICAgICAgIC8vIHBpcGUgdGhlIHN0cmVhbSwgZGlzYWJsaW5nIGJ1ZmZlcmluZ1xuICAgKiAgICAgICAgIHZhciBzdHJlYW0gPSB0aGlzLnJlc3BvbnNlLmh0dHBSZXNwb25zZS5jcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCk7XG4gICAqICAgICAgICAgc3RyZWFtLnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgKiAgICAgICB9IGVsc2UgeyAvLyBhYm9ydCB0aGlzIHJlcXVlc3QgYW5kIHNldCBhIGJldHRlciBlcnJvciBtZXNzYWdlXG4gICAqICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgKiAgICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgRVRhZycpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgfSkuc2VuZChjb25zb2xlLmxvZyk7XG4gICAqL1xuICBjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCkge1xuICAgIHRoaXMuc3RyZWFtaW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW07XG4gIH1cbn0pO1xuXG5cbkFXUy5IdHRwQ2xpZW50ID0gaW5oZXJpdCh7fSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5IdHRwQ2xpZW50LmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gIGlmICh0aGlzLnNpbmdsZXRvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zaW5nbGV0b24gPSBuZXcgdGhpcygpO1xuICB9XG4gIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5TdHJlYW07XG52YXIgVHJhbnNmb3JtU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlRyYW5zZm9ybTtcbnZhciBSZWFkYWJsZVN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5SZWFkYWJsZTtcbnJlcXVpcmUoJy4uL2h0dHAnKTtcbnZhciBDT05ORUNUSU9OX1JFVVNFX0VOVl9OQU1FID0gJ0FXU19OT0RFSlNfQ09OTkVDVElPTl9SRVVTRV9FTkFCTEVEJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLk5vZGVIdHRwQ2xpZW50ID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIGhhbmRsZVJlcXVlc3Q6IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QoaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLCBjYWxsYmFjaywgZXJyQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVuZHBvaW50ID0gaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gICAgdmFyIHBhdGhQcmVmaXggPSAnJztcbiAgICBpZiAoIWh0dHBPcHRpb25zKSBodHRwT3B0aW9ucyA9IHt9O1xuICAgIGlmIChodHRwT3B0aW9ucy5wcm94eSkge1xuICAgICAgcGF0aFByZWZpeCA9IGVuZHBvaW50LnByb3RvY29sICsgJy8vJyArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgICAgaWYgKGVuZHBvaW50LnBvcnQgIT09IDgwICYmIGVuZHBvaW50LnBvcnQgIT09IDQ0Mykge1xuICAgICAgICBwYXRoUHJlZml4ICs9ICc6JyArIGVuZHBvaW50LnBvcnQ7XG4gICAgICB9XG4gICAgICBlbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoaHR0cE9wdGlvbnMucHJveHkpO1xuICAgIH1cblxuICAgIHZhciB1c2VTU0wgPSBlbmRwb2ludC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgdmFyIGh0dHAgPSB1c2VTU0wgPyByZXF1aXJlKCdodHRwcycpIDogcmVxdWlyZSgnaHR0cCcpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogZW5kcG9pbnQuaG9zdG5hbWUsXG4gICAgICBwb3J0OiBlbmRwb2ludC5wb3J0LFxuICAgICAgbWV0aG9kOiBodHRwUmVxdWVzdC5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBodHRwUmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcGF0aDogcGF0aFByZWZpeCArIGh0dHBSZXF1ZXN0LnBhdGhcbiAgICB9O1xuXG4gICAgaWYgKCFodHRwT3B0aW9ucy5hZ2VudCkge1xuICAgICAgb3B0aW9ucy5hZ2VudCA9IHRoaXMuZ2V0QWdlbnQodXNlU1NMLCB7XG4gICAgICAgIGtlZXBBbGl2ZTogcHJvY2Vzcy5lbnZbQ09OTkVDVElPTl9SRVVTRV9FTlZfTkFNRV0gPT09ICcxJyA/IHRydWUgOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgQVdTLnV0aWwudXBkYXRlKG9wdGlvbnMsIGh0dHBPcHRpb25zKTtcbiAgICBkZWxldGUgb3B0aW9ucy5wcm94eTsgLy8gcHJveHkgaXNuJ3QgYW4gSFRUUCBvcHRpb25cbiAgICBkZWxldGUgb3B0aW9ucy50aW1lb3V0OyAvLyB0aW1lb3V0IGlzbid0IGFuIEhUVFAgb3B0aW9uXG5cbiAgICB2YXIgc3RyZWFtID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIChodHRwUmVzcCkge1xuICAgICAgaWYgKHN0cmVhbS5kaWRDYWxsYmFjaykgcmV0dXJuO1xuXG4gICAgICBjYWxsYmFjayhodHRwUmVzcCk7XG4gICAgICBodHRwUmVzcC5lbWl0KFxuICAgICAgICAnaGVhZGVycycsXG4gICAgICAgIGh0dHBSZXNwLnN0YXR1c0NvZGUsXG4gICAgICAgIGh0dHBSZXNwLmhlYWRlcnMsXG4gICAgICAgIGh0dHBSZXNwLnN0YXR1c01lc3NhZ2VcbiAgICAgICk7XG4gICAgfSk7XG4gICAgaHR0cFJlcXVlc3Quc3RyZWFtID0gc3RyZWFtOyAvLyBhdHRhY2ggc3RyZWFtIHRvIGh0dHBSZXF1ZXN0XG4gICAgc3RyZWFtLmRpZENhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAvLyBjb25uZWN0aW9uIHRpbWVvdXQgc3VwcG9ydFxuICAgIGlmIChodHRwT3B0aW9ucy5jb25uZWN0VGltZW91dCkge1xuICAgICAgdmFyIGNvbm5lY3RUaW1lb3V0SWQ7XG4gICAgICBzdHJlYW0ub24oJ3NvY2tldCcsIGZ1bmN0aW9uKHNvY2tldCkge1xuICAgICAgICBpZiAoc29ja2V0LmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICBjb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBjb25uZWN0VGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZGlkQ2FsbGJhY2spIHJldHVybjsgc3RyZWFtLmRpZENhbGxiYWNrID0gdHJ1ZTtcblxuICAgICAgICAgICAgc3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdTb2NrZXQgdGltZWQgb3V0IHdpdGhvdXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbicpLFxuICAgICAgICAgICAgICB7Y29kZTogJ1RpbWVvdXRFcnJvcid9XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9LCBodHRwT3B0aW9ucy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjb25uZWN0VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdGltZW91dCBzdXBwb3J0XG4gICAgc3RyZWFtLnNldFRpbWVvdXQoaHR0cE9wdGlvbnMudGltZW91dCB8fCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzdHJlYW0uZGlkQ2FsbGJhY2spIHJldHVybjsgc3RyZWFtLmRpZENhbGxiYWNrID0gdHJ1ZTtcblxuICAgICAgdmFyIG1zZyA9ICdDb25uZWN0aW9uIHRpbWVkIG91dCBhZnRlciAnICsgaHR0cE9wdGlvbnMudGltZW91dCArICdtcyc7XG4gICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobXNnKSwge2NvZGU6ICdUaW1lb3V0RXJyb3InfSkpO1xuICAgICAgc3RyZWFtLmFib3J0KCk7XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoY29ubmVjdFRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgIGNvbm5lY3RUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5kaWRDYWxsYmFjaykgcmV0dXJuOyBzdHJlYW0uZGlkQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgaWYgKCdFQ09OTlJFU0VUJyA9PT0gZXJyLmNvZGUgfHwgJ0VQSVBFJyA9PT0gZXJyLmNvZGUgfHwgJ0VUSU1FRE9VVCcgPT09IGVyci5jb2RlKSB7XG4gICAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKGVyciwge2NvZGU6ICdUaW1lb3V0RXJyb3InfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBleHBlY3QgPSBodHRwUmVxdWVzdC5oZWFkZXJzLkV4cGVjdCB8fCBodHRwUmVxdWVzdC5oZWFkZXJzLmV4cGVjdDtcbiAgICBpZiAoZXhwZWN0ID09PSAnMTAwLWNvbnRpbnVlJykge1xuICAgICAgc3RyZWFtLm9uY2UoJ2NvbnRpbnVlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYud3JpdGVCb2R5KHN0cmVhbSwgaHR0cFJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVCb2R5KHN0cmVhbSwgaHR0cFJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG5cbiAgd3JpdGVCb2R5OiBmdW5jdGlvbiB3cml0ZUJvZHkoc3RyZWFtLCBodHRwUmVxdWVzdCkge1xuICAgIHZhciBib2R5ID0gaHR0cFJlcXVlc3QuYm9keTtcbiAgICB2YXIgdG90YWxCeXRlcyA9IHBhcnNlSW50KGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10sIDEwKTtcblxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAvLyBGb3IgcHJvZ3Jlc3Mgc3VwcG9ydCBvZiBzdHJlYW1pbmcgY29udGVudCAtXG4gICAgICAvLyBwaXBlIHRoZSBkYXRhIHRocm91Z2ggYSB0cmFuc2Zvcm0gc3RyZWFtIHRvIGVtaXQgJ3NlbmRQcm9ncmVzcycgZXZlbnRzXG4gICAgICB2YXIgcHJvZ3Jlc3NTdHJlYW0gPSB0aGlzLnByb2dyZXNzU3RyZWFtKHN0cmVhbSwgdG90YWxCeXRlcyk7XG4gICAgICBpZiAocHJvZ3Jlc3NTdHJlYW0pIHtcbiAgICAgICAgYm9keS5waXBlKHByb2dyZXNzU3RyZWFtKS5waXBlKHN0cmVhbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LnBpcGUoc3RyZWFtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcbiAgICAgIC8vIFRoZSBwcm92aWRlZCBib2R5IGlzIGEgYnVmZmVyL3N0cmluZyBhbmQgaXMgYWxyZWFkeSBmdWxseSBhdmFpbGFibGUgaW4gbWVtb3J5IC1cbiAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSBpdCdzIGJlc3QgdG8gc2VuZCBpdCBhcyBhIHdob2xlIGJ5IGNhbGxpbmcgc3RyZWFtLmVuZChib2R5KSxcbiAgICAgIC8vIENhbGxlcnMgZXhwZWN0IGEgJ3NlbmRQcm9ncmVzcycgZXZlbnQgd2hpY2ggaXMgYmVzdCBlbWl0dGVkIG9uY2VcbiAgICAgIC8vIHRoZSBodHRwIHJlcXVlc3Qgc3RyZWFtIGhhcyBiZWVuIGZ1bGx5IHdyaXR0ZW4gYW5kIGFsbCBkYXRhIGZsdXNoZWQuXG4gICAgICAvLyBUaGUgdXNlIG9mIHRvdGFsQnl0ZXMgaXMgaW1wb3J0YW50IG92ZXIgYm9keS5sZW5ndGggZm9yIHN0cmluZ3Mgd2hlcmVcbiAgICAgIC8vIGxlbmd0aCBpcyBjaGFyIGxlbmd0aCBhbmQgbm90IGJ5dGUgbGVuZ3RoLlxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnc2VuZFByb2dyZXNzJywge1xuICAgICAgICAgIGxvYWRlZDogdG90YWxCeXRlcyxcbiAgICAgICAgICB0b3RhbDogdG90YWxCeXRlc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgc3RyZWFtLmVuZChib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gcmVxdWVzdCBib2R5XG4gICAgICBzdHJlYW0uZW5kKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGh0dHBzLkFnZW50IG9yIGh0dHAuQWdlbnQgYWNjb3JkaW5nIHRvIHRoZSByZXF1ZXN0IHNjaGVtYS5cbiAgICovXG4gIGdldEFnZW50OiBmdW5jdGlvbiBnZXRBZ2VudCh1c2VTU0wsIGFnZW50T3B0aW9ucykge1xuICAgIHZhciBodHRwID0gdXNlU1NMID8gcmVxdWlyZSgnaHR0cHMnKSA6IHJlcXVpcmUoJ2h0dHAnKTtcbiAgICBpZiAodXNlU1NMKSB7XG4gICAgICBpZiAoIUFXUy5Ob2RlSHR0cENsaWVudC5zc2xBZ2VudCkge1xuICAgICAgICBBV1MuTm9kZUh0dHBDbGllbnQuc3NsQWdlbnQgPSBuZXcgaHR0cC5BZ2VudChBV1MudXRpbC5tZXJnZSh7XG4gICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiBwcm9jZXNzLmVudi5OT0RFX1RMU19SRUpFQ1RfVU5BVVRIT1JJWkVEID09PSAnMCcgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgfSwgYWdlbnRPcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIEFXUy5Ob2RlSHR0cENsaWVudC5zc2xBZ2VudC5zZXRNYXhMaXN0ZW5lcnMoMCk7XG5cbiAgICAgICAgLy8gZGVsZWdhdGUgbWF4U29ja2V0cyB0byBnbG9iYWxBZ2VudCwgc2V0IGEgZGVmYXVsdCBsaW1pdCBvZiA1MCBpZiBjdXJyZW50IHZhbHVlIGlzIEluZmluaXR5LlxuICAgICAgICAvLyBVc2VycyBjYW4gYnlwYXNzIHRoaXMgZGVmYXVsdCBieSBzdXBwbHlpbmcgdGhlaXIgb3duIEFnZW50IGFzIHBhcnQgb2YgU0RLIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBV1MuTm9kZUh0dHBDbGllbnQuc3NsQWdlbnQsICdtYXhTb2NrZXRzJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TWF4U29ja2V0cyA9IDUwO1xuICAgICAgICAgICAgdmFyIGdsb2JhbEFnZW50ID0gaHR0cC5nbG9iYWxBZ2VudDtcbiAgICAgICAgICAgIGlmIChnbG9iYWxBZ2VudCAmJiBnbG9iYWxBZ2VudC5tYXhTb2NrZXRzICE9PSBJbmZpbml0eSAmJiB0eXBlb2YgZ2xvYmFsQWdlbnQubWF4U29ja2V0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbEFnZW50Lm1heFNvY2tldHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1heFNvY2tldHM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBV1MuTm9kZUh0dHBDbGllbnQuc3NsQWdlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghQVdTLk5vZGVIdHRwQ2xpZW50LmFnZW50KSB7XG4gICAgICAgIEFXUy5Ob2RlSHR0cENsaWVudC5hZ2VudCA9IG5ldyBodHRwLkFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQVdTLk5vZGVIdHRwQ2xpZW50LmFnZW50O1xuICAgIH1cbiAgfSxcblxuICBwcm9ncmVzc1N0cmVhbTogZnVuY3Rpb24gcHJvZ3Jlc3NTdHJlYW0oc3RyZWFtLCB0b3RhbEJ5dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1TdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBmb3Igbm9kZSAwLjggdGhlcmUgaXMgbm8gc3RyZWFtaW5nIHByb2dyZXNzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsb2FkZWRCeXRlcyA9IDA7XG4gICAgdmFyIHJlcG9ydGVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgIHJlcG9ydGVyLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgbG9hZGVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBzdHJlYW0uZW1pdCgnc2VuZFByb2dyZXNzJywge1xuICAgICAgICAgIGxvYWRlZDogbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgdG90YWw6IHRvdGFsQnl0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVwb3J0ZXI7XG4gIH0sXG5cbiAgZW1pdHRlcjogbnVsbFxufSk7XG5cbi8qKlxuICogQCFpZ25vcmVcbiAqL1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5wcm90b3R5cGUgPSBBV1MuTm9kZUh0dHBDbGllbnQucHJvdG90eXBlO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9IFJlYWRhYmxlU3RyZWFtID8gMiA6IDE7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gSnNvbkJ1aWxkZXIoKSB7IH1cblxuSnNvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmFuc2xhdGUodmFsdWUsIHNoYXBlKSk7XG59O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUsIHNoYXBlKSB7XG4gIGlmICghc2hhcGUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICBjYXNlICdzdHJ1Y3R1cmUnOiByZXR1cm4gdHJhbnNsYXRlU3RydWN0dXJlKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHRyYW5zbGF0ZU1hcCh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gdHJhbnNsYXRlTGlzdCh2YWx1ZSwgc2hhcGUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTdHJ1Y3R1cmUoc3RydWN0dXJlLCBzaGFwZSkge1xuICBpZiAoc2hhcGUuaXNEb2N1bWVudCkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gIH1cbiAgdmFyIHN0cnVjdCA9IHt9O1xuICB1dGlsLmVhY2goc3RydWN0dXJlLCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlKSB7XG4gICAgICBpZiAobWVtYmVyU2hhcGUubG9jYXRpb24gIT09ICdib2R5JykgcmV0dXJuO1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IG1lbWJlclNoYXBlLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyU2hhcGUubmFtZSA6IG5hbWU7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHN0cnVjdFtsb2NhdGlvbk5hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBvdXQucHVzaChyZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTWFwKG1hcCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1dpcmVGb3JtYXQodmFsdWUpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25CdWlsZGVyO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25QYXJzZXIoKSB7IH1cblxuSnNvblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShKU09OLnBhcnNlKHZhbHVlKSwgc2hhcGUpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHRyYW5zbGF0ZVN0cnVjdHVyZSh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiB0cmFuc2xhdGVNYXAodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU3RydWN0dXJlKHN0cnVjdHVyZSwgc2hhcGUpIHtcbiAgaWYgKHN0cnVjdHVyZSA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoc2hhcGUuaXNEb2N1bWVudCkgcmV0dXJuIHN0cnVjdHVyZTtcblxuICB2YXIgc3RydWN0ID0ge307XG4gIHZhciBzaGFwZU1lbWJlcnMgPSBzaGFwZS5tZW1iZXJzO1xuICB1dGlsLmVhY2goc2hhcGVNZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXJTaGFwZSkge1xuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RydWN0dXJlLCBsb2NhdGlvbk5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJ1Y3R1cmVbbG9jYXRpb25OYW1lXTtcbiAgICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgc3RydWN0W25hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0gW107XG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dC5wdXNoKG51bGwpO1xuICAgIGVsc2Ugb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1hcChtYXAsIHNoYXBlKSB7XG4gIGlmIChtYXAgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0ge307XG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBvdXRba2V5XSA9IG51bGw7XG4gICAgZWxzZSBvdXRba2V5XSA9IHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlLnRvVHlwZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSnNvblBhcnNlcjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnJlcXVpcmUoJy4vaHR0cCcpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGdldE1ldGFkYXRhU2VydmljZUVuZHBvaW50ID0gcmVxdWlyZSgnLi9tZXRhZGF0YV9zZXJ2aWNlL2dldF9tZXRhZGF0YV9zZXJ2aWNlX2VuZHBvaW50Jyk7XG52YXIgVVJMID0gcmVxdWlyZSgndXJsJykuVVJMO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXRhZGF0YSBzZXJ2aWNlIGF2YWlsYWJsZSBvbiBFQzIgaW5zdGFuY2VzLiBVc2luZyB0aGVcbiAqIHtyZXF1ZXN0fSBtZXRob2QsIHlvdSBjYW4gcmVjZWlldmUgbWV0YWRhdGEgYWJvdXQgYW55IGF2YWlsYWJsZSByZXNvdXJjZVxuICogb24gdGhlIG1ldGFkYXRhIHNlcnZpY2UuXG4gKlxuICogWW91IGNhbiBkaXNhYmxlIHRoZSB1c2Ugb2YgdGhlIElNRFMgYnkgc2V0dGluZyB0aGUgQVdTX0VDMl9NRVRBREFUQV9ESVNBQkxFRFxuICogZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKlxuICogQCFhdHRyaWJ1dGUgW3JdIGh0dHBPcHRpb25zXG4gKiAgIEByZXR1cm4gW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIEhUVFAgcmVxdWVzdDpcbiAqXG4gKiAgICAgKiAqKnRpbWVvdXQqKiAoTnVtYmVyKSAmbWRhc2g7IGEgdGltZW91dCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogICAgICAgYmVmb3JlIGFib3J0aW5nIHRoZSBjb25uZWN0aW9uLiBTZXQgdG8gMCBmb3Igbm8gdGltZW91dC5cbiAqXG4gKiBAIW1hY3JvIG5vYnJvd3NlclxuICovXG5BV1MuTWV0YWRhdGFTZXJ2aWNlID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBlbmRwb2ludCBvZiB0aGUgaW5zdGFuY2UgbWV0YWRhdGEgc2VydmljZVxuICAgKi9cbiAgZW5kcG9pbnQ6IGdldE1ldGFkYXRhU2VydmljZUVuZHBvaW50KCksXG5cbiAgLyoqXG4gICAqIEAhaWdub3JlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IEhUVFAgb3B0aW9ucy4gQnkgZGVmYXVsdCwgdGhlIG1ldGFkYXRhIHNlcnZpY2UgaXMgc2V0IHRvIG5vdFxuICAgKiB0aW1lb3V0IG9uIGxvbmcgcmVxdWVzdHMuIFRoaXMgbWVhbnMgdGhhdCBvbiBub24tRUMyIG1hY2hpbmVzLCB0aGlzXG4gICAqIHJlcXVlc3Qgd2lsbCBuZXZlciByZXR1cm4uIElmIHlvdSBhcmUgY2FsbGluZyB0aGlzIG9wZXJhdGlvbiBmcm9tIGFuXG4gICAqIGVudmlyb25tZW50IHRoYXQgbWF5IG5vdCBhbHdheXMgcnVuIG9uIEVDMiwgc2V0IGEgYHRpbWVvdXRgIHZhbHVlIHNvXG4gICAqIHRoZSBTREsgd2lsbCBhYm9ydCB0aGUgcmVxdWVzdCBhZnRlciBhIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBodHRwT3B0aW9uczogeyB0aW1lb3V0OiAwIH0sXG5cbiAgLyoqXG4gICAqIHdoZW4gZW5hYmxlZCwgbWV0YWRhdGEgc2VydmljZSB3aWxsIG5vdCBmZXRjaCB0b2tlblxuICAgKi9cbiAgZGlzYWJsZUZldGNoVG9rZW46IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1ldGFkYXRhU2VydmljZSBvYmplY3Qgd2l0aCBhIGdpdmVuIHNldCBvZiBvcHRpb25zLlxuICAgKlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaG9zdCBbU3RyaW5nXSB0aGUgaG9zdG5hbWUgb2YgdGhlIGluc3RhbmNlIG1ldGFkYXRhXG4gICAqICAgc2VydmljZVxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaHR0cE9wdGlvbnMgW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZVxuICAgKiAgIHVuZGVybHlpbmcgSFRUUCByZXF1ZXN0OlxuICAgKlxuICAgKiAgICogKip0aW1lb3V0KiogKE51bWJlcikgJm1kYXNoOyBhIHRpbWVvdXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAgICogICAgIGJlZm9yZSBhYm9ydGluZyB0aGUgY29ubmVjdGlvbi4gU2V0IHRvIDAgZm9yIG5vIHRpbWVvdXQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXhSZXRyaWVzIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyB0b1xuICAgKiAgIHBlcmZvcm0gZm9yIHRpbWVvdXQgZXJyb3JzXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZXRyeURlbGF5T3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGVcbiAgICogICByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLiBTZWUgQVdTLkNvbmZpZyBmb3IgZGV0YWlscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBNZXRhZGF0YVNlcnZpY2Uob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaG9zdCkge1xuICAgICAgb3B0aW9ucy5lbmRwb2ludCA9ICdodHRwOi8vJyArIG9wdGlvbnMuaG9zdDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIEFXUy51dGlsLnVwZGF0ZSh0aGlzLCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBpbnN0YW5jZSBtZXRhZGF0YSBzZXJ2aWNlIGZvciBhIGdpdmVuIHJlc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgcGF0aCBvZiB0aGUgcmVzb3VyY2UgdG8gZ2V0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFttYXBdIGFuIG9wdGlvbmFsIG1hcCB1c2VkIHRvIG1ha2UgcmVxdWVzdFxuICAgKlxuICAgKiAgICogKiptZXRob2QqKiAoU3RyaW5nKSAmbWRhc2g7IEhUVFAgcmVxdWVzdCBtZXRob2RcbiAgICpcbiAgICogICAqICoqaGVhZGVycyoqIChtYXA8U3RyaW5nLFN0cmluZz4pICZtZGFzaDsgYSBtYXAgb2YgcmVzcG9uc2UgaGVhZGVyIGtleXMgYW5kIHRoZWlyIHJlc3BlY3RpdmUgdmFsdWVzXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQ2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyBhdmFpbGFibGUgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvciwgbnVsbF0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBzZXRcbiAgICogICBAcGFyYW0gZGF0YSBbU3RyaW5nLCBudWxsXSBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCwgdGhlIGJvZHkgb2ZcbiAgICogICAgIHRoZSByZXNwb25zZVxuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52W0FXUy51dGlsLmltZHNEaXNhYmxlZEVudl0pIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRUMyIEluc3RhbmNlIE1ldGFkYXRhIFNlcnZpY2UgYWNjZXNzIGRpc2FibGVkJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoIHx8ICcvJztcblxuICAgIC8vIFZlcmlmeSB0aGF0IGhvc3QgaXMgYSB2YWxpZCBVUkxcbiAgICBpZiAoVVJMKSB7IG5ldyBVUkwodGhpcy5lbmRwb2ludCk7IH1cblxuICAgIHZhciBodHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QodGhpcy5lbmRwb2ludCArIHBhdGgpO1xuICAgIGh0dHBSZXF1ZXN0Lm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgfVxuICAgIEFXUy51dGlsLmhhbmRsZVJlcXVlc3RXaXRoUmV0cmllcyhodHRwUmVxdWVzdCwgdGhpcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuICBsb2FkQ3JlZGVudGlhbHNDYWxsYmFja3M6IFtdLFxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIG1ldGFkYXRhIHRva2VuIHVzZWQgZm9yIGdldHRpbmcgY3JlZGVudGlhbHNcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIHRva2VuKVxuICAgKiAgIENhbGxlZCB3aGVuIHRva2VuIGlzIGxvYWRlZCBmcm9tIHRoZSByZXNvdXJjZVxuICAgKi9cbiAgZmV0Y2hNZXRhZGF0YVRva2VuOiBmdW5jdGlvbiBmZXRjaE1ldGFkYXRhVG9rZW4oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRva2VuRmV0Y2hQYXRoID0gJy9sYXRlc3QvYXBpL3Rva2VuJztcbiAgICBzZWxmLnJlcXVlc3QoXG4gICAgICB0b2tlbkZldGNoUGF0aCxcbiAgICAgIHtcbiAgICAgICAgJ21ldGhvZCc6ICdQVVQnLFxuICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuLXR0bC1zZWNvbmRzJzogJzIxNjAwJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAY2FsbGJhY2sgY2IgZnVuY3Rpb24oZXJyLCBjcmVkcylcbiAgICogICBDYWxsZWQgd2hlbiBjcmVkZW50aWFscyBhcmUgbG9hZGVkIGZyb20gdGhlIHJlc291cmNlXG4gICAqL1xuICBmZXRjaENyZWRlbnRpYWxzOiBmdW5jdGlvbiBmZXRjaENyZWRlbnRpYWxzKG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBiYXNlUGF0aCA9ICcvbGF0ZXN0L21ldGEtZGF0YS9pYW0vc2VjdXJpdHktY3JlZGVudGlhbHMvJztcblxuICAgIHNlbGYucmVxdWVzdChiYXNlUGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcm9sZU5hbWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5kaXNhYmxlRmV0Y2hUb2tlbiA9ICEoZXJyLnN0YXR1c0NvZGUgPT09IDQwMSk7XG4gICAgICAgIGNiKEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnRUMyIE1ldGFkYXRhIHJvbGVOYW1lIHJlcXVlc3QgcmV0dXJuZWQgZXJyb3InXG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcm9sZU5hbWUgPSByb2xlTmFtZS5zcGxpdCgnXFxuJylbMF07IC8vIGdyYWIgZmlyc3QgKGFuZCBvbmx5KSByb2xlXG4gICAgICBzZWxmLnJlcXVlc3QoYmFzZVBhdGggKyByb2xlTmFtZSwgb3B0aW9ucywgZnVuY3Rpb24gKGNyZWRFcnIsIGNyZWREYXRhKSB7XG4gICAgICAgIGlmIChjcmVkRXJyKSB7XG4gICAgICAgICAgc2VsZi5kaXNhYmxlRmV0Y2hUb2tlbiA9ICEoY3JlZEVyci5zdGF0dXNDb2RlID09PSA0MDEpO1xuICAgICAgICAgIGNiKEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgICAgY3JlZEVycixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0VDMiBNZXRhZGF0YSBjcmVkcyByZXF1ZXN0IHJldHVybmVkIGVycm9yJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjcmVkZW50aWFscyA9IEpTT04ucGFyc2UoY3JlZERhdGEpO1xuICAgICAgICAgIGNiKG51bGwsIGNyZWRlbnRpYWxzKTtcbiAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgIGNiKHBhcnNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgYSBzZXQgb2YgY3JlZGVudGlhbHMgc3RvcmVkIGluIHRoZSBpbnN0YW5jZSBtZXRhZGF0YSBzZXJ2aWNlXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBjcmVkZW50aWFscylcbiAgICogICBDYWxsZWQgd2hlbiBjcmVkZW50aWFscyBhcmUgbG9hZGVkIGZyb20gdGhlIHJlc291cmNlXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgc2V0XG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtPYmplY3RdIHRoZSByYXcgSlNPTiBvYmplY3QgY29udGFpbmluZyBhbGxcbiAgICogICAgIG1ldGFkYXRhIGZyb20gdGhlIGNyZWRlbnRpYWxzIHJlc291cmNlXG4gICAqL1xuICBsb2FkQ3JlZGVudGlhbHM6IGZ1bmN0aW9uIGxvYWRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmxvYWRDcmVkZW50aWFsc0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICBpZiAoc2VsZi5sb2FkQ3JlZGVudGlhbHNDYWxsYmFja3MubGVuZ3RoID4gMSkgeyByZXR1cm47IH1cblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrcyhlcnIsIGNyZWRzKSB7XG4gICAgICB2YXIgY2I7XG4gICAgICB3aGlsZSAoKGNiID0gc2VsZi5sb2FkQ3JlZGVudGlhbHNDYWxsYmFja3Muc2hpZnQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYihlcnIsIGNyZWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5kaXNhYmxlRmV0Y2hUb2tlbikge1xuICAgICAgc2VsZi5mZXRjaENyZWRlbnRpYWxzKHt9LCBjYWxsYmFja3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmZldGNoTWV0YWRhdGFUb2tlbihmdW5jdGlvbih0b2tlbkVycm9yLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW5FcnJvcikge1xuICAgICAgICAgIGlmICh0b2tlbkVycm9yLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICAgICAgICBzZWxmLmRpc2FibGVGZXRjaFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuRXJyb3IucmV0cnlhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MoQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIHRva2VuRXJyb3IsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRUMyIE1ldGFkYXRhIHRva2VuIHJlcXVlc3QgcmV0dXJuZWQgZXJyb3InXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5FcnJvci5zdGF0dXNDb2RlID09PSA0MDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyhBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgdG9rZW5FcnJvcixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFQzIgTWV0YWRhdGEgdG9rZW4gcmVxdWVzdCByZXR1cm5lZCA0MDAnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuJzogdG9rZW5cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmV0Y2hDcmVkZW50aWFscyhvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgfSk7XG5cbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5NZXRhZGF0YVNlcnZpY2U7XG4iLCJ2YXIgZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBJUHY0OiAnaHR0cDovLzE2OS4yNTQuMTY5LjI1NCcsXG4gICAgSVB2NjogJ2h0dHA6Ly9bZmQwMDplYzI6OjI1NF0nLFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFbmRwb2ludDtcbiIsInZhciBFTlZfRU5EUE9JTlRfTkFNRSA9ICdBV1NfRUMyX01FVEFEQVRBX1NFUlZJQ0VfRU5EUE9JTlQnO1xudmFyIENPTkZJR19FTkRQT0lOVF9OQU1FID0gJ2VjMl9tZXRhZGF0YV9zZXJ2aWNlX2VuZHBvaW50JztcblxudmFyIGdldEVuZHBvaW50Q29uZmlnT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGVudmlyb25tZW50VmFyaWFibGVTZWxlY3RvcjogZnVuY3Rpb24oZW52KSB7IHJldHVybiBlbnZbRU5WX0VORFBPSU5UX05BTUVdOyB9LFxuICAgIGNvbmZpZ0ZpbGVTZWxlY3RvcjogZnVuY3Rpb24ocHJvZmlsZSkgeyByZXR1cm4gcHJvZmlsZVtDT05GSUdfRU5EUE9JTlRfTkFNRV07IH0sXG4gICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFbmRwb2ludENvbmZpZ09wdGlvbnM7XG4iLCJ2YXIgZ2V0RW5kcG9pbnRNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgSVB2NDogJ0lQdjQnLFxuICAgIElQdjY6ICdJUHY2JyxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RW5kcG9pbnRNb2RlO1xuIiwidmFyIEVuZHBvaW50TW9kZSA9IHJlcXVpcmUoJy4vZ2V0X2VuZHBvaW50X21vZGUnKSgpO1xuXG52YXIgRU5WX0VORFBPSU5UX01PREVfTkFNRSA9ICdBV1NfRUMyX01FVEFEQVRBX1NFUlZJQ0VfRU5EUE9JTlRfTU9ERSc7XG52YXIgQ09ORklHX0VORFBPSU5UX01PREVfTkFNRSA9ICdlYzJfbWV0YWRhdGFfc2VydmljZV9lbmRwb2ludF9tb2RlJztcblxudmFyIGdldEVuZHBvaW50TW9kZUNvbmZpZ09wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnZpcm9ubWVudFZhcmlhYmxlU2VsZWN0b3I6IGZ1bmN0aW9uKGVudikgeyByZXR1cm4gZW52W0VOVl9FTkRQT0lOVF9NT0RFX05BTUVdOyB9LFxuICAgIGNvbmZpZ0ZpbGVTZWxlY3RvcjogZnVuY3Rpb24ocHJvZmlsZSkgeyByZXR1cm4gcHJvZmlsZVtDT05GSUdfRU5EUE9JTlRfTU9ERV9OQU1FXTsgfSxcbiAgICBkZWZhdWx0OiBFbmRwb2ludE1vZGUuSVB2NCxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RW5kcG9pbnRNb2RlQ29uZmlnT3B0aW9ucztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbnZhciBFbmRwb2ludCA9IHJlcXVpcmUoJy4vZ2V0X2VuZHBvaW50JykoKTtcbnZhciBFbmRwb2ludE1vZGUgPSByZXF1aXJlKCcuL2dldF9lbmRwb2ludF9tb2RlJykoKTtcblxudmFyIEVORFBPSU5UX0NPTkZJR19PUFRJT05TID0gcmVxdWlyZSgnLi9nZXRfZW5kcG9pbnRfY29uZmlnX29wdGlvbnMnKSgpO1xudmFyIEVORFBPSU5UX01PREVfQ09ORklHX09QVElPTlMgPSByZXF1aXJlKCcuL2dldF9lbmRwb2ludF9tb2RlX2NvbmZpZ19vcHRpb25zJykoKTtcblxudmFyIGdldE1ldGFkYXRhU2VydmljZUVuZHBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmRwb2ludCA9IEFXUy51dGlsLmxvYWRDb25maWcoRU5EUE9JTlRfQ09ORklHX09QVElPTlMpO1xuICBpZiAoZW5kcG9pbnQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVuZHBvaW50O1xuXG4gIHZhciBlbmRwb2ludE1vZGUgPSBBV1MudXRpbC5sb2FkQ29uZmlnKEVORFBPSU5UX01PREVfQ09ORklHX09QVElPTlMpO1xuICBzd2l0Y2ggKGVuZHBvaW50TW9kZSkge1xuICAgIGNhc2UgRW5kcG9pbnRNb2RlLklQdjQ6XG4gICAgICByZXR1cm4gRW5kcG9pbnQuSVB2NDtcbiAgICBjYXNlIEVuZHBvaW50TW9kZS5JUHY2OlxuICAgICAgcmV0dXJuIEVuZHBvaW50LklQdjY7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZW5kcG9pbnQgbW9kZTogJyArIGVuZHBvaW50TW9kZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWV0YWRhdGFTZXJ2aWNlRW5kcG9pbnQ7XG4iLCJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xudmFyIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL3NoYXBlJyk7XG52YXIgUGFnaW5hdG9yID0gcmVxdWlyZSgnLi9wYWdpbmF0b3InKTtcbnZhciBSZXNvdXJjZVdhaXRlciA9IHJlcXVpcmUoJy4vcmVzb3VyY2Vfd2FpdGVyJyk7XG52YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuLi8uLi9hcGlzL21ldGFkYXRhLmpzb24nKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIEFwaShhcGksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBhcGkgPSBhcGkgfHwge307XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFwaSA9IHRoaXM7XG5cbiAgYXBpLm1ldGFkYXRhID0gYXBpLm1ldGFkYXRhIHx8IHt9O1xuXG4gIHZhciBzZXJ2aWNlSWRlbnRpZmllciA9IG9wdGlvbnMuc2VydmljZUlkZW50aWZpZXI7XG4gIGRlbGV0ZSBvcHRpb25zLnNlcnZpY2VJZGVudGlmaWVyO1xuXG4gIHByb3BlcnR5KHRoaXMsICdpc0FwaScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaVZlcnNpb24nLCBhcGkubWV0YWRhdGEuYXBpVmVyc2lvbik7XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludFByZWZpeCcsIGFwaS5tZXRhZGF0YS5lbmRwb2ludFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduaW5nTmFtZScsIGFwaS5tZXRhZGF0YS5zaWduaW5nTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdnbG9iYWxFbmRwb2ludCcsIGFwaS5tZXRhZGF0YS5nbG9iYWxFbmRwb2ludCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduYXR1cmVWZXJzaW9uJywgYXBpLm1ldGFkYXRhLnNpZ25hdHVyZVZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnanNvblZlcnNpb24nLCBhcGkubWV0YWRhdGEuanNvblZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAndGFyZ2V0UHJlZml4JywgYXBpLm1ldGFkYXRhLnRhcmdldFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdwcm90b2NvbCcsIGFwaS5tZXRhZGF0YS5wcm90b2NvbCk7XG4gIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBhcGkubWV0YWRhdGEudGltZXN0YW1wRm9ybWF0KTtcbiAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIGFwaS5tZXRhZGF0YS54bWxOYW1lc3BhY2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYWJicmV2aWF0aW9uJywgYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnZnVsbE5hbWUnLCBhcGkubWV0YWRhdGEuc2VydmljZUZ1bGxOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ3NlcnZpY2VJZCcsIGFwaS5tZXRhZGF0YS5zZXJ2aWNlSWQpO1xuICBpZiAoc2VydmljZUlkZW50aWZpZXIgJiYgbWV0YWRhdGFbc2VydmljZUlkZW50aWZpZXJdKSB7XG4gICAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTm9EZWZhdWx0TGlzdHMnLCBtZXRhZGF0YVtzZXJ2aWNlSWRlbnRpZmllcl0ueG1sTm9EZWZhdWx0TGlzdHMsIGZhbHNlKTtcbiAgfVxuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2NsYXNzTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24gfHwgYXBpLm1ldGFkYXRhLnNlcnZpY2VGdWxsTmFtZTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXkFtYXpvbnxBV1NcXHMqfFxcKC4qfFxccyt8XFxXKy9nLCAnJyk7XG4gICAgaWYgKG5hbWUgPT09ICdFbGFzdGljTG9hZEJhbGFuY2luZycpIG5hbWUgPSAnRUxCJztcbiAgICByZXR1cm4gbmFtZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWRkRW5kcG9pbnRPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5lbmRwb2ludG9wZXJhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcHJvcGVydHkoc2VsZiwgJ2VuZHBvaW50T3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdChuYW1lKSk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkgJiYgIXNlbGYuaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSkge1xuICAgICAgcHJvcGVydHkoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdoYXNSZXF1aXJlZEVuZHBvaW50RGlzY292ZXJ5JyxcbiAgICAgICAgb3BlcmF0aW9uLmVuZHBvaW50ZGlzY292ZXJ5LnJlcXVpcmVkID09PSB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3BlcnR5KHRoaXMsICdvcGVyYXRpb25zJywgbmV3IENvbGxlY3Rpb24oYXBpLm9wZXJhdGlvbnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIG9wZXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gIH0sIHV0aWwuc3RyaW5nLmxvd2VyRmlyc3QsIGFkZEVuZHBvaW50T3BlcmF0aW9uKSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3NoYXBlcycsIG5ldyBDb2xsZWN0aW9uKGFwaS5zaGFwZXMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZSwgb3B0aW9ucyk7XG4gIH0pKTtcblxuICBwcm9wZXJ0eSh0aGlzLCAncGFnaW5hdG9ycycsIG5ldyBDb2xsZWN0aW9uKGFwaS5wYWdpbmF0b3JzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IsIG9wdGlvbnMpO1xuICB9KSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3dhaXRlcnMnLCBuZXcgQ29sbGVjdGlvbihhcGkud2FpdGVycywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgd2FpdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVdhaXRlcihuYW1lLCB3YWl0ZXIsIG9wdGlvbnMpO1xuICB9LCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgYXBpLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgYXBpLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXBpO1xuIiwidmFyIG1lbW9pemVkUHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykubWVtb2l6ZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gbWVtb2l6ZShuYW1lLCB2YWx1ZSwgZmFjdG9yeSwgbmFtZVRyKSB7XG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgbmFtZVRyKG5hbWUpLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFjdG9yeShuYW1lLCB2YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKGl0ZXJhYmxlLCBvcHRpb25zLCBmYWN0b3J5LCBuYW1lVHIsIGNhbGxiYWNrKSB7XG4gIG5hbWVUciA9IG5hbWVUciB8fCBTdHJpbmc7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBpZCBpbiBpdGVyYWJsZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGlkKSkge1xuICAgICAgbWVtb2l6ZS5jYWxsKHNlbGYsIGlkLCBpdGVyYWJsZVtpZF0sIGZhY3RvcnksIG5hbWVUcik7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGlkLCBpdGVyYWJsZVtpZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL3NoYXBlJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHByb3BlcnR5ID0gdXRpbC5wcm9wZXJ0eTtcbnZhciBtZW1vaXplZFByb3BlcnR5ID0gdXRpbC5tZW1vaXplZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBvcGVyYXRpb24ubmFtZSB8fCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgb3BlcmF0aW9uLmh0dHAgPSBvcGVyYXRpb24uaHR0cCB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ2VuZHBvaW50Jywgb3BlcmF0aW9uLmVuZHBvaW50KTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBNZXRob2QnLCBvcGVyYXRpb24uaHR0cC5tZXRob2QgfHwgJ1BPU1QnKTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBQYXRoJywgb3BlcmF0aW9uLmh0dHAucmVxdWVzdFVyaSB8fCAnLycpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXV0aHR5cGUnLCBvcGVyYXRpb24uYXV0aHR5cGUgfHwgJycpO1xuICBwcm9wZXJ0eShcbiAgICB0aGlzLFxuICAgICdlbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkJyxcbiAgICBvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkgP1xuICAgICAgKG9wZXJhdGlvbi5lbmRwb2ludGRpc2NvdmVyeS5yZXF1aXJlZCA/ICdSRVFVSVJFRCcgOiAnT1BUSU9OQUwnKSA6XG4gICAgJ05VTEwnXG4gICk7XG4gIHByb3BlcnR5KHRoaXMsICdodHRwQ2hlY2tzdW1SZXF1aXJlZCcsIG9wZXJhdGlvbi5odHRwQ2hlY2tzdW1SZXF1aXJlZCwgZmFsc2UpO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2lucHV0JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFvcGVyYXRpb24uaW5wdXQpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGUuY3JlYXRlKG9wZXJhdGlvbi5pbnB1dCwgb3B0aW9ucyk7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ291dHB1dCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICghb3BlcmF0aW9uLm91dHB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJ1Y3R1cmUnfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZS5jcmVhdGUob3BlcmF0aW9uLm91dHB1dCwgb3B0aW9ucyk7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2Vycm9ycycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgaWYgKCFvcGVyYXRpb24uZXJyb3JzKSByZXR1cm4gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlcmF0aW9uLmVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKFNoYXBlLmNyZWF0ZShvcGVyYXRpb24uZXJyb3JzW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ3BhZ2luYXRvcicsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcHRpb25zLmFwaS5wYWdpbmF0b3JzW25hbWVdO1xuICB9KTtcblxuICBpZiAob3B0aW9ucy5kb2N1bWVudGF0aW9uKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb24nLCBvcGVyYXRpb24uZG9jdW1lbnRhdGlvbik7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb25VcmwnLCBvcGVyYXRpb24uZG9jdW1lbnRhdGlvblVybCk7XG4gIH1cblxuICAvLyBpZGVtcG90ZW50TWVtYmVycyBvbmx5IHRyYWNrcyB0b3AtbGV2ZWwgaW5wdXQgc2hhcGVzXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2lkZW1wb3RlbnRNZW1iZXJzJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkZW1wb3RlbnRNZW1iZXJzID0gW107XG4gICAgdmFyIGlucHV0ID0gc2VsZi5pbnB1dDtcbiAgICB2YXIgbWVtYmVycyA9IGlucHV0Lm1lbWJlcnM7XG4gICAgaWYgKCFpbnB1dC5tZW1iZXJzKSB7XG4gICAgICByZXR1cm4gaWRlbXBvdGVudE1lbWJlcnM7XG4gICAgfVxuICAgIGZvciAodmFyIG5hbWUgaW4gbWVtYmVycykge1xuICAgICAgaWYgKCFtZW1iZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlcnNbbmFtZV0uaXNJZGVtcG90ZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGlkZW1wb3RlbnRNZW1iZXJzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZGVtcG90ZW50TWVtYmVycztcbiAgfSk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnaGFzRXZlbnRPdXRwdXQnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0cHV0ID0gc2VsZi5vdXRwdXQ7XG4gICAgcmV0dXJuIGhhc0V2ZW50U3RyZWFtKG91dHB1dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYXNFdmVudFN0cmVhbSh0b3BMZXZlbFNoYXBlKSB7XG4gIHZhciBtZW1iZXJzID0gdG9wTGV2ZWxTaGFwZS5tZW1iZXJzO1xuICB2YXIgcGF5bG9hZCA9IHRvcExldmVsU2hhcGUucGF5bG9hZDtcblxuICBpZiAoIXRvcExldmVsU2hhcGUubWVtYmVycykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBtZW1iZXJzW3BheWxvYWRdO1xuICAgIHJldHVybiBwYXlsb2FkTWVtYmVyLmlzRXZlbnRTdHJlYW07XG4gIH1cblxuICAvLyBjaGVjayBpZiBhbnkgbWVtYmVyIGlzIGFuIGV2ZW50IHN0cmVhbVxuICBmb3IgKHZhciBuYW1lIGluIG1lbWJlcnMpIHtcbiAgICBpZiAoIW1lbWJlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGlmIChtZW1iZXJzW25hbWVdLmlzRXZlbnRTdHJlYW0gPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb247XG4iLCJ2YXIgcHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgcHJvcGVydHkodGhpcywgJ2lucHV0VG9rZW4nLCBwYWdpbmF0b3IuaW5wdXRfdG9rZW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbGltaXRLZXknLCBwYWdpbmF0b3IubGltaXRfa2V5KTtcbiAgcHJvcGVydHkodGhpcywgJ21vcmVSZXN1bHRzJywgcGFnaW5hdG9yLm1vcmVfcmVzdWx0cyk7XG4gIHByb3BlcnR5KHRoaXMsICdvdXRwdXRUb2tlbicsIHBhZ2luYXRvci5vdXRwdXRfdG9rZW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAncmVzdWx0S2V5JywgcGFnaW5hdG9yLnJlc3VsdF9rZXkpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2luYXRvcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHByb3BlcnR5ID0gdXRpbC5wcm9wZXJ0eTtcblxuZnVuY3Rpb24gUmVzb3VyY2VXYWl0ZXIobmFtZSwgd2FpdGVyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIG5hbWUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXBpJywgb3B0aW9ucy5hcGksIGZhbHNlKTtcblxuICBpZiAod2FpdGVyLm9wZXJhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdvcGVyYXRpb24nLCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KHdhaXRlci5vcGVyYXRpb24pKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGtleXMgPSBbXG4gICAgJ3R5cGUnLFxuICAgICdkZXNjcmlwdGlvbicsXG4gICAgJ2RlbGF5JyxcbiAgICAnbWF4QXR0ZW1wdHMnLFxuICAgICdhY2NlcHRvcnMnXG4gIF07XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciB2YWx1ZSA9IHdhaXRlcltrZXldO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcHJvcGVydHkoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZXNvdXJjZVdhaXRlcjtcbiIsInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBwcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXRpbC5wcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVkUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gIGlmICghb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXSkge1xuICAgIHV0aWwubWVtb2l6ZWRQcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFNoYXBlKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHByb3BlcnR5KHRoaXMsICdzaGFwZScsIHNoYXBlLnNoYXBlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICd0eXBlJywgc2hhcGUudHlwZSk7XG4gIHByb3BlcnR5KHRoaXMsICdlbnVtJywgc2hhcGUuZW51bSk7XG4gIHByb3BlcnR5KHRoaXMsICdtaW4nLCBzaGFwZS5taW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbWF4Jywgc2hhcGUubWF4KTtcbiAgcHJvcGVydHkodGhpcywgJ3BhdHRlcm4nLCBzaGFwZS5wYXR0ZXJuKTtcbiAgcHJvcGVydHkodGhpcywgJ2xvY2F0aW9uJywgc2hhcGUubG9jYXRpb24gfHwgdGhpcy5sb2NhdGlvbiB8fCAnYm9keScpO1xuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHRoaXMubmFtZSB8fCBzaGFwZS54bWxOYW1lIHx8IHNoYXBlLnF1ZXJ5TmFtZSB8fFxuICAgIHNoYXBlLmxvY2F0aW9uTmFtZSB8fCBtZW1iZXJOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzU3RyZWFtaW5nJywgc2hhcGUuc3RyZWFtaW5nIHx8IHRoaXMuaXNTdHJlYW1pbmcgfHwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZXNMZW5ndGgnLCBzaGFwZS5yZXF1aXJlc0xlbmd0aCwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNDb21wb3NpdGUnLCBzaGFwZS5pc0NvbXBvc2l0ZSB8fCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1NoYXBlJywgdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNRdWVyeU5hbWUnLCBCb29sZWFuKHNoYXBlLnF1ZXJ5TmFtZSksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzTG9jYXRpb25OYW1lJywgQm9vbGVhbihzaGFwZS5sb2NhdGlvbk5hbWUpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0lkZW1wb3RlbnQnLCBzaGFwZS5pZGVtcG90ZW5jeVRva2VuID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzSnNvblZhbHVlJywgc2hhcGUuanNvbnZhbHVlID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzU2Vuc2l0aXZlJywgc2hhcGUuc2Vuc2l0aXZlID09PSB0cnVlIHx8IHNoYXBlLnByb3RvdHlwZSAmJiBzaGFwZS5wcm90b3R5cGUuc2Vuc2l0aXZlID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnRTdHJlYW0nLCBCb29sZWFuKHNoYXBlLmV2ZW50c3RyZWFtKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudCcsIEJvb2xlYW4oc2hhcGUuZXZlbnQpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0V2ZW50UGF5bG9hZCcsIEJvb2xlYW4oc2hhcGUuZXZlbnRwYXlsb2FkKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudEhlYWRlcicsIEJvb2xlYW4oc2hhcGUuZXZlbnRoZWFkZXIpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1RpbWVzdGFtcEZvcm1hdFNldCcsIEJvb2xlYW4oc2hhcGUudGltZXN0YW1wRm9ybWF0KSB8fCBzaGFwZS5wcm90b3R5cGUgJiYgc2hhcGUucHJvdG90eXBlLmlzVGltZXN0YW1wRm9ybWF0U2V0ID09PSB0cnVlLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludERpc2NvdmVyeUlkJywgQm9vbGVhbihzaGFwZS5lbmRwb2ludGRpc2NvdmVyeWlkKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaG9zdExhYmVsJywgQm9vbGVhbihzaGFwZS5ob3N0TGFiZWwpLCBmYWxzZSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgc2hhcGUuZG9jdW1lbnRhdGlvbik7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb25VcmwnLCBzaGFwZS5kb2N1bWVudGF0aW9uVXJsKTtcbiAgfVxuXG4gIGlmIChzaGFwZS54bWxBdHRyaWJ1dGUpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNYbWxBdHRyaWJ1dGUnLCBzaGFwZS54bWxBdHRyaWJ1dGUgfHwgZmFsc2UpO1xuICB9XG5cbiAgLy8gdHlwZSBjb252ZXJzaW9uIGFuZCBwYXJzaW5nXG4gIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBudWxsKTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUubm9ybWFsaXplZFR5cGVzID0ge1xuICBjaGFyYWN0ZXI6ICdzdHJpbmcnLFxuICBkb3VibGU6ICdmbG9hdCcsXG4gIGxvbmc6ICdpbnRlZ2VyJyxcbiAgc2hvcnQ6ICdpbnRlZ2VyJyxcbiAgYmlnaW50ZWdlcjogJ2ludGVnZXInLFxuICBiaWdkZWNpbWFsOiAnZmxvYXQnLFxuICBibG9iOiAnYmluYXJ5J1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUudHlwZXMgPSB7XG4gICdzdHJ1Y3R1cmUnOiBTdHJ1Y3R1cmVTaGFwZSxcbiAgJ2xpc3QnOiBMaXN0U2hhcGUsXG4gICdtYXAnOiBNYXBTaGFwZSxcbiAgJ2Jvb2xlYW4nOiBCb29sZWFuU2hhcGUsXG4gICd0aW1lc3RhbXAnOiBUaW1lc3RhbXBTaGFwZSxcbiAgJ2Zsb2F0JzogRmxvYXRTaGFwZSxcbiAgJ2ludGVnZXInOiBJbnRlZ2VyU2hhcGUsXG4gICdzdHJpbmcnOiBTdHJpbmdTaGFwZSxcbiAgJ2Jhc2U2NCc6IEJhc2U2NFNoYXBlLFxuICAnYmluYXJ5JzogQmluYXJ5U2hhcGVcbn07XG5cblNoYXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHNoYXBlLCBvcHRpb25zKSB7XG4gIGlmIChzaGFwZS5zaGFwZSkge1xuICAgIHZhciByZWZTaGFwZSA9IG9wdGlvbnMuYXBpLnNoYXBlc1tzaGFwZS5zaGFwZV07XG4gICAgaWYgKCFyZWZTaGFwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzaGFwZSByZWZlcmVuY2U6ICcgKyBzaGFwZS5zaGFwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZlNoYXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5TaGFwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoc2hhcGUsIG9wdGlvbnMsIG1lbWJlck5hbWUpIHtcbiAgaWYgKHNoYXBlLmlzU2hhcGUpIHJldHVybiBzaGFwZTtcblxuICB2YXIgcmVmU2hhcGUgPSBTaGFwZS5yZXNvbHZlKHNoYXBlLCBvcHRpb25zKTtcbiAgaWYgKHJlZlNoYXBlKSB7XG4gICAgdmFyIGZpbHRlcmVkS2V5cyA9IE9iamVjdC5rZXlzKHNoYXBlKTtcbiAgICBpZiAoIW9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgICAgZmlsdGVyZWRLZXlzID0gZmlsdGVyZWRLZXlzLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAhbmFtZS5tYXRjaCgvZG9jdW1lbnRhdGlvbi8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFuIGlubGluZSBzaGFwZSB3aXRoIGV4dHJhIG1lbWJlcnNcbiAgICB2YXIgSW5saW5lU2hhcGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlZlNoYXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgc2hhcGUsIG9wdGlvbnMsIG1lbWJlck5hbWUpO1xuICAgIH07XG4gICAgSW5saW5lU2hhcGUucHJvdG90eXBlID0gcmVmU2hhcGU7XG4gICAgcmV0dXJuIG5ldyBJbmxpbmVTaGFwZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNldCB0eXBlIGlmIG5vdCBzZXRcbiAgICBpZiAoIXNoYXBlLnR5cGUpIHtcbiAgICAgIGlmIChzaGFwZS5tZW1iZXJzKSBzaGFwZS50eXBlID0gJ3N0cnVjdHVyZSc7XG4gICAgICBlbHNlIGlmIChzaGFwZS5tZW1iZXIpIHNoYXBlLnR5cGUgPSAnbGlzdCc7XG4gICAgICBlbHNlIGlmIChzaGFwZS5rZXkpIHNoYXBlLnR5cGUgPSAnbWFwJztcbiAgICAgIGVsc2Ugc2hhcGUudHlwZSA9ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSB0eXBlc1xuICAgIHZhciBvcmlnVHlwZSA9IHNoYXBlLnR5cGU7XG4gICAgaWYgKFNoYXBlLm5vcm1hbGl6ZWRUeXBlc1tzaGFwZS50eXBlXSkge1xuICAgICAgc2hhcGUudHlwZSA9IFNoYXBlLm5vcm1hbGl6ZWRUeXBlc1tzaGFwZS50eXBlXTtcbiAgICB9XG5cbiAgICBpZiAoU2hhcGUudHlwZXNbc2hhcGUudHlwZV0pIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUudHlwZXNbc2hhcGUudHlwZV0oc2hhcGUsIG9wdGlvbnMsIG1lbWJlck5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBzaGFwZSB0eXBlOiAnICsgb3JpZ1R5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gQ29tcG9zaXRlU2hhcGUoc2hhcGUpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzQ29tcG9zaXRlJywgdHJ1ZSk7XG5cbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdmbGF0dGVuZWQnLCBzaGFwZS5mbGF0dGVuZWQgfHwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFN0cnVjdHVyZVNoYXBlKHNoYXBlLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlcXVpcmVkTWFwID0gbnVsbCwgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcblxuICBDb21wb3NpdGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChmaXJzdEluaXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSk7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlcnMnLCB7fSk7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlck5hbWVzJywgW10pO1xuICAgIHByb3BlcnR5KHRoaXMsICdyZXF1aXJlZCcsIFtdKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNSZXF1aXJlZCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgIHByb3BlcnR5KHRoaXMsICdpc0RvY3VtZW50JywgQm9vbGVhbihzaGFwZS5kb2N1bWVudCkpO1xuICB9XG5cbiAgaWYgKHNoYXBlLm1lbWJlcnMpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnbWVtYmVycycsIG5ldyBDb2xsZWN0aW9uKHNoYXBlLm1lbWJlcnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShtZW1iZXIsIG9wdGlvbnMsIG5hbWUpO1xuICAgIH0pKTtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdtZW1iZXJOYW1lcycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNoYXBlLnhtbE9yZGVyIHx8IE9iamVjdC5rZXlzKHNoYXBlLm1lbWJlcnMpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNoYXBlLmV2ZW50KSB7XG4gICAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdldmVudFBheWxvYWRNZW1iZXJOYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0gc2VsZi5tZW1iZXJzO1xuICAgICAgICB2YXIgbWVtYmVyTmFtZXMgPSBzZWxmLm1lbWJlck5hbWVzO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgbWVtYmVycyB0byBmaW5kIG9uZXMgdGhhdCBhcmUgZXZlbnQgcGF5bG9hZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBtZW1iZXJOYW1lcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWVtYmVyc1ttZW1iZXJOYW1lc1tpXV0uaXNFdmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXJOYW1lc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdldmVudEhlYWRlck1lbWJlck5hbWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0gc2VsZi5tZW1iZXJzO1xuICAgICAgICB2YXIgbWVtYmVyTmFtZXMgPSBzZWxmLm1lbWJlck5hbWVzO1xuICAgICAgICB2YXIgZXZlbnRIZWFkZXJNZW1iZXJOYW1lcyA9IFtdO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgbWVtYmVycyB0byBmaW5kIG9uZXMgdGhhdCBhcmUgZXZlbnQgaGVhZGVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IG1lbWJlck5hbWVzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgIGlmIChtZW1iZXJzW21lbWJlck5hbWVzW2ldXS5pc0V2ZW50SGVhZGVyKSB7XG4gICAgICAgICAgICBldmVudEhlYWRlck1lbWJlck5hbWVzLnB1c2gobWVtYmVyTmFtZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRIZWFkZXJNZW1iZXJOYW1lcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaGFwZS5yZXF1aXJlZCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdyZXF1aXJlZCcsIHNoYXBlLnJlcXVpcmVkKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNSZXF1aXJlZCcsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghcmVxdWlyZWRNYXApIHtcbiAgICAgICAgcmVxdWlyZWRNYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5yZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlcXVpcmVkTWFwW3NoYXBlLnJlcXVpcmVkW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcXVpcmVkTWFwW25hbWVdO1xuICAgIH0sIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIHByb3BlcnR5KHRoaXMsICdyZXN1bHRXcmFwcGVyJywgc2hhcGUucmVzdWx0V3JhcHBlciB8fCBudWxsKTtcblxuICBpZiAoc2hhcGUucGF5bG9hZCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdwYXlsb2FkJywgc2hhcGUucGF5bG9hZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHNoYXBlLnhtbE5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlVXJpJywgc2hhcGUueG1sTmFtZXNwYWNlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2hhcGUueG1sTmFtZXNwYWNlID09PSAnb2JqZWN0Jykge1xuICAgIHByb3BlcnR5KHRoaXMsICd4bWxOYW1lc3BhY2VQcmVmaXgnLCBzaGFwZS54bWxOYW1lc3BhY2UucHJlZml4KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlVXJpJywgc2hhcGUueG1sTmFtZXNwYWNlLnVyaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTGlzdFNoYXBlKHNoYXBlLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcywgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuICB9XG5cbiAgaWYgKHNoYXBlLm1lbWJlcikge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ21lbWJlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZS5tZW1iZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuZmxhdHRlbmVkKSB7XG4gICAgdmFyIG9sZE5hbWUgPSB0aGlzLm5hbWU7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGYubWVtYmVyLm5hbWUgfHwgb2xkTmFtZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBNYXBTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuICAgIHByb3BlcnR5KHRoaXMsICdrZXknLCBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJpbmcnfSwgb3B0aW9ucykpO1xuICAgIHByb3BlcnR5KHRoaXMsICd2YWx1ZScsIFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cmluZyd9LCBvcHRpb25zKSk7XG4gIH1cblxuICBpZiAoc2hhcGUua2V5KSB7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAna2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLmtleSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHNoYXBlLnZhbHVlKSB7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUudmFsdWUsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRpbWVzdGFtcFNoYXBlKHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoc2hhcGUudGltZXN0YW1wRm9ybWF0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsIHNoYXBlLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH0gZWxzZSBpZiAoc2VsZi5pc1RpbWVzdGFtcEZvcm1hdFNldCAmJiB0aGlzLnRpbWVzdGFtcEZvcm1hdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCB0aGlzLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH0gZWxzZSBpZiAodGhpcy5sb2NhdGlvbiA9PT0gJ2hlYWRlcicpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgJ3JmYzgyMicpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9jYXRpb24gPT09ICdxdWVyeXN0cmluZycpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgJ2lzbzg2MDEnKTtcbiAgfSBlbHNlIGlmICh0aGlzLmFwaSkge1xuICAgIHN3aXRjaCAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgY2FzZSAncmVzdC1qc29uJzpcbiAgICAgICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICd1bml4VGltZXN0YW1wJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzdC14bWwnOlxuICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgY2FzZSAnZWMyJzpcbiAgICAgICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdpc284NjAxJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50b1VUQ1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICB1dGlsLmRhdGUucGFyc2VUaW1lc3RhbXAodmFsdWUpIDogbnVsbDtcbiAgfTtcblxuICB0aGlzLnRvV2lyZUZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwuZGF0ZS5mb3JtYXQodmFsdWUsIHNlbGYudGltZXN0YW1wRm9ybWF0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gU3RyaW5nU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdmFyIG51bGxMZXNzUHJvdG9jb2xzID0gWydyZXN0LXhtbCcsICdxdWVyeScsICdlYzInXTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhbHVlID0gdGhpcy5hcGkgJiYgbnVsbExlc3NQcm90b2NvbHMuaW5kZXhPZih0aGlzLmFwaS5wcm90b2NvbCkgPiAtMSA/XG4gICAgICB2YWx1ZSB8fCAnJyA6IHZhbHVlO1xuICAgIGlmICh0aGlzLmlzSnNvblZhbHVlKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG4gIH07XG5cbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSnNvblZhbHVlID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEZsb2F0U2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH07XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gdGhpcy50b1R5cGU7XG59XG5cbmZ1bmN0aW9uIEludGVnZXJTaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHRoaXMudG9UeXBlO1xufVxuXG5mdW5jdGlvbiBCaW5hcnlTaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBidWYgPSB1dGlsLmJhc2U2NC5kZWNvZGUodmFsdWUpO1xuICAgIGlmICh0aGlzLmlzU2Vuc2l0aXZlICYmIHV0aWwuaXNOb2RlKCkgJiYgdHlwZW9mIHV0aWwuQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gIC8qIE5vZGUuanMgY2FuIGNyZWF0ZSBhIEJ1ZmZlciB0aGF0IGlzIG5vdCBpc29sYXRlZC5cbiAgICogaS5lLiBidWYuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgc2Vuc2l0aXZlIGRhdGEgaXMgYWNjZXNzaWJsZSB0byBhbnlvbmUgd2l0aCBhY2Nlc3MgdG8gYnVmLmJ1ZmZlci5cbiAgICogSWYgdGhpcyBpcyB0aGUgbm9kZSBzaGFyZWQgQnVmZmVyLCB0aGVuIG90aGVyIGNvZGUgd2l0aGluIHRoaXMgcHJvY2VzcyBfY291bGRfIGZpbmQgdGhpcyBzZWNyZXQuXG4gICAqIENvcHkgc2Vuc2l0aXZlIGRhdGEgdG8gYW4gaXNvbGF0ZWQgQnVmZmVyIGFuZCB6ZXJvIHRoZSBzZW5zaXRpdmUgZGF0YS5cbiAgICogV2hpbGUgdGhpcyBpcyBzYWZlIHRvIGRvIGhlcmUsIGNvcHlpbmcgdGhpcyBjb2RlIHNvbWV3aGVyZSBlbHNlIG1heSBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICovXG4gICAgICB2YXIgc2VjdXJlQnVmID0gdXRpbC5CdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCwgYnVmKTtcbiAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgYnVmID0gc2VjdXJlQnVmO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHV0aWwuYmFzZTY0LmVuY29kZTtcbn1cblxuZnVuY3Rpb24gQmFzZTY0U2hhcGUoKSB7XG4gIEJpbmFyeVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEJvb2xlYW5TaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnO1xuICB9O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5TaGFwZS5zaGFwZXMgPSB7XG4gIFN0cnVjdHVyZVNoYXBlOiBTdHJ1Y3R1cmVTaGFwZSxcbiAgTGlzdFNoYXBlOiBMaXN0U2hhcGUsXG4gIE1hcFNoYXBlOiBNYXBTaGFwZSxcbiAgU3RyaW5nU2hhcGU6IFN0cmluZ1NoYXBlLFxuICBCb29sZWFuU2hhcGU6IEJvb2xlYW5TaGFwZSxcbiAgQmFzZTY0U2hhcGU6IEJhc2U2NFNoYXBlXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHJlZ2lvbl91dGlscyA9IHJlcXVpcmUoJy4vcmVnaW9uL3V0aWxzJyk7XG52YXIgaXNGaXBzUmVnaW9uID0gcmVnaW9uX3V0aWxzLmlzRmlwc1JlZ2lvbjtcbnZhciBnZXRSZWFsUmVnaW9uID0gcmVnaW9uX3V0aWxzLmdldFJlYWxSZWdpb247XG5cbnV0aWwuaXNCcm93c2VyID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbnV0aWwuaXNOb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuXG4vLyBub2RlLmpzIHNwZWNpZmljIG1vZHVsZXNcbnV0aWwuY3J5cHRvLmxpYiA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudXRpbC5CdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG51dGlsLmRvbWFpbiA9IHJlcXVpcmUoJ2RvbWFpbicpO1xudXRpbC5zdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnV0aWwudXJsID0gcmVxdWlyZSgndXJsJyk7XG51dGlsLnF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnV0aWwuZW52aXJvbm1lbnQgPSAnbm9kZWpzJztcbnV0aWwuY3JlYXRlRXZlbnRTdHJlYW0gPSB1dGlsLnN0cmVhbS5SZWFkYWJsZSA/XG4gIHJlcXVpcmUoJy4vZXZlbnQtc3RyZWFtL3N0cmVhbWluZy1jcmVhdGUtZXZlbnQtc3RyZWFtJykuY3JlYXRlRXZlbnRTdHJlYW0gOiByZXF1aXJlKCcuL2V2ZW50LXN0cmVhbS9idWZmZXJlZC1jcmVhdGUtZXZlbnQtc3RyZWFtJykuY3JlYXRlRXZlbnRTdHJlYW07XG51dGlsLnJlYWxDbG9jayA9IHJlcXVpcmUoJy4vcmVhbGNsb2NrL25vZGVDbG9jaycpO1xudXRpbC5jbGllbnRTaWRlTW9uaXRvcmluZyA9IHtcbiAgUHVibGlzaGVyOiByZXF1aXJlKCcuL3B1Ymxpc2hlcicpLlB1Ymxpc2hlcixcbiAgY29uZmlnUHJvdmlkZXI6IHJlcXVpcmUoJy4vcHVibGlzaGVyL2NvbmZpZ3VyYXRpb24nKSxcbn07XG51dGlsLmluaUxvYWRlciA9IHJlcXVpcmUoJy4vc2hhcmVkLWluaScpLmluaUxvYWRlcjtcbnV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lID0gcmVxdWlyZSgndXRpbCcpLmdldFN5c3RlbUVycm9yTmFtZTtcblxudXRpbC5sb2FkQ29uZmlnID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgZW52VmFsdWUgPSBvcHRpb25zLmVudmlyb25tZW50VmFyaWFibGVTZWxlY3Rvcihwcm9jZXNzLmVudik7XG4gIGlmIChlbnZWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVudlZhbHVlO1xuICB9XG5cbiAgdmFyIGNvbmZpZ0ZpbGUgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25maWdGaWxlID0gdXRpbC5pbmlMb2FkZXIgPyB1dGlsLmluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICBpc0NvbmZpZzogdHJ1ZSxcbiAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudlt1dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdXG4gICAgfSkgOiB7fTtcbiAgfSBjYXRjaCAoZSkge31cbiAgdmFyIHNoYXJlZEZpbGVDb25maWcgPSBjb25maWdGaWxlW1xuICAgIHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHV0aWwuZGVmYXVsdFByb2ZpbGVcbiAgXSB8fCB7fTtcbiAgdmFyIGNvbmZpZ1ZhbHVlID0gb3B0aW9ucy5jb25maWdGaWxlU2VsZWN0b3Ioc2hhcmVkRmlsZUNvbmZpZyk7XG4gIGlmIChjb25maWdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1ZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdDtcbn07XG5cbnZhciBBV1M7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbicpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy90ZW1wb3JhcnlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY2hhaW5hYmxlX3RlbXBvcmFyeV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy93ZWJfaWRlbnRpdHlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY29nbml0b19pZGVudGl0eV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9zYW1sX2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3Byb2Nlc3NfY3JlZGVudGlhbHMnKTtcblxuLy8gTG9hZCB0aGUgeG1sMmpzIFhNTCBwYXJzZXJcbkFXUy5YTUwuUGFyc2VyID0gcmVxdWlyZSgnLi94bWwvbm9kZV9wYXJzZXInKTtcblxuLy8gTG9hZCBOb2RlIEhUVFAgY2xpZW50XG5yZXF1aXJlKCcuL2h0dHAvbm9kZScpO1xuXG5yZXF1aXJlKCcuL3NoYXJlZC1pbmkvaW5pLWxvYWRlcicpO1xuXG4vLyBMb2FkIGN1c3RvbSBjcmVkZW50aWFsIHByb3ZpZGVyc1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy90b2tlbl9maWxlX3dlYl9pZGVudGl0eV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9lYzJfbWV0YWRhdGFfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvcmVtb3RlX2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2Vjc19jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9lbnZpcm9ubWVudF9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9maWxlX3N5c3RlbV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9zaGFyZWRfaW5pX2ZpbGVfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvcHJvY2Vzc19jcmVkZW50aWFscycpO1xuXG4vLyBTZXR1cCBkZWZhdWx0IGNoYWluIHByb3ZpZGVyc1xuLy8gSWYgdGhpcyBjaGFuZ2VzLCBwbGVhc2UgdXBkYXRlIGRvY3VtZW50YXRpb24gZm9yXG4vLyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyBpblxuLy8gY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbi5qc1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7IH0sXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQU1BWk9OJyk7IH0sXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKCk7IH0sXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRUNTQ3JlZGVudGlhbHMoKTsgfSxcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Qcm9jZXNzQ3JlZGVudGlhbHMoKTsgfSxcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzKCk7IH0sXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpOyB9XG5dO1xuXG52YXIgZ2V0UmVnaW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbnYgPSBwcm9jZXNzLmVudjtcbiAgdmFyIHJlZ2lvbiA9IGVudi5BV1NfUkVHSU9OIHx8IGVudi5BTUFaT05fUkVHSU9OO1xuICBpZiAoZW52W0FXUy51dGlsLmNvbmZpZ09wdEluRW52XSkge1xuICAgIHZhciB0b0NoZWNrID0gW1xuICAgICAge2ZpbGVuYW1lOiBlbnZbQVdTLnV0aWwuc2hhcmVkQ3JlZGVudGlhbHNGaWxlRW52XX0sXG4gICAgICB7aXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBlbnZbQVdTLnV0aWwuc2hhcmVkQ29uZmlnRmlsZUVudl19XG4gICAgXTtcbiAgICB2YXIgaW5pTG9hZGVyID0gQVdTLnV0aWwuaW5pTG9hZGVyO1xuICAgIHdoaWxlICghcmVnaW9uICYmIHRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICB2YXIgY29uZmlnRmlsZSA9IHt9O1xuICAgICAgdmFyIGZpbGVJbmZvID0gdG9DaGVjay5zaGlmdCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnRmlsZSA9IGluaUxvYWRlci5sb2FkRnJvbShmaWxlSW5mbyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGZpbGVJbmZvLmlzQ29uZmlnKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZmlsZSA9IGNvbmZpZ0ZpbGVbZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlXTtcbiAgICAgIHJlZ2lvbiA9IHByb2ZpbGUgJiYgcHJvZmlsZS5yZWdpb247XG4gICAgfVxuICB9XG4gIHJldHVybiByZWdpb247XG59O1xuXG52YXIgZ2V0Qm9vbGVhblZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgPyB0cnVlOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgVVNFX0ZJUFNfRU5EUE9JTlRfQ09ORklHX09QVElPTlMgPSB7XG4gIGVudmlyb25tZW50VmFyaWFibGVTZWxlY3RvcjogZnVuY3Rpb24oZW52KSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5WYWx1ZShlbnZbJ0FXU19VU0VfRklQU19FTkRQT0lOVCddKTtcbiAgfSxcbiAgY29uZmlnRmlsZVNlbGVjdG9yOiBmdW5jdGlvbihwcm9maWxlKSB7XG4gICAgcmV0dXJuIGdldEJvb2xlYW5WYWx1ZShwcm9maWxlWyd1c2VfZmlwc19lbmRwb2ludCddKTtcbiAgfSxcbiAgZGVmYXVsdDogZmFsc2UsXG59O1xuXG52YXIgVVNFX0RVQUxTVEFDS19FTkRQT0lOVF9DT05GSUdfT1BUSU9OUyA9IHtcbiAgZW52aXJvbm1lbnRWYXJpYWJsZVNlbGVjdG9yOiBmdW5jdGlvbihlbnYpIHtcbiAgICByZXR1cm4gZ2V0Qm9vbGVhblZhbHVlKGVudlsnQVdTX1VTRV9EVUFMU1RBQ0tfRU5EUE9JTlQnXSk7XG4gIH0sXG4gIGNvbmZpZ0ZpbGVTZWxlY3RvcjogZnVuY3Rpb24ocHJvZmlsZSkge1xuICAgIHJldHVybiBnZXRCb29sZWFuVmFsdWUocHJvZmlsZVsndXNlX2R1YWxzdGFja19lbmRwb2ludCddKTtcbiAgfSxcbiAgZGVmYXVsdDogZmFsc2UsXG59O1xuXG4vLyBVcGRhdGUgY29uZmlndXJhdGlvbiBrZXlzXG5BV1MudXRpbC51cGRhdGUoQVdTLkNvbmZpZy5wcm90b3R5cGUua2V5cywge1xuICBjcmVkZW50aWFsczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjcmVkZW50aWFscyA9IG51bGw7XG4gICAgbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbihbXG4gICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpOyB9LFxuICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKTsgfSxcbiAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKHsgZGlzYWJsZUFzc3VtZVJvbGU6IHRydWUgfSk7IH1cbiAgICBdKS5yZXNvbHZlKGZ1bmN0aW9uKGVyciwgY3JlZHMpIHtcbiAgICAgIGlmICghZXJyKSBjcmVkZW50aWFscyA9IGNyZWRzO1xuICAgIH0pO1xuICAgIHJldHVybiBjcmVkZW50aWFscztcbiAgfSxcbiAgY3JlZGVudGlhbFByb3ZpZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbigpO1xuICB9LFxuICBsb2dnZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTSlNfREVCVUcgPyBjb25zb2xlIDogbnVsbDtcbiAgfSxcbiAgcmVnaW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVnaW9uID0gZ2V0UmVnaW9uKCk7XG4gICAgcmV0dXJuIHJlZ2lvbiA/IGdldFJlYWxSZWdpb24ocmVnaW9uKTogdW5kZWZpbmVkO1xuICB9LFxuICB1c2VGaXBzRW5kcG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWdpb24gPSBnZXRSZWdpb24oKTtcbiAgICByZXR1cm4gaXNGaXBzUmVnaW9uKHJlZ2lvbilcbiAgICAgID8gdHJ1ZVxuICAgICAgOiB1dGlsLmxvYWRDb25maWcoVVNFX0ZJUFNfRU5EUE9JTlRfQ09ORklHX09QVElPTlMpO1xuICB9LFxuICB1c2VEdWFsc3RhY2tFbmRwb2ludDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwubG9hZENvbmZpZyhVU0VfRFVBTFNUQUNLX0VORFBPSU5UX0NPTkZJR19PUFRJT05TKTtcbiAgfVxufSk7XG5cbi8vIFJlc2V0IGNvbmZpZ3VyYXRpb25cbkFXUy5jb25maWcgPSBuZXcgQVdTLkNvbmZpZygpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUGFyYW1WYWxpZGF0b3IgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB2YWxpZGF0b3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsaWRhdGlvbiBbQm9vbGVhbnxtYXBdIHdoZXRoZXIgaW5wdXQgcGFyYW1ldGVycyBzaG91bGQgYmVcbiAgICogICAgIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvcGVyYXRpb24gZGVzY3JpcHRpb24gYmVmb3JlIHNlbmRpbmcgdGhlXG4gICAqICAgICByZXF1ZXN0LiBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBzcGVjaWZpY1xuICAgKiAgICAgdmFsaWRhdGlvbiBmZWF0dXJlczpcbiAgICpcbiAgICogICAgICogKiptaW4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtaW5cbiAgICogICAgICAgY29uc3RyYWludC4gVGhpcyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBwYXJhbVZhbGlkYXRpb24gaXMgc2V0XG4gICAqICAgICAgIHRvIGB0cnVlYC5cbiAgICogICAgICogKiptYXgqKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtYXhcbiAgICogICAgICAgY29uc3RyYWludC5cbiAgICogICAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gICAqICAgICAgIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICogICAgICogKiplbnVtKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBvbmVcbiAgICogICAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBQYXJhbVZhbGlkYXRvcih2YWxpZGF0aW9uKSB7XG4gICAgaWYgKHZhbGlkYXRpb24gPT09IHRydWUgfHwgdmFsaWRhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0aW9uID0geydtaW4nOiB0cnVlfTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0aW9uID0gdmFsaWRhdGlvbjtcbiAgfSxcblxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoc2hhcGUsIHBhcmFtcywgY29udGV4dCkge1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZSwgcGFyYW1zIHx8IHt9LCBjb250ZXh0IHx8ICdwYXJhbXMnKTtcblxuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgbXNnID0gdGhpcy5lcnJvcnMuam9pbignXFxuKiAnKTtcbiAgICAgIG1zZyA9ICdUaGVyZSB3ZXJlICcgKyB0aGlzLmVycm9ycy5sZW5ndGggK1xuICAgICAgICAnIHZhbGlkYXRpb24gZXJyb3JzOlxcbiogJyArIG1zZztcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcihtc2cpLFxuICAgICAgICB7Y29kZTogJ011bHRpcGxlVmFsaWRhdGlvbkVycm9ycycsIGVycm9yczogdGhpcy5lcnJvcnN9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcnNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBmYWlsOiBmdW5jdGlvbiBmYWlsKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmVycm9ycy5wdXNoKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSwge2NvZGU6IGNvZGV9KSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVTdHJ1Y3R1cmU6IGZ1bmN0aW9uIHZhbGlkYXRlU3RydWN0dXJlKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB0aGlzLnZhbGlkYXRlVHlwZShwYXJhbXMsIGNvbnRleHQsIFsnb2JqZWN0J10sICdzdHJ1Y3R1cmUnKTtcblxuICAgIHZhciBwYXJhbU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IHNoYXBlLnJlcXVpcmVkICYmIGkgPCBzaGFwZS5yZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyYW1OYW1lID0gc2hhcGUucmVxdWlyZWRbaV07XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWlzc2luZ1JlcXVpcmVkUGFyYW1ldGVyJyxcbiAgICAgICAgICAnTWlzc2luZyByZXF1aXJlZCBrZXkgXFwnJyArIHBhcmFtTmFtZSArICdcXCcgaW4gJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGhhc2ggbWVtYmVyc1xuICAgIGZvciAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpKSBjb250aW51ZTtcblxuICAgICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXSxcbiAgICAgICAgICBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbcGFyYW1OYW1lXTtcblxuICAgICAgaWYgKG1lbWJlclNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1lbWJlckNvbnRleHQgPSBbY29udGV4dCwgcGFyYW1OYW1lXS5qb2luKCcuJyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIobWVtYmVyU2hhcGUsIHBhcmFtVmFsdWUsIG1lbWJlckNvbnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbVZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFyYW1WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZhaWwoJ1VuZXhwZWN0ZWRQYXJhbWV0ZXInLFxuICAgICAgICAgICdVbmV4cGVjdGVkIGtleSBcXCcnICsgcGFyYW1OYW1lICsgJ1xcJyBmb3VuZCBpbiAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgdmFsaWRhdGVNZW1iZXI6IGZ1bmN0aW9uIHZhbGlkYXRlTWVtYmVyKHNoYXBlLCBwYXJhbSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSAnc3RydWN0dXJlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTdHJ1Y3R1cmUoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUxpc3Qoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTWFwKHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNjYWxhcihzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZUxpc3Q6IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdChzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHBhcmFtcywgY29udGV4dCwgW0FycmF5XSkpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVSYW5nZShzaGFwZSwgcGFyYW1zLmxlbmd0aCwgY29udGV4dCwgJ2xpc3QgbWVtYmVyIGNvdW50Jyk7XG4gICAgICAvLyB2YWxpZGF0ZSBhcnJheSBtZW1iZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKHNoYXBlLm1lbWJlciwgcGFyYW1zW2ldLCBjb250ZXh0ICsgJ1snICsgaSArICddJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlTWFwOiBmdW5jdGlvbiB2YWxpZGF0ZU1hcChzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHBhcmFtcywgY29udGV4dCwgWydvYmplY3QnXSwgJ21hcCcpKSB7XG4gICAgICAvLyBCdWlsZCB1cCBhIGNvdW50IG9mIG1hcCBtZW1iZXJzIHRvIHZhbGlkYXRlIHJhbmdlIHRyYWl0cy5cbiAgICAgIHZhciBtYXBDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbSkpIGNvbnRpbnVlO1xuICAgICAgICAvLyBWYWxpZGF0ZSBhbnkgbWFwIGtleSB0cmFpdCBjb25zdHJhaW50c1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKHNoYXBlLmtleSwgcGFyYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCArICdba2V5PVxcJycgKyBwYXJhbSArICdcXCddJyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUudmFsdWUsIHBhcmFtc1twYXJhbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCArICdbXFwnJyArIHBhcmFtICsgJ1xcJ10nKTtcbiAgICAgICAgbWFwQ291bnQrKztcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGVSYW5nZShzaGFwZSwgbWFwQ291bnQsIGNvbnRleHQsICdtYXAgbWVtYmVyIGNvdW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlU2NhbGFyOiBmdW5jdGlvbiB2YWxpZGF0ZVNjYWxhcihzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTdHJpbmcoc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVBheWxvYWQodmFsdWUsIGNvbnRleHQpO1xuICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTnVtYmVyKHNoYXBlLCB2YWx1ZSwgY29udGV4dCk7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCBbJ2Jvb2xlYW4nXSk7XG4gICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIFtEYXRlLFxuICAgICAgICAgIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/WiQvLCAnbnVtYmVyJ10sXG4gICAgICAgICAgJ0RhdGUgb2JqZWN0LCBJU08tODYwMSBzdHJpbmcsIG9yIGEgVU5JWCB0aW1lc3RhbXAnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWwoJ1Vua293blR5cGUnLCAnVW5oYW5kbGVkIHR5cGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUudHlwZSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHZhciB2YWxpZFR5cGVzID0gWydzdHJpbmcnXTtcbiAgICBpZiAoc2hhcGUuaXNKc29uVmFsdWUpIHtcbiAgICAgIHZhbGlkVHlwZXMgPSB2YWxpZFR5cGVzLmNvbmNhdChbJ251bWJlcicsICdvYmplY3QnLCAnYm9vbGVhbiddKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCB2YWxpZFR5cGVzKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZUVudW0oc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIHRoaXMudmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUubGVuZ3RoLCBjb250ZXh0LCAnc3RyaW5nIGxlbmd0aCcpO1xuICAgICAgdGhpcy52YWxpZGF0ZVBhdHRlcm4oc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIHRoaXMudmFsaWRhdGVVcmkoc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVVcmk6IGZ1bmN0aW9uIHZhbGlkYXRlVXJpKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmIChzaGFwZVsnbG9jYXRpb24nXSA9PT0gJ3VyaScpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5mYWlsKCdVcmlQYXJhbWV0ZXJFcnJvcicsICdFeHBlY3RlZCB1cmkgcGFyYW1ldGVyIHRvIGhhdmUgbGVuZ3RoID49IDEsJ1xuICAgICAgICAgICsgJyBidXQgZm91bmQgXCInICsgdmFsdWUgKydcIiBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVBhdHRlcm46IGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVybihzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydwYXR0ZXJuJ10gJiYgc2hhcGVbJ3BhdHRlcm4nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIShuZXcgUmVnRXhwKHNoYXBlWydwYXR0ZXJuJ10pKS50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ1BhdHRlcm5NYXRjaEVycm9yJywgJ1Byb3ZpZGVkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiICdcbiAgICAgICAgICArICdkb2VzIG5vdCBtYXRjaCByZWdleCBwYXR0ZXJuIC8nICsgc2hhcGVbJ3BhdHRlcm4nXSArICcvIGZvciAnXG4gICAgICAgICAgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVSYW5nZTogZnVuY3Rpb24gdmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUsIGNvbnRleHQsIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydtaW4nXSkge1xuICAgICAgaWYgKHNoYXBlWydtaW4nXSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgc2hhcGVbJ21pbiddKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWluUmFuZ2VFcnJvcicsICdFeHBlY3RlZCAnICsgZGVzY3JpcHRvciArICcgPj0gJ1xuICAgICAgICAgICsgc2hhcGVbJ21pbiddICsgJywgYnV0IGZvdW5kICcgKyB2YWx1ZSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudmFsaWRhdGlvblsnbWF4J10pIHtcbiAgICAgIGlmIChzaGFwZVsnbWF4J10gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHNoYXBlWydtYXgnXSkge1xuICAgICAgICB0aGlzLmZhaWwoJ01heFJhbmdlRXJyb3InLCAnRXhwZWN0ZWQgJyArIGRlc2NyaXB0b3IgKyAnIDw9ICdcbiAgICAgICAgICArIHNoYXBlWydtYXgnXSArICcsIGJ1dCBmb3VuZCAnICsgdmFsdWUgKyAnIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlRW51bTogZnVuY3Rpb24gdmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydlbnVtJ10gJiYgc2hhcGVbJ2VudW0nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBGYWlsIGlmIHRoZSBzdHJpbmcgdmFsdWUgaXMgbm90IHByZXNlbnQgaW4gdGhlIGVudW0gbGlzdFxuICAgICAgaWYgKHNoYXBlWydlbnVtJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnRW51bUVycm9yJywgJ0ZvdW5kIHN0cmluZyB2YWx1ZSBvZiAnICsgdmFsdWUgKyAnLCBidXQgJ1xuICAgICAgICAgICsgJ2V4cGVjdGVkICcgKyBzaGFwZVsnZW51bSddLmpvaW4oJ3wnKSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVUeXBlOiBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIGFjY2VwdGVkVHlwZXMsIHR5cGUpIHtcbiAgICAvLyBXZSB3aWxsIG5vdCBsb2cgYW4gZXJyb3IgZm9yIG51bGwgb3IgdW5kZWZpbmVkLCBidXQgd2Ugd2lsbCByZXR1cm5cbiAgICAvLyBmYWxzZSBzbyB0aGF0IGNhbGxlcnMga25vdyB0aGF0IHRoZSBleHBlY3RlZCB0eXBlIHdhcyBub3Qgc3RyaWN0bHkgbWV0LlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZm91bmRJbnZhbGlkVHlwZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0ZWRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBhY2NlcHRlZFR5cGVzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBhY2NlcHRlZFR5cGVzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoYWNjZXB0ZWRUeXBlc1tpXSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBpZiAoKHZhbHVlIHx8ICcnKS50b1N0cmluZygpLm1hdGNoKGFjY2VwdGVkVHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGFjY2VwdGVkVHlwZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoQVdTLnV0aWwuaXNUeXBlKHZhbHVlLCBhY2NlcHRlZFR5cGVzW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghdHlwZSAmJiAhZm91bmRJbnZhbGlkVHlwZSkgYWNjZXB0ZWRUeXBlcyA9IGFjY2VwdGVkVHlwZXMuc2xpY2UoKTtcbiAgICAgICAgYWNjZXB0ZWRUeXBlc1tpXSA9IEFXUy51dGlsLnR5cGVOYW1lKGFjY2VwdGVkVHlwZXNbaV0pO1xuICAgICAgfVxuICAgICAgZm91bmRJbnZhbGlkVHlwZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGFjY2VwdGVkVHlwZSA9IHR5cGU7XG4gICAgaWYgKCFhY2NlcHRlZFR5cGUpIHtcbiAgICAgIGFjY2VwdGVkVHlwZSA9IGFjY2VwdGVkVHlwZXMuam9pbignLCAnKS5yZXBsYWNlKC8sKFteLF0rKSQvLCAnLCBvciQxJyk7XG4gICAgfVxuXG4gICAgdmFyIHZvd2VsID0gYWNjZXB0ZWRUeXBlLm1hdGNoKC9eW2FlaW91XS9pKSA/ICduJyA6ICcnO1xuICAgIHRoaXMuZmFpbCgnSW52YWxpZFBhcmFtZXRlclR5cGUnLCAnRXhwZWN0ZWQgJyArIGNvbnRleHQgKyAnIHRvIGJlIGEnICtcbiAgICAgICAgICAgICAgdm93ZWwgKyAnICcgKyBhY2NlcHRlZFR5cGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICB2YWxpZGF0ZU51bWJlcjogZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNhc3RlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoY2FzdGVkVmFsdWUudG9TdHJpbmcoKSA9PT0gdmFsdWUpIHZhbHVlID0gY2FzdGVkVmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgWydudW1iZXInXSkpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUsIGNvbnRleHQsICdudW1lcmljIHZhbHVlJyk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlUGF5bG9hZDogZnVuY3Rpb24gdmFsaWRhdGVQYXlsb2FkKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHJldHVybjsgLy8gdHlwZWQgYXJyYXlzXG4gICAgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7IC8vIHNwZWNpYWwgY2hlY2sgZm9yIGJ1ZmZlci9zdHJlYW0gaW4gTm9kZS5qc1xuICAgICAgdmFyIFN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5TdHJlYW07XG4gICAgICBpZiAoQVdTLnV0aWwuQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmVhbSkgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09IHZvaWQgMCAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHlwZXMgPSBbJ0J1ZmZlcicsICdTdHJlYW0nLCAnRmlsZScsICdCbG9iJywgJ0FycmF5QnVmZmVyJywgJ0RhdGFWaWV3J107XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc1R5cGUodmFsdWUsIHR5cGVzW2ldKSkgcmV0dXJuO1xuICAgICAgICBpZiAoQVdTLnV0aWwudHlwZU5hbWUodmFsdWUuY29uc3RydWN0b3IpID09PSB0eXBlc1tpXSkgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmFpbCgnSW52YWxpZFBhcmFtZXRlclR5cGUnLCAnRXhwZWN0ZWQgJyArIGNvbnRleHQgKyAnIHRvIGJlIGEgJyArXG4gICAgICAnc3RyaW5nLCBCdWZmZXIsIFN0cmVhbSwgQmxvYiwgb3IgdHlwZWQgYXJyYXkgb2JqZWN0Jyk7XG4gIH1cbn0pO1xuIiwidmFyIHV0aWwgPSAgcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBQcmVwZW5kIHByZWZpeCBkZWZpbmVkIGJ5IEFQSSBtb2RlbCB0byBlbmRwb2ludCB0aGF0J3MgYWxyZWFkeVxuICogY29uc3RydWN0ZWQuIFRoaXMgZmVhdHVyZSBkb2VzIG5vdCBhcHBseSB0byBvcGVyYXRpb25zIHVzaW5nXG4gKiBlbmRwb2ludCBkaXNjb3ZlcnkgYW5kIGNhbiBiZSBkaXNhYmxlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwb3B1bGF0ZUhvc3RQcmVmaXgocmVxdWVzdCkgIHtcbiAgdmFyIGVuYWJsZWQgPSByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmhvc3RQcmVmaXhFbmFibGVkO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybiByZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICAvL2Rvbid0IG1hcnNoYWwgaG9zdCBwcmVmaXggd2hlbiBvcGVyYXRpb24gaGFzIGVuZHBvaW50IGRpc2NvdmVyeSB0cmFpdHNcbiAgaWYgKGhhc0VuZHBvaW50RGlzY292ZXIocmVxdWVzdCkpIHJldHVybiByZXF1ZXN0O1xuICBpZiAob3BlcmF0aW9uTW9kZWwuZW5kcG9pbnQgJiYgb3BlcmF0aW9uTW9kZWwuZW5kcG9pbnQuaG9zdFByZWZpeCkge1xuICAgIHZhciBob3N0UHJlZml4Tm90YXRpb24gPSBvcGVyYXRpb25Nb2RlbC5lbmRwb2ludC5ob3N0UHJlZml4O1xuICAgIHZhciBob3N0UHJlZml4ID0gZXhwYW5kSG9zdFByZWZpeChob3N0UHJlZml4Tm90YXRpb24sIHJlcXVlc3QucGFyYW1zLCBvcGVyYXRpb25Nb2RlbC5pbnB1dCk7XG4gICAgcHJlcGVuZEVuZHBvaW50UHJlZml4KHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQsIGhvc3RQcmVmaXgpO1xuICAgIHZhbGlkYXRlSG9zdG5hbWUocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0bmFtZSk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3Q7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0VuZHBvaW50RGlzY292ZXIocmVxdWVzdCkge1xuICB2YXIgYXBpID0gcmVxdWVzdC5zZXJ2aWNlLmFwaTtcbiAgdmFyIG9wZXJhdGlvbk1vZGVsID0gYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICB2YXIgaXNFbmRwb2ludE9wZXJhdGlvbiA9IGFwaS5lbmRwb2ludE9wZXJhdGlvbiAmJiAoYXBpLmVuZHBvaW50T3BlcmF0aW9uID09PSB1dGlsLnN0cmluZy5sb3dlckZpcnN0KG9wZXJhdGlvbk1vZGVsLm5hbWUpKTtcbiAgcmV0dXJuIChvcGVyYXRpb25Nb2RlbC5lbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkICE9PSAnTlVMTCcgfHwgaXNFbmRwb2ludE9wZXJhdGlvbiA9PT0gdHJ1ZSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZEhvc3RQcmVmaXgoaG9zdFByZWZpeE5vdGF0aW9uLCBwYXJhbXMsIHNoYXBlKSB7XG4gIHV0aWwuZWFjaChzaGFwZS5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICBpZiAobWVtYmVyLmhvc3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbbmFtZV0gIT09ICdzdHJpbmcnIHx8IHBhcmFtc1tuYW1lXSA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgIG1lc3NhZ2U6ICdQYXJhbWV0ZXIgJyArIG5hbWUgKyAnIHNob3VsZCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICBjb2RlOiAnSW52YWxpZFBhcmFtZXRlcidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdcXFxceycgKyBuYW1lICsgJ1xcXFx9JywgJ2cnKTtcbiAgICAgIGhvc3RQcmVmaXhOb3RhdGlvbiA9IGhvc3RQcmVmaXhOb3RhdGlvbi5yZXBsYWNlKHJlZ2V4LCBwYXJhbXNbbmFtZV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBob3N0UHJlZml4Tm90YXRpb247XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRFbmRwb2ludFByZWZpeChlbmRwb2ludCwgcHJlZml4KSB7XG4gIGlmIChlbmRwb2ludC5ob3N0KSB7XG4gICAgZW5kcG9pbnQuaG9zdCA9IHByZWZpeCArIGVuZHBvaW50Lmhvc3Q7XG4gIH1cbiAgaWYgKGVuZHBvaW50Lmhvc3RuYW1lKSB7XG4gICAgZW5kcG9pbnQuaG9zdG5hbWUgPSBwcmVmaXggKyBlbmRwb2ludC5ob3N0bmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhvc3RuYW1lKGhvc3RuYW1lKSB7XG4gIHZhciBsYWJlbHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAvL1JlZmVyZW5jZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMjMjc2VjdGlvbi0yXG4gIHZhciBob3N0UGF0dGVybiA9IC9eW2EtekEtWjAtOV17MX0kfF5bYS16QS1aMC05XVthLXpBLVowLTlcXC1dKlthLXpBLVowLTldJC87XG4gIHV0aWwuYXJyYXlFYWNoKGxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICBpZiAoIWxhYmVsLmxlbmd0aCB8fCBsYWJlbC5sZW5ndGggPCAxIHx8IGxhYmVsLmxlbmd0aCA+IDYzKSB7XG4gICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdWYWxpZGF0aW9uRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnSG9zdG5hbWUgbGFiZWwgbGVuZ3RoIHNob3VsZCBiZSBiZXR3ZWVuIDEgdG8gNjMgY2hhcmFjdGVycywgaW5jbHVzaXZlLidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWhvc3RQYXR0ZXJuLnRlc3QobGFiZWwpKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAge2NvZGU6ICdWYWxpZGF0aW9uRXJyb3InLCBtZXNzYWdlOiBsYWJlbCArICcgaXMgbm90IGhvc3RuYW1lIGNvbXBhdGlibGUuJ30pO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwb3B1bGF0ZUhvc3RQcmVmaXg6IHBvcHVsYXRlSG9zdFByZWZpeFxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIEpzb25CdWlsZGVyID0gcmVxdWlyZSgnLi4vanNvbi9idWlsZGVyJyk7XG52YXIgSnNvblBhcnNlciA9IHJlcXVpcmUoJy4uL2pzb24vcGFyc2VyJyk7XG52YXIgcG9wdWxhdGVIb3N0UHJlZml4ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykucG9wdWxhdGVIb3N0UHJlZml4O1xuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgdmFyIGFwaSA9IHJlcS5zZXJ2aWNlLmFwaTtcbiAgdmFyIHRhcmdldCA9IGFwaS50YXJnZXRQcmVmaXggKyAnLicgKyBhcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5uYW1lO1xuICB2YXIgdmVyc2lvbiA9IGFwaS5qc29uVmVyc2lvbiB8fCAnMS4wJztcbiAgdmFyIGlucHV0ID0gYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG4gIHZhciBidWlsZGVyID0gbmV3IEpzb25CdWlsZGVyKCk7XG5cbiAgaWYgKHZlcnNpb24gPT09IDEpIHZlcnNpb24gPSAnMS4wJztcbiAgaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIuYnVpbGQocmVxLnBhcmFtcyB8fCB7fSwgaW5wdXQpO1xuICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LWFtei1qc29uLScgKyB2ZXJzaW9uO1xuICBodHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1UYXJnZXQnXSA9IHRhcmdldDtcblxuICBwb3B1bGF0ZUhvc3RQcmVmaXgocmVxKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgdmFyIGVycm9yID0ge307XG4gIHZhciBodHRwUmVzcG9uc2UgPSByZXNwLmh0dHBSZXNwb25zZTtcblxuICBlcnJvci5jb2RlID0gaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16bi1lcnJvcnR5cGUnXSB8fCAnVW5rbm93bkVycm9yJztcbiAgaWYgKHR5cGVvZiBlcnJvci5jb2RlID09PSAnc3RyaW5nJykge1xuICAgIGVycm9yLmNvZGUgPSBlcnJvci5jb2RlLnNwbGl0KCc6JylbMF07XG4gIH1cblxuICBpZiAoaHR0cFJlc3BvbnNlLmJvZHkubGVuZ3RoID4gMCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZSA9IEpTT04ucGFyc2UoaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKSk7XG4gICAgICB2YXIgY29kZSA9IGUuX190eXBlIHx8IGUuY29kZSB8fCBlLkNvZGU7XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZS5zcGxpdCgnIycpLnBvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdSZXF1ZXN0RW50aXR5VG9vTGFyZ2UnKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSAnUmVxdWVzdCBib2R5IG11c3QgYmUgbGVzcyB0aGFuIDEgTUInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IChlLm1lc3NhZ2UgfHwgZS5NZXNzYWdlIHx8IG51bGwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBodHRwUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXJyb3Iuc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIGVycm9yLm1lc3NhZ2UgPSBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZS50b1N0cmluZygpO1xuICB9XG5cbiAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIGVycm9yKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgYm9keSA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKSB8fCAne30nO1xuICBpZiAocmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNvbnZlcnRSZXNwb25zZVR5cGVzID09PSBmYWxzZSkge1xuICAgIHJlc3AuZGF0YSA9IEpTT04ucGFyc2UoYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3Jlc3AucmVxdWVzdC5vcGVyYXRpb25dO1xuICAgIHZhciBzaGFwZSA9IG9wZXJhdGlvbi5vdXRwdXQgfHwge307XG4gICAgdmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKCk7XG4gICAgcmVzcC5kYXRhID0gcGFyc2VyLnBhcnNlKGJvZHksIHNoYXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgUXVlcnlQYXJhbVNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuLi9xdWVyeS9xdWVyeV9wYXJhbV9zZXJpYWxpemVyJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuLi9tb2RlbC9zaGFwZScpO1xudmFyIHBvcHVsYXRlSG9zdFByZWZpeCA9IHJlcXVpcmUoJy4vaGVscGVycycpLnBvcHVsYXRlSG9zdFByZWZpeDtcblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPVxuICAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnO1xuICBodHRwUmVxdWVzdC5wYXJhbXMgPSB7XG4gICAgVmVyc2lvbjogcmVxLnNlcnZpY2UuYXBpLmFwaVZlcnNpb24sXG4gICAgQWN0aW9uOiBvcGVyYXRpb24ubmFtZVxuICB9O1xuXG4gIC8vIGNvbnZlcnQgdGhlIHJlcXVlc3QgcGFyYW1ldGVycyBpbnRvIGEgbGlzdCBvZiBxdWVyeSBwYXJhbXMsXG4gIC8vIGUuZy4gRGVlcGx5Lk5lc3RlZFBhcmFtLjAuTmFtZT12YWx1ZVxuICB2YXIgYnVpbGRlciA9IG5ldyBRdWVyeVBhcmFtU2VyaWFsaXplcigpO1xuICBidWlsZGVyLnNlcmlhbGl6ZShyZXEucGFyYW1zLCBvcGVyYXRpb24uaW5wdXQsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaHR0cFJlcXVlc3QucGFyYW1zW25hbWVdID0gdmFsdWU7XG4gIH0pO1xuICBodHRwUmVxdWVzdC5ib2R5ID0gdXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKGh0dHBSZXF1ZXN0LnBhcmFtcyk7XG5cbiAgcG9wdWxhdGVIb3N0UHJlZml4KHJlcSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIHZhciBkYXRhLCBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpO1xuICBpZiAoYm9keS5tYXRjaCgnPFVua25vd25PcGVyYXRpb25FeGNlcHRpb24nKSkge1xuICAgIGRhdGEgPSB7XG4gICAgICBDb2RlOiAnVW5rbm93bk9wZXJhdGlvbicsXG4gICAgICBNZXNzYWdlOiAnVW5rbm93biBvcGVyYXRpb24gJyArIHJlc3AucmVxdWVzdC5vcGVyYXRpb25cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gbmV3IEFXUy5YTUwuUGFyc2VyKCkucGFyc2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgQ29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgTWVzc2FnZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGF0YS5yZXF1ZXN0SWQgJiYgIXJlc3AucmVxdWVzdElkKSByZXNwLnJlcXVlc3RJZCA9IGRhdGEucmVxdWVzdElkO1xuICBpZiAoZGF0YS5FcnJvcnMpIGRhdGEgPSBkYXRhLkVycm9ycztcbiAgaWYgKGRhdGEuRXJyb3IpIGRhdGEgPSBkYXRhLkVycm9yO1xuICBpZiAoZGF0YS5Db2RlKSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IGRhdGEuQ29kZSxcbiAgICAgIG1lc3NhZ2U6IGRhdGEuTWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgbWVzc2FnZTogbnVsbFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgc2hhcGUgPSBvcGVyYXRpb24ub3V0cHV0IHx8IHt9O1xuICB2YXIgb3JpZ1J1bGVzID0gc2hhcGU7XG5cbiAgaWYgKG9yaWdSdWxlcy5yZXN1bHRXcmFwcGVyKSB7XG4gICAgdmFyIHRtcCA9IFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cnVjdHVyZSd9KTtcbiAgICB0bXAubWVtYmVyc1tvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl0gPSBzaGFwZTtcbiAgICB0bXAubWVtYmVyTmFtZXMgPSBbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdO1xuICAgIHV0aWwucHJvcGVydHkoc2hhcGUsICduYW1lJywgc2hhcGUucmVzdWx0V3JhcHBlcik7XG4gICAgc2hhcGUgPSB0bXA7XG4gIH1cblxuICB2YXIgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG5cbiAgLy8gVE9ETzogUmVmYWN0b3IgWE1MIFBhcnNlciB0byBwYXJzZSBSZXF1ZXN0SWQgZnJvbSByZXNwb25zZS5cbiAgaWYgKHNoYXBlICYmIHNoYXBlLm1lbWJlcnMgJiYgIXNoYXBlLm1lbWJlcnMuX1hBTVpSZXF1ZXN0SWQpIHtcbiAgICB2YXIgcmVxdWVzdElkU2hhcGUgPSBTaGFwZS5jcmVhdGUoXG4gICAgICB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICB7IGFwaTogeyBwcm90b2NvbDogJ3F1ZXJ5JyB9IH0sXG4gICAgICAncmVxdWVzdElkJ1xuICAgICk7XG4gICAgc2hhcGUubWVtYmVycy5fWEFNWlJlcXVlc3RJZCA9IHJlcXVlc3RJZFNoYXBlO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYXJzZXIucGFyc2UocmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpLCBzaGFwZSk7XG4gIHJlc3AucmVxdWVzdElkID0gZGF0YS5fWEFNWlJlcXVlc3RJZCB8fCBkYXRhLnJlcXVlc3RJZDtcblxuICBpZiAoZGF0YS5fWEFNWlJlcXVlc3RJZCkgZGVsZXRlIGRhdGEuX1hBTVpSZXF1ZXN0SWQ7XG5cbiAgaWYgKG9yaWdSdWxlcy5yZXN1bHRXcmFwcGVyKSB7XG4gICAgaWYgKGRhdGFbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdKSB7XG4gICAgICB1dGlsLnVwZGF0ZShkYXRhLCBkYXRhW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXSk7XG4gICAgICBkZWxldGUgZGF0YVtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl07XG4gICAgfVxuICB9XG5cbiAgcmVzcC5kYXRhID0gZGF0YTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcG9wdWxhdGVIb3N0UHJlZml4ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykucG9wdWxhdGVIb3N0UHJlZml4O1xuXG5mdW5jdGlvbiBwb3B1bGF0ZU1ldGhvZChyZXEpIHtcbiAgcmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmh0dHBNZXRob2Q7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVVJJKGVuZHBvaW50UGF0aCwgb3BlcmF0aW9uUGF0aCwgaW5wdXQsIHBhcmFtcykge1xuICB2YXIgdXJpID0gW2VuZHBvaW50UGF0aCwgb3BlcmF0aW9uUGF0aF0uam9pbignLycpO1xuICB1cmkgPSB1cmkucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xuXG4gIHZhciBxdWVyeVN0cmluZyA9IHt9LCBxdWVyeVN0cmluZ1NldCA9IGZhbHNlO1xuICB1dGlsLmVhY2goaW5wdXQubWVtYmVycywgZnVuY3Rpb24gKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1zW25hbWVdO1xuICAgIGlmIChwYXJhbVZhbHVlID09PSBudWxsIHx8IHBhcmFtVmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICd1cmknKSB7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdcXFxceycgKyBtZW1iZXIubmFtZSArICcoXFxcXCspP1xcXFx9Jyk7XG4gICAgICB1cmkgPSB1cmkucmVwbGFjZShyZWdleCwgZnVuY3Rpb24oXywgcGx1cykge1xuICAgICAgICB2YXIgZm4gPSBwbHVzID8gdXRpbC51cmlFc2NhcGVQYXRoIDogdXRpbC51cmlFc2NhcGU7XG4gICAgICAgIHJldHVybiBmbihTdHJpbmcocGFyYW1WYWx1ZSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdxdWVyeXN0cmluZycpIHtcbiAgICAgIHF1ZXJ5U3RyaW5nU2V0ID0gdHJ1ZTtcblxuICAgICAgaWYgKG1lbWJlci50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgcXVlcnlTdHJpbmdbbWVtYmVyLm5hbWVdID0gcGFyYW1WYWx1ZS5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwudXJpRXNjYXBlKG1lbWJlci5tZW1iZXIudG9XaXJlRm9ybWF0KHZhbCkudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtZW1iZXIudHlwZSA9PT0gJ21hcCcpIHtcbiAgICAgICAgdXRpbC5lYWNoKHBhcmFtVmFsdWUsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nW2tleV0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLnVyaUVzY2FwZShTdHJpbmcodmFsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IHV0aWwudXJpRXNjYXBlKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0cmluZ1ttZW1iZXIubmFtZV0gPSB1dGlsLnVyaUVzY2FwZShtZW1iZXIudG9XaXJlRm9ybWF0KHBhcmFtVmFsdWUpLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHF1ZXJ5U3RyaW5nU2V0KSB7XG4gICAgdXJpICs9ICh1cmkuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHV0aWwuYXJyYXlFYWNoKE9iamVjdC5rZXlzKHF1ZXJ5U3RyaW5nKS5zb3J0KCksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHF1ZXJ5U3RyaW5nW2tleV0pKSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nW2tleV0gPSBbcXVlcnlTdHJpbmdba2V5XV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5U3RyaW5nW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaCh1dGlsLnVyaUVzY2FwZShTdHJpbmcoa2V5KSkgKyAnPScgKyBxdWVyeVN0cmluZ1trZXldW2ldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cmkgKz0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVVUkkocmVxKSB7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIGlucHV0ID0gb3BlcmF0aW9uLmlucHV0O1xuXG4gIHZhciB1cmkgPSBnZW5lcmF0ZVVSSShyZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQucGF0aCwgb3BlcmF0aW9uLmh0dHBQYXRoLCBpbnB1dCwgcmVxLnBhcmFtcyk7XG4gIHJlcS5odHRwUmVxdWVzdC5wYXRoID0gdXJpO1xufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZUhlYWRlcnMocmVxKSB7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdXRpbC5lYWNoKG9wZXJhdGlvbi5pbnB1dC5tZW1iZXJzLCBmdW5jdGlvbiAobmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIHZhbHVlID0gcmVxLnBhcmFtc1tuYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcnMnICYmIG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgdXRpbC5lYWNoKHZhbHVlLCBmdW5jdGlvbihrZXksIG1lbWJlclZhbHVlKSB7XG4gICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzW21lbWJlci5uYW1lICsga2V5XSA9IG1lbWJlclZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgICB2YWx1ZSA9IG1lbWJlci50b1dpcmVGb3JtYXQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICBpZiAobWVtYmVyLmlzSnNvblZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdXRpbC5iYXNlNjQuZW5jb2RlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzW21lbWJlci5uYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgcG9wdWxhdGVNZXRob2QocmVxKTtcbiAgcG9wdWxhdGVVUkkocmVxKTtcbiAgcG9wdWxhdGVIZWFkZXJzKHJlcSk7XG4gIHBvcHVsYXRlSG9zdFByZWZpeChyZXEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IoKSB7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIHIgPSByZXNwLmh0dHBSZXNwb25zZTtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgb3V0cHV0ID0gb3BlcmF0aW9uLm91dHB1dDtcblxuICAvLyBub3JtYWxpemUgaGVhZGVycyBuYW1lcyB0byBsb3dlci1jYXNlZCBrZXlzIGZvciBtYXRjaGluZ1xuICB2YXIgaGVhZGVycyA9IHt9O1xuICB1dGlsLmVhY2goci5oZWFkZXJzLCBmdW5jdGlvbiAoaywgdikge1xuICAgIGhlYWRlcnNbay50b0xvd2VyQ2FzZSgpXSA9IHY7XG4gIH0pO1xuXG4gIHV0aWwuZWFjaChvdXRwdXQubWVtYmVycywgZnVuY3Rpb24obmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIGhlYWRlciA9IChtZW1iZXIubmFtZSB8fCBuYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXJzJyAmJiBtZW1iZXIudHlwZSA9PT0gJ21hcCcpIHtcbiAgICAgIGRhdGFbbmFtZV0gPSB7fTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IG1lbWJlci5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlci5uYW1lIDogJyc7XG4gICAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoJ14nICsgbG9jYXRpb24gKyAnKC4rKScsICdpJyk7XG4gICAgICB1dGlsLmVhY2goci5oZWFkZXJzLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gay5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGRhdGFbbmFtZV1bcmVzdWx0WzFdXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVyJykge1xuICAgICAgaWYgKGhlYWRlcnNbaGVhZGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1lbWJlci5pc0pzb25WYWx1ZSA/XG4gICAgICAgICAgdXRpbC5iYXNlNjQuZGVjb2RlKGhlYWRlcnNbaGVhZGVyXSkgOlxuICAgICAgICAgIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgZGF0YVtuYW1lXSA9IG1lbWJlci50b1R5cGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnc3RhdHVzQ29kZScpIHtcbiAgICAgIGRhdGFbbmFtZV0gPSBwYXJzZUludChyLnN0YXR1c0NvZGUsIDEwKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlc3AuZGF0YSA9IGRhdGE7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YSxcbiAgZ2VuZXJhdGVVUkk6IGdlbmVyYXRlVVJJXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgUmVzdCA9IHJlcXVpcmUoJy4vcmVzdCcpO1xudmFyIEpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcbnZhciBKc29uQnVpbGRlciA9IHJlcXVpcmUoJy4uL2pzb24vYnVpbGRlcicpO1xudmFyIEpzb25QYXJzZXIgPSByZXF1aXJlKCcuLi9qc29uL3BhcnNlcicpO1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUJvZHkocmVxKSB7XG4gIHZhciBidWlsZGVyID0gbmV3IEpzb25CdWlsZGVyKCk7XG4gIHZhciBpbnB1dCA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuXG4gIGlmIChpbnB1dC5wYXlsb2FkKSB7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHZhciBwYXlsb2FkU2hhcGUgPSBpbnB1dC5tZW1iZXJzW2lucHV0LnBheWxvYWRdO1xuICAgIHBhcmFtcyA9IHJlcS5wYXJhbXNbaW5wdXQucGF5bG9hZF07XG5cbiAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIuYnVpbGQocGFyYW1zIHx8IHt9LCBwYXlsb2FkU2hhcGUpO1xuICAgICAgYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5vbi1KU09OIHBheWxvYWRcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gcGFyYW1zO1xuICAgICAgaWYgKHBheWxvYWRTaGFwZS50eXBlID09PSAnYmluYXJ5JyB8fCBwYXlsb2FkU2hhcGUuaXNTdHJlYW1pbmcpIHtcbiAgICAgICAgYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIuYnVpbGQocmVxLnBhcmFtcywgaW5wdXQpO1xuICAgIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSwgaXNCaW5hcnkpIHtcbiAgaWYgKCFyZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pIHtcbiAgICB2YXIgdHlwZSA9IGlzQmluYXJ5ID8gJ2JpbmFyeS9vY3RldC1zdHJlYW0nIDogJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHR5cGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICBSZXN0LmJ1aWxkUmVxdWVzdChyZXEpO1xuXG4gIC8vIG5ldmVyIHNlbmQgYm9keSBwYXlsb2FkIG9uIEdFVC9IRUFEL0RFTEVURVxuICBpZiAoWydHRVQnLCAnSEVBRCcsICdERUxFVEUnXS5pbmRleE9mKHJlcS5odHRwUmVxdWVzdC5tZXRob2QpIDwgMCkge1xuICAgIHBvcHVsYXRlQm9keShyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIEpzb24uZXh0cmFjdEVycm9yKHJlc3ApO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdERhdGEocmVzcCk7XG5cbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5vdXRwdXQgfHwge307XG4gIHZhciBwYXJzZXI7XG4gIHZhciBoYXNFdmVudE91dHB1dCA9IG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dDtcblxuICBpZiAocnVsZXMucGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gcnVsZXMubWVtYmVyc1tydWxlcy5wYXlsb2FkXTtcbiAgICB2YXIgYm9keSA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHk7XG4gICAgaWYgKHBheWxvYWRNZW1iZXIuaXNFdmVudFN0cmVhbSkge1xuICAgICAgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHV0aWwuY3JlYXRlRXZlbnRTdHJlYW0oXG4gICAgICAgIEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyID8gcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtIDogYm9keSxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICBwYXlsb2FkTWVtYmVyXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnc3RydWN0dXJlJyB8fCBwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKCk7XG4gICAgICByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0gPSBwYXJzZXIucGFyc2UoYm9keSwgcGF5bG9hZE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHBheWxvYWRNZW1iZXIudG9UeXBlKGJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0YSA9IHJlc3AuZGF0YTtcbiAgICBKc29uLmV4dHJhY3REYXRhKHJlc3ApO1xuICAgIHJlc3AuZGF0YSA9IHV0aWwubWVyZ2UoZGF0YSwgcmVzcC5kYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgUmVzdCA9IHJlcXVpcmUoJy4vcmVzdCcpO1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUJvZHkocmVxKSB7XG4gIHZhciBpbnB1dCA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICB2YXIgYnVpbGRlciA9IG5ldyBBV1MuWE1MLkJ1aWxkZXIoKTtcbiAgdmFyIHBhcmFtcyA9IHJlcS5wYXJhbXM7XG5cbiAgdmFyIHBheWxvYWQgPSBpbnB1dC5wYXlsb2FkO1xuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gaW5wdXQubWVtYmVyc1twYXlsb2FkXTtcbiAgICBwYXJhbXMgPSBwYXJhbXNbcGF5bG9hZF07XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcGF5bG9hZE1lbWJlci5uYW1lO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLnRvWE1MKHBhcmFtcywgcGF5bG9hZE1lbWJlciwgcm9vdEVsZW1lbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7IC8vIG5vbi14bWwgcGF5bG9hZFxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBwYXJhbXM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci50b1hNTChwYXJhbXMsIGlucHV0LCBpbnB1dC5uYW1lIHx8XG4gICAgICBpbnB1dC5zaGFwZSB8fCB1dGlsLnN0cmluZy51cHBlckZpcnN0KHJlcS5vcGVyYXRpb24pICsgJ1JlcXVlc3QnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIFJlc3QuYnVpbGRSZXF1ZXN0KHJlcSk7XG5cbiAgLy8gbmV2ZXIgc2VuZCBib2R5IHBheWxvYWQgb24gR0VUL0hFQURcbiAgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmRleE9mKHJlcS5odHRwUmVxdWVzdC5tZXRob2QpIDwgMCkge1xuICAgIHBvcHVsYXRlQm9keShyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdEVycm9yKHJlc3ApO1xuXG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKS5wYXJzZShyZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIENvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBNZXNzYWdlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhLkVycm9ycykgZGF0YSA9IGRhdGEuRXJyb3JzO1xuICBpZiAoZGF0YS5FcnJvcikgZGF0YSA9IGRhdGEuRXJyb3I7XG4gIGlmIChkYXRhLkNvZGUpIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogZGF0YS5Db2RlLFxuICAgICAgbWVzc2FnZTogZGF0YS5NZXNzYWdlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBtZXNzYWdlOiBudWxsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICBSZXN0LmV4dHJhY3REYXRhKHJlc3ApO1xuXG4gIHZhciBwYXJzZXI7XG4gIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keTtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgb3V0cHV0ID0gb3BlcmF0aW9uLm91dHB1dDtcblxuICB2YXIgaGFzRXZlbnRPdXRwdXQgPSBvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQ7XG5cbiAgdmFyIHBheWxvYWQgPSBvdXRwdXQucGF5bG9hZDtcbiAgaWYgKHBheWxvYWQpIHtcbiAgICB2YXIgcGF5bG9hZE1lbWJlciA9IG91dHB1dC5tZW1iZXJzW3BheWxvYWRdO1xuICAgIGlmIChwYXlsb2FkTWVtYmVyLmlzRXZlbnRTdHJlYW0pIHtcbiAgICAgIHBhcnNlciA9IG5ldyBBV1MuWE1MLlBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gdXRpbC5jcmVhdGVFdmVudFN0cmVhbShcbiAgICAgICAgQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIgPyByZXNwLmh0dHBSZXNwb25zZS5zdHJlYW0gOiByZXNwLmh0dHBSZXNwb25zZS5ib2R5LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHBheWxvYWRNZW1iZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHBhcnNlci5wYXJzZShib2R5LnRvU3RyaW5nKCksIHBheWxvYWRNZW1iZXIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnYmluYXJ5JyB8fCBwYXlsb2FkTWVtYmVyLmlzU3RyZWFtaW5nKSB7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSBib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSBwYXlsb2FkTWVtYmVyLnRvVHlwZShib2R5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm9keS5sZW5ndGggPiAwKSB7XG4gICAgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG4gICAgdmFyIGRhdGEgPSBwYXJzZXIucGFyc2UoYm9keS50b1N0cmluZygpLCBvdXRwdXQpO1xuICAgIHV0aWwudXBkYXRlKHJlc3AuZGF0YSwgZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhXG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBSZXNvbHZlIGNsaWVudC1zaWRlIG1vbml0b3JpbmcgY29uZmlndXJhdGlvbiBmcm9tIGVpdGhlciBlbnZpcm9ubWVudGFsIHZhcmlhYmxlc1xuICogb3Igc2hhcmVkIGNvbmZpZyBmaWxlLiBDb25maWd1cmF0aW9ucyBmcm9tIGVudmlyb25tZW50YWwgdmFyaWFibGVzIGhhdmUgaGlnaGVyIHByaW9yaXR5XG4gKiB0aGFuIHRob3NlIGZyb20gc2hhcmVkIGNvbmZpZyBmaWxlLiBUaGUgcmVzb2x2ZXIgd2lsbCB0cnkgdG8gcmVhZCB0aGUgc2hhcmVkIGNvbmZpZyBmaWxlXG4gKiBubyBtYXR0ZXIgd2hldGhlciB0aGUgQVdTX1NES19MT0FEX0NPTkZJRyB2YXJpYWJsZSBpcyBzZXQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU1vbml0b3JpbmdDb25maWcoKSB7XG4gIHZhciBjb25maWcgPSB7XG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIGNsaWVudElkOiB1bmRlZmluZWQsXG4gICAgZW5hYmxlZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZFxuICB9O1xuICBpZiAoZnJvbUVudmlyb25tZW50KGNvbmZpZykgfHwgZnJvbUNvbmZpZ0ZpbGUoY29uZmlnKSkgcmV0dXJuIHRvSlNUeXBlKGNvbmZpZyk7XG4gIHJldHVybiB0b0pTVHlwZShjb25maWcpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgY29uZmlndXJhdGlvbnMgZnJvbSBlbnZpcm9ubWVudGFsIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGllbnQgc2lkZSBtb25pdG9yaW5nIGNvbmZpZyBvYmplY3QgbmVlZHMgdG8gYmUgcmVzb2x2ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHJlc29sdmluZyBjb25maWd1cmF0aW9ucyBpcyBkb25lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZnJvbUVudmlyb25tZW50KGNvbmZpZykge1xuICBjb25maWcucG9ydCA9IGNvbmZpZy5wb3J0IHx8IHByb2Nlc3MuZW52LkFXU19DU01fUE9SVDtcbiAgY29uZmlnLmVuYWJsZWQgPSBjb25maWcuZW5hYmxlZCB8fCBwcm9jZXNzLmVudi5BV1NfQ1NNX0VOQUJMRUQ7XG4gIGNvbmZpZy5jbGllbnRJZCA9IGNvbmZpZy5jbGllbnRJZCB8fCBwcm9jZXNzLmVudi5BV1NfQ1NNX0NMSUVOVF9JRDtcbiAgY29uZmlnLmhvc3QgPSBjb25maWcuaG9zdCB8fCBwcm9jZXNzLmVudi5BV1NfQ1NNX0hPU1Q7XG4gIHJldHVybiBjb25maWcucG9ydCAmJiBjb25maWcuZW5hYmxlZCAmJiBjb25maWcuY2xpZW50SWQgJiYgY29uZmlnLmhvc3QgfHxcbiAgICBbJ2ZhbHNlJywgJzAnXS5pbmRleE9mKGNvbmZpZy5lbmFibGVkKSA+PSAwOyAvL25vIG5lZWQgdG8gcmVhZCBzaGFyZWQgY29uZmlnIGZpbGUgaWYgZXhwbGljaXRlbHkgZGlzYWJsZWRcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGNvZmlndXJhdGlvbnMgZnJvbSBzaGFyZWQgY29uZmlnIGZpbGUgd2l0aCBzcGVjaWZpZWQgcm9sZSBuYW1lXG4gKiBAcGFyYW0ge29iamVjdH0gY2xpZW50IHNpZGUgbW9uaXRvcmluZyBjb25maWcgb2JqZWN0IG5lZWRzIHRvIGJlIHJlc29sdmVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciByZXNvbHZpbmcgY29uZmlndXJhdGlvbnMgaXMgZG9uZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZyb21Db25maWdGaWxlKGNvbmZpZykge1xuICB2YXIgc2hhcmVkRmlsZUNvbmZpZztcbiAgdHJ5IHtcbiAgICB2YXIgY29uZmlnRmlsZSA9IEFXUy51dGlsLmluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICBpc0NvbmZpZzogdHJ1ZSxcbiAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudltBV1MudXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgIH0pO1xuICAgIHZhciBzaGFyZWRGaWxlQ29uZmlnID0gY29uZmlnRmlsZVtcbiAgICAgIHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlXG4gICAgXTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghc2hhcmVkRmlsZUNvbmZpZykgcmV0dXJuIGNvbmZpZztcbiAgY29uZmlnLnBvcnQgPSBjb25maWcucG9ydCB8fCBzaGFyZWRGaWxlQ29uZmlnLmNzbV9wb3J0O1xuICBjb25maWcuZW5hYmxlZCA9IGNvbmZpZy5lbmFibGVkIHx8IHNoYXJlZEZpbGVDb25maWcuY3NtX2VuYWJsZWQ7XG4gIGNvbmZpZy5jbGllbnRJZCA9IGNvbmZpZy5jbGllbnRJZCB8fCBzaGFyZWRGaWxlQ29uZmlnLmNzbV9jbGllbnRfaWQ7XG4gIGNvbmZpZy5ob3N0ID0gY29uZmlnLmhvc3QgfHwgc2hhcmVkRmlsZUNvbmZpZy5jc21faG9zdDtcbiAgcmV0dXJuIGNvbmZpZy5wb3J0ICYmIGNvbmZpZy5lbmFibGVkICYmIGNvbmZpZy5jbGllbnRJZCAmJiBjb25maWcuaG9zdDtcbn1cblxuLyoqXG4gKiBUcmFuc2ZlciB0aGUgcmVzb2x2ZWQgY29uZmlndXJhdGlvbiB2YWx1ZSB0byBwcm9wZXIgdHlwZXM6IHBvcnQgYXMgbnVtYmVyLCBlbmFibGVkXG4gKiBhcyBib29sZWFuIGFuZCBjbGllbnRJZCBhcyBzdHJpbmcuIFRoZSAnZW5hYmxlZCcgZmxhZyBpcyB2YWx1ZWQgdG8gZmFsc2Ugd2hlbiBzZXRcbiAqIHRvICdmYWxzZScgb3IgJzAnLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc29sdmVkIGNsaWVudCBzaWRlIG1vbml0b3JpbmcgY29uZmlnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9KU1R5cGUoY29uZmlnKSB7XG4gICAgLy9jb25maWcuWFhYIGlzIGVpdGhlciB1bmRlZmluZWQgb3Igc3RyaW5nXG4gIHZhciBmYWxzeU5vdGF0aW9ucyA9IFsnZmFsc2UnLCAnMCcsIHVuZGVmaW5lZF07XG4gIGlmICghY29uZmlnLmVuYWJsZWQgfHwgZmFsc3lOb3RhdGlvbnMuaW5kZXhPZihjb25maWcuZW5hYmxlZC50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgY29uZmlnLmVuYWJsZWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgY29uZmlnLnBvcnQgPSBjb25maWcucG9ydCA/IHBhcnNlSW50KGNvbmZpZy5wb3J0LCAxMCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb25maWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZU1vbml0b3JpbmdDb25maWc7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIGRncmFtID0gcmVxdWlyZSgnZGdyYW0nKTtcbnZhciBzdHJpbmdUb0J1ZmZlciA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyO1xuXG52YXIgTUFYX01FU1NBR0VfU0laRSA9IDEwMjQgKiA4OyAvLyA4IEtCXG5cbi8qKlxuICogUHVibGlzaGVzIG1ldHJpY3MgdmlhIHVkcC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFBhcmFtdGVycyBmb3IgUHVibGlzaGVyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucG9ydCA9IDMxMDAwXSBQb3J0IG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsaWVudElkID0gJyddIENsaWVudCBJZGVudGlmaWVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZWQgPSBmYWxzZV0gZW5hYmxlIHNlbmRpbmcgbWV0cmljcyBkYXRhZ3JhbVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFB1Ymxpc2hlcihvcHRpb25zKSB7XG4gICAgLy8gaGFuZGxlIGNvbmZpZ3VyYXRpb25cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQgfHwgZmFsc2U7XG4gICAgdGhpcy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IDMxMDAwO1xuICAgIHRoaXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkIHx8ICcnO1xuICAgIHRoaXMuYWRkcmVzcyA9IG9wdGlvbnMuaG9zdCB8fCAnMTI3LjAuMC4xJztcbiAgICBpZiAodGhpcy5jbGllbnRJZC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgLy8gQ2xpZW50SWQgaGFzIGEgbWF4IGxlbmd0aCBvZiAyNTVcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IHRoaXMuY2xpZW50SWQuc3Vic3RyKDAsIDI1NSk7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZXNJbkZsaWdodCA9IDA7XG59XG5cblB1Ymxpc2hlci5wcm90b3R5cGUuZmllbGRzVG9UcmltID0ge1xuICAgIFVzZXJBZ2VudDogMjU2LFxuICAgIFNka0V4Y2VwdGlvbjogMTI4LFxuICAgIFNka0V4Y2VwdGlvbk1lc3NhZ2U6IDUxMixcbiAgICBBd3NFeGNlcHRpb246IDEyOCxcbiAgICBBd3NFeGNlcHRpb25NZXNzYWdlOiA1MTIsXG4gICAgRmluYWxTZGtFeGNlcHRpb246IDEyOCxcbiAgICBGaW5hbFNka0V4Y2VwdGlvbk1lc3NhZ2U6IDUxMixcbiAgICBGaW5hbEF3c0V4Y2VwdGlvbjogMTI4LFxuICAgIEZpbmFsQXdzRXhjZXB0aW9uTWVzc2FnZTogNTEyXG5cbn07XG5cbi8qKlxuICogVHJpbXMgZmllbGRzIHRoYXQgaGF2ZSBhIHNwZWNpZmllZCBtYXggbGVuZ3RoLlxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEFwaUNhbGwgb3IgQXBpQ2FsbEF0dGVtcHQgZXZlbnQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblB1Ymxpc2hlci5wcm90b3R5cGUudHJpbUZpZWxkcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHRyaW1tYWJsZUZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRzVG9UcmltKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IHRyaW1tYWJsZUZpZWxkcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdHJpbW1hYmxlRmllbGRzW2ldO1xuICAgICAgICBpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gdGhpcy5maWVsZHNUb1RyaW1bZmllbGRdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZlbnRbZmllbGRdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlLnN1YnN0cigwLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBBcGlDYWxsIGFuZCBBcGlDYWxsQXR0ZW1wdCBldmVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgYXBpQ2FsbCBvciBhcGlDYWxsQXR0ZW1wdCBldmVudC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5QdWJsaXNoZXIucHJvdG90eXBlLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gc2V0IHRoZSBjbGllbnRJZFxuICAgIGV2ZW50LkNsaWVudElkID0gdGhpcy5jbGllbnRJZDtcblxuICAgIHRoaXMudHJpbUZpZWxkcyhldmVudCk7XG5cbiAgICB2YXIgbWVzc2FnZSA9IHN0cmluZ1RvQnVmZmVyKEpTT04uc3RyaW5naWZ5KGV2ZW50KSk7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgbWVzc2FnZS5sZW5ndGggPiBNQVhfTUVTU0FHRV9TSVpFKSB7XG4gICAgICAgIC8vIGRyb3AgdGhlIG1lc3NhZ2UgaWYgcHVibGlzaGVyIG5vdCBlbmFibGVkIG9yIGl0IGlzIHRvbyBsYXJnZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wdWJsaXNoRGF0YWdyYW0obWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIFB1Ymxpc2hlcyBtZXNzYWdlIHRvIGFuIGFnZW50LlxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2UgSlNPTiBtZXNzYWdlIHRvIHNlbmQgdG8gYWdlbnQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUHVibGlzaGVyLnByb3RvdHlwZS5wdWJsaXNoRGF0YWdyYW0gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuXG4gICAgdGhpcy5tZXNzYWdlc0luRmxpZ2h0Kys7XG4gICAgdGhpcy5jbGllbnQuc2VuZChtZXNzYWdlLCAwLCBtZXNzYWdlLmxlbmd0aCwgdGhpcy5wb3J0LCB0aGlzLmFkZHJlc3MsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKC0tc2VsZi5tZXNzYWdlc0luRmxpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgZXhpc3RpbmcgY2xpZW50IHNvIHRoZSBldmVudCBsb29wIGlzbid0IGtlcHQgb3BlblxuICAgICAgICAgICAgc2VsZi5kZXN0cm95Q2xpZW50KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBleGlzdGluZyB1ZHAgc29ja2V0LCBvciBjcmVhdGVzIG9uZSBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUHVibGlzaGVyLnByb3RvdHlwZS5nZXRDbGllbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gZGdyYW0uY3JlYXRlU29ja2V0KCd1ZHA0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsaWVudDtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHVkcCBzb2NrZXQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUHVibGlzaGVyLnByb3RvdHlwZS5kZXN0cm95Q2xpZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gdm9pZCAwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFB1Ymxpc2hlcjogUHVibGlzaGVyXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIFF1ZXJ5UGFyYW1TZXJpYWxpemVyKCkge1xufVxuXG5RdWVyeVBhcmFtU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24ocGFyYW1zLCBzaGFwZSwgZm4pIHtcbiAgc2VyaWFsaXplU3RydWN0dXJlKCcnLCBwYXJhbXMsIHNoYXBlLCBmbik7XG59O1xuXG5mdW5jdGlvbiB1Y2ZpcnN0KHNoYXBlKSB7XG4gIGlmIChzaGFwZS5pc1F1ZXJ5TmFtZSB8fCBzaGFwZS5hcGkucHJvdG9jb2wgIT09ICdlYzInKSB7XG4gICAgcmV0dXJuIHNoYXBlLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNoYXBlLm5hbWVbMF0udG9VcHBlckNhc2UoKSArIHNoYXBlLm5hbWUuc3Vic3RyKDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdHVyZShwcmVmaXgsIHN0cnVjdCwgcnVsZXMsIGZuKSB7XG4gIHV0aWwuZWFjaChydWxlcy5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHJ1Y3RbbmFtZV07XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHZhciBtZW1iZXJOYW1lID0gdWNmaXJzdChtZW1iZXIpO1xuICAgIG1lbWJlck5hbWUgPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBtZW1iZXJOYW1lIDogbWVtYmVyTmFtZTtcbiAgICBzZXJpYWxpemVNZW1iZXIobWVtYmVyTmFtZSwgdmFsdWUsIG1lbWJlciwgZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWFwKG5hbWUsIG1hcCwgcnVsZXMsIGZuKSB7XG4gIHZhciBpID0gMTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcHJlZml4ID0gcnVsZXMuZmxhdHRlbmVkID8gJy4nIDogJy5lbnRyeS4nO1xuICAgIHZhciBwb3NpdGlvbiA9IHByZWZpeCArIChpKyspICsgJy4nO1xuICAgIHZhciBrZXlOYW1lID0gcG9zaXRpb24gKyAocnVsZXMua2V5Lm5hbWUgfHwgJ2tleScpO1xuICAgIHZhciB2YWx1ZU5hbWUgPSBwb3NpdGlvbiArIChydWxlcy52YWx1ZS5uYW1lIHx8ICd2YWx1ZScpO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsga2V5TmFtZSwga2V5LCBydWxlcy5rZXksIGZuKTtcbiAgICBzZXJpYWxpemVNZW1iZXIobmFtZSArIHZhbHVlTmFtZSwgdmFsdWUsIHJ1bGVzLnZhbHVlLCBmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KG5hbWUsIGxpc3QsIHJ1bGVzLCBmbikge1xuICB2YXIgbWVtYmVyUnVsZXMgPSBydWxlcy5tZW1iZXIgfHwge307XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgZm4uY2FsbCh0aGlzLCBuYW1lLCBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbiAodiwgbikge1xuICAgIHZhciBzdWZmaXggPSAnLicgKyAobiArIDEpO1xuICAgIGlmIChydWxlcy5hcGkucHJvdG9jb2wgPT09ICdlYzInKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGZvciBFQzJcbiAgICAgIHN1ZmZpeCA9IHN1ZmZpeCArICcnOyAvLyBtYWtlIGxpbnRlciBoYXBweVxuICAgIH0gZWxzZSBpZiAocnVsZXMuZmxhdHRlbmVkKSB7XG4gICAgICBpZiAobWVtYmVyUnVsZXMubmFtZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBwYXJ0cy5wdXNoKHVjZmlyc3QobWVtYmVyUnVsZXMpKTtcbiAgICAgICAgbmFtZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VmZml4ID0gJy4nICsgKG1lbWJlclJ1bGVzLm5hbWUgPyBtZW1iZXJSdWxlcy5uYW1lIDogJ21lbWJlcicpICsgc3VmZml4O1xuICAgIH1cbiAgICBzZXJpYWxpemVNZW1iZXIobmFtZSArIHN1ZmZpeCwgdiwgbWVtYmVyUnVsZXMsIGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1lbWJlcihuYW1lLCB2YWx1ZSwgcnVsZXMsIGZuKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChydWxlcy50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgIHNlcmlhbGl6ZVN0cnVjdHVyZShuYW1lLCB2YWx1ZSwgcnVsZXMsIGZuKTtcbiAgfSBlbHNlIGlmIChydWxlcy50eXBlID09PSAnbGlzdCcpIHtcbiAgICBzZXJpYWxpemVMaXN0KG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgc2VyaWFsaXplTWFwKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2Uge1xuICAgIGZuKG5hbWUsIHJ1bGVzLnRvV2lyZUZvcm1hdCh2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeVBhcmFtU2VyaWFsaXplcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAvL3Byb3ZpZGUgcmVhbHRpbWUgY2xvY2sgZm9yIHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50XG4gIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgIHZhciBzZWNvbmQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgIHJldHVybiBzZWNvbmRbMF0gKiAxMDAwICsgKHNlY29uZFsxXSAvIDEwMDAwMDApO1xuICB9XG59O1xuIiwiZnVuY3Rpb24gaXNGaXBzUmVnaW9uKHJlZ2lvbikge1xuICByZXR1cm4gdHlwZW9mIHJlZ2lvbiA9PT0gJ3N0cmluZycgJiYgKHJlZ2lvbi5zdGFydHNXaXRoKCdmaXBzLScpIHx8IHJlZ2lvbi5lbmRzV2l0aCgnLWZpcHMnKSk7XG59XG5cbmZ1bmN0aW9uIGlzR2xvYmFsUmVnaW9uKHJlZ2lvbikge1xuICByZXR1cm4gdHlwZW9mIHJlZ2lvbiA9PT0gJ3N0cmluZycgJiYgWydhd3MtZ2xvYmFsJywgJ2F3cy11cy1nb3YtZ2xvYmFsJ10uaW5jbHVkZXMocmVnaW9uKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhbFJlZ2lvbihyZWdpb24pIHtcbiAgcmV0dXJuIFsnZmlwcy1hd3MtZ2xvYmFsJywgJ2F3cy1maXBzJywgJ2F3cy1nbG9iYWwnXS5pbmNsdWRlcyhyZWdpb24pXG4gICAgICA/ICd1cy1lYXN0LTEnXG4gICAgICA6IFsnZmlwcy1hd3MtdXMtZ292LWdsb2JhbCcsICdhd3MtdXMtZ292LWdsb2JhbCddLmluY2x1ZGVzKHJlZ2lvbilcbiAgICAgID8gJ3VzLWdvdi13ZXN0LTEnXG4gICAgICA6IHJlZ2lvbi5yZXBsYWNlKC9maXBzLShka3ItfHByb2QtKT98LWZpcHMvLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0ZpcHNSZWdpb246IGlzRmlwc1JlZ2lvbixcbiAgaXNHbG9iYWxSZWdpb246IGlzR2xvYmFsUmVnaW9uLFxuICBnZXRSZWFsUmVnaW9uOiBnZXRSZWFsUmVnaW9uXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciByZWdpb25Db25maWcgPSByZXF1aXJlKCcuL3JlZ2lvbl9jb25maWdfZGF0YS5qc29uJyk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUmVnaW9uUHJlZml4KHJlZ2lvbikge1xuICBpZiAoIXJlZ2lvbikgcmV0dXJuIG51bGw7XG4gIHZhciBwYXJ0cyA9IHJlZ2lvbi5zcGxpdCgnLScpO1xuICBpZiAocGFydHMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBwYXJ0cy5zbGljZSgwLCBwYXJ0cy5sZW5ndGggLSAyKS5qb2luKCctJykgKyAnLSonO1xufVxuXG5mdW5jdGlvbiBkZXJpdmVkS2V5cyhzZXJ2aWNlKSB7XG4gIHZhciByZWdpb24gPSBzZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gIHZhciByZWdpb25QcmVmaXggPSBnZW5lcmF0ZVJlZ2lvblByZWZpeChyZWdpb24pO1xuICB2YXIgZW5kcG9pbnRQcmVmaXggPSBzZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeDtcblxuICByZXR1cm4gW1xuICAgIFtyZWdpb24sIGVuZHBvaW50UHJlZml4XSxcbiAgICBbcmVnaW9uUHJlZml4LCBlbmRwb2ludFByZWZpeF0sXG4gICAgW3JlZ2lvbiwgJyonXSxcbiAgICBbcmVnaW9uUHJlZml4LCAnKiddLFxuICAgIFsnKicsIGVuZHBvaW50UHJlZml4XSxcbiAgICBbJyonLCAnKiddXG4gIF0ubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVswXSAmJiBpdGVtWzFdID8gaXRlbS5qb2luKCcvJykgOiBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlDb25maWcoc2VydmljZSwgY29uZmlnKSB7XG4gIHV0aWwuZWFjaChjb25maWcsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAnZ2xvYmFsRW5kcG9pbnQnKSByZXR1cm47XG4gICAgaWYgKHNlcnZpY2UuY29uZmlnW2tleV0gPT09IHVuZGVmaW5lZCB8fCBzZXJ2aWNlLmNvbmZpZ1trZXldID09PSBudWxsKSB7XG4gICAgICBzZXJ2aWNlLmNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlRW5kcG9pbnQoc2VydmljZSkge1xuICB2YXIga2V5cyA9IGRlcml2ZWRLZXlzKHNlcnZpY2UpO1xuICB2YXIgdXNlRmlwc0VuZHBvaW50ID0gc2VydmljZS5jb25maWcudXNlRmlwc0VuZHBvaW50O1xuICB2YXIgdXNlRHVhbHN0YWNrRW5kcG9pbnQgPSBzZXJ2aWNlLmNvbmZpZy51c2VEdWFsc3RhY2tFbmRwb2ludDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFrZXkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJ1bGVzID0gdXNlRmlwc0VuZHBvaW50XG4gICAgICA/IHVzZUR1YWxzdGFja0VuZHBvaW50XG4gICAgICAgID8gcmVnaW9uQ29uZmlnLmR1YWxzdGFja0ZpcHNSdWxlc1xuICAgICAgICA6IHJlZ2lvbkNvbmZpZy5maXBzUnVsZXNcbiAgICAgIDogdXNlRHVhbHN0YWNrRW5kcG9pbnRcbiAgICAgID8gcmVnaW9uQ29uZmlnLmR1YWxzdGFja1J1bGVzXG4gICAgICA6IHJlZ2lvbkNvbmZpZy5ydWxlcztcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocnVsZXMsIGtleSkpIHtcbiAgICAgIHZhciBjb25maWcgPSBydWxlc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZyA9IHJlZ2lvbkNvbmZpZy5wYXR0ZXJuc1tjb25maWddO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgZ2xvYmFsIGVuZHBvaW50XG4gICAgICBzZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnQgPSAhIWNvbmZpZy5nbG9iYWxFbmRwb2ludDtcbiAgICAgIGlmIChjb25maWcuc2lnbmluZ1JlZ2lvbikge1xuICAgICAgICBzZXJ2aWNlLnNpZ25pbmdSZWdpb24gPSBjb25maWcuc2lnbmluZ1JlZ2lvbjtcbiAgICAgIH1cblxuICAgICAgLy8gc2lnbmF0dXJlIHZlcnNpb25cbiAgICAgIGlmICghY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIGNvbmZpZy5zaWduYXR1cmVWZXJzaW9uID0gJ3Y0JztcblxuICAgICAgLy8gbWVyZ2UgY29uZmlnXG4gICAgICBhcHBseUNvbmZpZyhzZXJ2aWNlLCBjb25maWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbmRwb2ludFN1ZmZpeChyZWdpb24pIHtcbiAgdmFyIHJlZ2lvblJlZ2V4ZXMgPSB7XG4gICAgJ14odXN8ZXV8YXB8c2F8Y2F8bWUpXFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnYW1hem9uYXdzLmNvbScsXG4gICAgJ15jblxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2FtYXpvbmF3cy5jb20uY24nLFxuICAgICdedXNcXFxcLWdvdlxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2FtYXpvbmF3cy5jb20nLFxuICAgICdedXNcXFxcLWlzb1xcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2Mycy5pYy5nb3YnLFxuICAgICdedXNcXFxcLWlzb2JcXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdzYzJzLnNnb3YuZ292J1xuICB9O1xuICB2YXIgZGVmYXVsdFN1ZmZpeCA9ICdhbWF6b25hd3MuY29tJztcbiAgdmFyIHJlZ2V4ZXMgPSBPYmplY3Qua2V5cyhyZWdpb25SZWdleGVzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlZ2lvblBhdHRlcm4gPSBSZWdFeHAocmVnZXhlc1tpXSk7XG4gICAgdmFyIGRuc1N1ZmZpeCA9IHJlZ2lvblJlZ2V4ZXNbcmVnZXhlc1tpXV07XG4gICAgaWYgKHJlZ2lvblBhdHRlcm4udGVzdChyZWdpb24pKSByZXR1cm4gZG5zU3VmZml4O1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3VmZml4O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uZmlndXJlRW5kcG9pbnQ6IGNvbmZpZ3VyZUVuZHBvaW50LFxuICBnZXRFbmRwb2ludFN1ZmZpeDogZ2V0RW5kcG9pbnRTdWZmaXgsXG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIEFjY2VwdG9yU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi9zdGF0ZV9tYWNoaW5lJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgZG9tYWluID0gQVdTLnV0aWwuZG9tYWluO1xudmFyIGptZXNwYXRoID0gcmVxdWlyZSgnam1lc3BhdGgnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGhhcmRFcnJvclN0YXRlcyA9IHtzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDF9O1xuXG5mdW5jdGlvbiBpc1Rlcm1pbmFsU3RhdGUobWFjaGluZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhcmRFcnJvclN0YXRlcywgbWFjaGluZS5fYXNtLmN1cnJlbnRTdGF0ZSk7XG59XG5cbnZhciBmc20gPSBuZXcgQWNjZXB0b3JTdGF0ZU1hY2hpbmUoKTtcbmZzbS5zZXR1cFN0YXRlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhbnNpdGlvbiA9IGZ1bmN0aW9uKF8sIGRvbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvciA9IGZhbHNlO1xuXG4gICAgc2VsZi5lbWl0KHNlbGYuX2FzbS5jdXJyZW50U3RhdGUsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoaXNUZXJtaW5hbFN0YXRlKHNlbGYpKSB7XG4gICAgICAgICAgaWYgKGRvbWFpbiAmJiBzZWxmLmRvbWFpbiBpbnN0YW5jZW9mIGRvbWFpbi5Eb21haW4pIHtcbiAgICAgICAgICAgIGVyci5kb21haW5FbWl0dGVyID0gc2VsZjtcbiAgICAgICAgICAgIGVyci5kb21haW4gPSBzZWxmLmRvbWFpbjtcbiAgICAgICAgICAgIGVyci5kb21haW5UaHJvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuZG9tYWluLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZShzZWxmLnJlc3BvbnNlLmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIHRoaXMuYWRkU3RhdGUoJ3ZhbGlkYXRlJywgJ2J1aWxkJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2J1aWxkJywgJ2FmdGVyQnVpbGQnLCAncmVzdGFydCcsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdhZnRlckJ1aWxkJywgJ3NpZ24nLCAncmVzdGFydCcsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzaWduJywgJ3NlbmQnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgncmV0cnknLCAnYWZ0ZXJSZXRyeScsICdhZnRlclJldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2FmdGVyUmV0cnknLCAnc2lnbicsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzZW5kJywgJ3ZhbGlkYXRlUmVzcG9uc2UnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgndmFsaWRhdGVSZXNwb25zZScsICdleHRyYWN0RGF0YScsICdleHRyYWN0RXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXh0cmFjdEVycm9yJywgJ2V4dHJhY3REYXRhJywgJ3JldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2V4dHJhY3REYXRhJywgJ3N1Y2Nlc3MnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgncmVzdGFydCcsICdidWlsZCcsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzdWNjZXNzJywgJ2NvbXBsZXRlJywgJ2NvbXBsZXRlJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2Vycm9yJywgJ2NvbXBsZXRlJywgJ2NvbXBsZXRlJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2NvbXBsZXRlJywgbnVsbCwgbnVsbCwgdHJhbnNpdGlvbik7XG59O1xuZnNtLnNldHVwU3RhdGVzKCk7XG5cbi8qKlxuICogIyMgQXN5bmNocm9ub3VzIFJlcXVlc3RzXG4gKlxuICogQWxsIHJlcXVlc3RzIG1hZGUgdGhyb3VnaCB0aGUgU0RLIGFyZSBhc3luY2hyb25vdXMgYW5kIHVzZSBhXG4gKiBjYWxsYmFjayBpbnRlcmZhY2UuIEVhY2ggc2VydmljZSBtZXRob2QgdGhhdCBraWNrcyBvZmYgYSByZXF1ZXN0XG4gKiByZXR1cm5zIGFuIGBBV1MuUmVxdWVzdGAgb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgdG8gcmVnaXN0ZXJcbiAqIGNhbGxiYWNrcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBzZXJ2aWNlIG1ldGhvZCByZXR1cm5zIHRoZSByZXF1ZXN0XG4gKiBvYmplY3QgYXMgXCJyZXF1ZXN0XCIsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGNhbGxiYWNrczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyByZXF1ZXN0IGlzIGFuIEFXUy5SZXF1ZXN0IG9iamVjdFxuICogdmFyIHJlcXVlc3QgPSBlYzIuZGVzY3JpYmVJbnN0YW5jZXMoKTtcbiAqXG4gKiAvLyByZWdpc3RlciBjYWxsYmFja3Mgb24gcmVxdWVzdCB0byByZXRyaWV2ZSByZXNwb25zZSBkYXRhXG4gKiByZXF1ZXN0Lm9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgY29uc29sZS5sb2cocmVzcG9uc2UuZGF0YSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFdoZW4gYSByZXF1ZXN0IGlzIHJlYWR5IHRvIGJlIHNlbnQsIHRoZSB7c2VuZH0gbWV0aG9kIHNob3VsZFxuICogYmUgY2FsbGVkOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHJlcXVlc3Quc2VuZCgpO1xuICogYGBgXG4gKlxuICogU2luY2UgcmVnaXN0ZXJlZCBjYWxsYmFja3MgbWF5IG9yIG1heSBub3QgYmUgaWRlbXBvdGVudCwgcmVxdWVzdHMgc2hvdWxkIG9ubHlcbiAqIGJlIHNlbnQgb25jZS4gVG8gcGVyZm9ybSB0aGUgc2FtZSBvcGVyYXRpb24gbXVsdGlwbGUgdGltZXMsIHlvdSB3aWxsIG5lZWQgdG9cbiAqIGNyZWF0ZSBtdWx0aXBsZSByZXF1ZXN0IG9iamVjdHMsIGVhY2ggd2l0aCBpdHMgb3duIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqICMjIFJlbW92aW5nIERlZmF1bHQgTGlzdGVuZXJzIGZvciBFdmVudHNcbiAqXG4gKiBSZXF1ZXN0IG9iamVjdHMgYXJlIGJ1aWx0IHdpdGggZGVmYXVsdCBsaXN0ZW5lcnMgZm9yIHRoZSB2YXJpb3VzIGV2ZW50cyxcbiAqIGRlcGVuZGluZyBvbiB0aGUgc2VydmljZSB0eXBlLiBJbiBzb21lIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gcmVtb3ZlXG4gKiBzb21lIGJ1aWx0LWluIGxpc3RlbmVycyB0byBjdXN0b21pemUgYmVoYXZpb3VyLiBEb2luZyB0aGlzIHJlcXVpcmVzXG4gKiBhY2Nlc3MgdG8gdGhlIGJ1aWx0LWluIGxpc3RlbmVyIGZ1bmN0aW9ucywgd2hpY2ggYXJlIGV4cG9zZWQgdGhyb3VnaFxuICogdGhlIHtBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZX0gbmFtZXNwYWNlLiBGb3IgaW5zdGFuY2UsIHlvdSBtYXlcbiAqIHdhbnQgdG8gY3VzdG9taXplIHRoZSBIVFRQIGhhbmRsZXIgdXNlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0LiBJbiB0aGlzXG4gKiBjYXNlLCB5b3UgY2FuIHJlbW92ZSB0aGUgYnVpbHQtaW4gbGlzdGVuZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSAnc2VuZCdcbiAqIGV2ZW50LCB0aGUge0FXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkR9IGxpc3RlbmVyIGFuZCBhZGQgeW91ciBvd24uXG4gKlxuICogIyMgTXVsdGlwbGUgQ2FsbGJhY2tzIGFuZCBDaGFpbmluZ1xuICpcbiAqIFlvdSBjYW4gcmVnaXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2tzIG9uIGFueSByZXF1ZXN0IG9iamVjdC4gVGhlXG4gKiBjYWxsYmFja3MgY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIGRpZmZlcmVudCBldmVudHMsIG9yIGFsbCBmb3IgdGhlXG4gKiBzYW1lIGV2ZW50LiBJbiBhZGRpdGlvbiwgeW91IGNhbiBjaGFpbiBjYWxsYmFjayByZWdpc3RyYXRpb24sIGZvclxuICogZXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiByZXF1ZXN0LlxuICogICBvbignc3VjY2VzcycsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJTdWNjZXNzIVwiKTtcbiAqICAgfSkuXG4gKiAgIG9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSkge1xuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IhXCIpO1xuICogICB9KS5cbiAqICAgb24oJ2NvbXBsZXRlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkFsd2F5cyFcIik7XG4gKiAgIH0pLlxuICogICBzZW5kKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYWJvdmUgZXhhbXBsZSB3aWxsIHByaW50IGVpdGhlciBcIlN1Y2Nlc3MhIEFsd2F5cyFcIiwgb3IgXCJFcnJvciEgQWx3YXlzIVwiLFxuICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkIG9yIG5vdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBodHRwUmVxdWVzdFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBIVFRQIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbQVdTLkh0dHBSZXF1ZXN0XSB0aGUgcmF3IEhUVFAgcmVxdWVzdCBvYmplY3RcbiAqICAgICBjb250YWluaW5nIHJlcXVlc3QgaGVhZGVycyBhbmQgYm9keSBpbmZvcm1hdGlvblxuICogICAgIHNlbnQgYnkgdGhlIHNlcnZpY2UuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3RhcnRUaW1lXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIE9wZXJhdGlvbiBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0RhdGVdIHRoZSB0aW1lIHRoYXQgdGhlIHJlcXVlc3Qgc3RhcnRlZFxuICpcbiAqIEAhZ3JvdXAgUmVxdWVzdCBCdWlsZGluZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IHZhbGlkYXRlKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGEgcmVxdWVzdCBpcyBiZWluZyB2YWxpZGF0ZWQuIExpc3RlbmVyc1xuICogICBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIG5vdCBiZSBzZW50LlxuICogICBAcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGJlaW5nIHNlbnRcbiAqICAgQHNlZSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9DUkVERU5USUFMU1xuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1JFR0lPTlxuICogICBAZXhhbXBsZSBFbnN1cmluZyB0aGF0IGEgY2VydGFpbiBwYXJhbWV0ZXIgaXMgc2V0IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdFxuICogICAgIHZhciByZXEgPSBzMy5wdXRPYmplY3QocGFyYW1zKTtcbiAqICAgICByZXEub24oJ3ZhbGlkYXRlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICBpZiAoIXJlcS5wYXJhbXMuQm9keS5tYXRjaCgvXkhlbGxvXFxzLykpIHtcbiAqICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2R5IG11c3Qgc3RhcnQgd2l0aCBcIkhlbGxvIFwiJyk7XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgcmVxLnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IC4uLiB9KTtcbiAqXG4gKiBAIWV2ZW50IGJ1aWxkKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IHBheWxvYWQgaXMgYmVpbmcgYnVpbHQuIExpc3RlbmVyc1xuICogICBzaG91bGQgZmlsbCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIHNlbmQgdGhlIHJlcXVlc3RcbiAqICAgb3ZlciBIVFRQLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH52YWxpZGF0ZSlcbiAqICAgQGV4YW1wbGUgQWRkIGEgY3VzdG9tIEhUVFAgaGVhZGVyIHRvIGEgcmVxdWVzdFxuICogICAgIHZhciByZXEgPSBzMy5wdXRPYmplY3QocGFyYW1zKTtcbiAqICAgICByZXEub24oJ2J1aWxkJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ3VzdG9tLUhlYWRlciddID0gJ3ZhbHVlJztcbiAqICAgICB9KTtcbiAqICAgICByZXEuc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICpcbiAqIEAhZXZlbnQgc2lnbihyZXF1ZXN0KVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBiZWluZyBzaWduZWQuIExpc3RlbmVycyBzaG91bGRcbiAqICAgYWRkIHRoZSBjb3JyZWN0IGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgYW5kL29yIGFkanVzdCB0aGUgYm9keSxcbiAqICAgZGVwZW5kaW5nIG9uIHRoZSBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gYmVpbmcgdXNlZC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+dmFsaWRhdGUpXG4gKlxuICogQCFncm91cCBSZXF1ZXN0IFNlbmRpbmcgRXZlbnRzXG4gKlxuICogQCFldmVudCBzZW5kKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyByZWFkeSB0byBiZSBzZW50LiBMaXN0ZW5lcnNcbiAqICAgc2hvdWxkIGNhbGwgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGxheWVyIHRvIGluaXRpYXRlXG4gKiAgIHRoZSBzZW5kaW5nIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gcmVzcG9uc2UgW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gKiAgIEBjb250ZXh0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgdGhhdCB3YXMgc2VudFxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkRcbiAqXG4gKiBAIWV2ZW50IHJldHJ5KHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBhIHJlcXVlc3QgZmFpbGVkIGFuZCBtaWdodCBuZWVkIHRvIGJlIHJldHJpZWQgb3IgcmVkaXJlY3RlZC5cbiAqICAgSWYgdGhlIHJlc3BvbnNlIGlzIHJldHJ5YWJsZSwgdGhlIGxpc3RlbmVyIHNob3VsZCBzZXQgdGhlXG4gKiAgIGByZXNwb25zZS5lcnJvci5yZXRyeWFibGVgIHByb3BlcnR5IHRvIGB0cnVlYCwgYW5kIG9wdGlvbmFsbHkgc2V0XG4gKiAgIGByZXNwb25zZS5lcnJvci5yZXRyeURlbGF5YCB0byB0aGUgbWlsbGlzZWNvbmQgZGVsYXkgZm9yIHRoZSBuZXh0IGF0dGVtcHQuXG4gKiAgIEluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3QsIGByZXNwb25zZS5lcnJvci5yZWRpcmVjdGAgc2hvdWxkIGJlIHNldCB0b1xuICogICBgdHJ1ZWAgd2l0aCBgcmV0cnlEZWxheWAgc2V0IHRvIGFuIG9wdGlvbmFsIGRlbGF5IG9uIHRoZSBuZXh0IHJlcXVlc3QuXG4gKlxuICogICBJZiBhIGxpc3RlbmVyIGRlY2lkZXMgdGhhdCBhIHJlcXVlc3Qgc2hvdWxkIG5vdCBiZSByZXRyaWVkLFxuICogICBpdCBzaG91bGQgc2V0IGJvdGggYHJldHJ5YWJsZWAgYW5kIGByZWRpcmVjdGAgdG8gZmFsc2UuXG4gKlxuICogICBOb3RlIHRoYXQgYSByZXRyeWFibGUgZXJyb3Igd2lsbCBiZSByZXRyaWVkIGF0IG1vc3RcbiAqICAge0FXUy5Db25maWcubWF4UmV0cmllc30gdGltZXMgKGJhc2VkIG9uIHRoZSBzZXJ2aWNlIG9iamVjdCdzIGNvbmZpZykuXG4gKiAgIFNpbWlsYXJseSwgYSByZXF1ZXN0IHRoYXQgaXMgcmVkaXJlY3RlZCB3aWxsIG9ubHkgcmVkaXJlY3QgYXQgbW9zdFxuICogICB7QVdTLkNvbmZpZy5tYXhSZWRpcmVjdHN9IHRpbWVzLlxuICpcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAZXhhbXBsZSBBZGRpbmcgYSBjdXN0b20gcmV0cnkgZm9yIGEgNDA0IHJlc3BvbnNlXG4gKiAgICAgcmVxdWVzdC5vbigncmV0cnknLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgICAgLy8gdGhpcyByZXNvdXJjZSBpcyBub3QgeWV0IGF2YWlsYWJsZSwgd2FpdCAxMCBzZWNvbmRzIHRvIGdldCBpdCBhZ2FpblxuICogICAgICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQgJiYgcmVzcG9uc2UuZXJyb3IpIHtcbiAqICAgICAgICAgcmVzcG9uc2UuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTsgICAvLyByZXRyeSB0aGlzIGVycm9yXG4gKiAgICAgICAgIHJlc3BvbnNlLmVycm9yLnJldHJ5RGVsYXkgPSAxMDAwMDsgLy8gd2FpdCAxMCBzZWNvbmRzXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQCFncm91cCBEYXRhIFBhcnNpbmcgRXZlbnRzXG4gKlxuICogQCFldmVudCBleHRyYWN0RXJyb3IocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCBvbiBhbGwgbm9uLTJ4eCByZXF1ZXN0cyBzbyB0aGF0IGxpc3RlbmVycyBjYW4gZXh0cmFjdFxuICogICBlcnJvciBkZXRhaWxzIGZyb20gdGhlIHJlc3BvbnNlIGJvZHkuIExpc3RlbmVycyB0byB0aGlzIGV2ZW50XG4gKiAgIHNob3VsZCBzZXQgdGhlIGByZXNwb25zZS5lcnJvcmAgcHJvcGVydHkuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGV4dHJhY3REYXRhKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgaW4gc3VjY2Vzc2Z1bCByZXF1ZXN0cyB0byBhbGxvdyBsaXN0ZW5lcnMgdG9cbiAqICAgZGUtc2VyaWFsaXplIHRoZSByZXNwb25zZSBib2R5IGludG8gYHJlc3BvbnNlLmRhdGFgLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFncm91cCBDb21wbGV0aW9uIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgc3VjY2VzcyhyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqICAgYHJlc3BvbnNlLmRhdGFgIHdpbGwgY29udGFpbiB0aGUgcmVzcG9uc2UgZGF0YSBhbmRcbiAqICAgYHJlc3BvbnNlLmVycm9yYCB3aWxsIGJlIG51bGwuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGVycm9yKGVycm9yLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlXG4gKiAgIHJlcXVlc3QuIGByZXNwb25zZS5lcnJvcmAgd2lsbCBjb250YWluIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yXG4gKiAgIHRoYXQgb2NjdXJyZWQuIGByZXNwb25zZS5kYXRhYCB3aWxsIGJlIG51bGwuXG4gKiAgIEBwYXJhbSBlcnJvciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0XG4gKiAgICAgdGhlIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGNvbXBsZXRlKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbmV2ZXIgYSByZXF1ZXN0IGN5Y2xlIGNvbXBsZXRlcy4gYHJlc3BvbnNlLmVycm9yYFxuICogICBzaG91bGQgYmUgY2hlY2tlZCwgc2luY2UgdGhlIHJlcXVlc3QgbWF5IGhhdmUgZmFpbGVkLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFncm91cCBIVFRQIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgaHR0cEhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcG9uc2UsIHN0YXR1c01lc3NhZ2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGhlYWRlcnMgYXJlIHNlbnQgYnkgdGhlIHJlbW90ZSBzZXJ2ZXJcbiAqICAgQHBhcmFtIHN0YXR1c0NvZGUgW0ludGVnZXJdIHRoZSBIVFRQIHJlc3BvbnNlIGNvZGVcbiAqICAgQHBhcmFtIGhlYWRlcnMgW21hcDxTdHJpbmcsU3RyaW5nPl0gdGhlIHJlc3BvbnNlIGhlYWRlcnNcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQHBhcmFtIHN0YXR1c01lc3NhZ2UgW1N0cmluZ10gQSBzdGF0dXMgbWVzc2FnZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBIVFRQXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlIGNvZGVcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgaHR0cERhdGEoY2h1bmssIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBkYXRhIGlzIHNlbnQgYnkgdGhlIHJlbW90ZSBzZXJ2ZXJcbiAqICAgQHBhcmFtIGNodW5rIFtCdWZmZXJdIHRoZSBidWZmZXIgZGF0YSBjb250YWluaW5nIHRoZSBuZXh0IGRhdGEgY2h1bmtcbiAqICAgICBmcm9tIHRoZSBzZXJ2ZXJcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQVxuICpcbiAqIEAhZXZlbnQgaHR0cFVwbG9hZFByb2dyZXNzKHByb2dyZXNzLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIEhUVFAgcmVxdWVzdCBoYXMgdXBsb2FkZWQgbW9yZSBkYXRhXG4gKiAgIEBwYXJhbSBwcm9ncmVzcyBbbWFwXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYGxvYWRlZGAgYW5kIGB0b3RhbGAgYnl0ZXNcbiAqICAgICBvZiB0aGUgcmVxdWVzdC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAbm90ZSBUaGlzIGV2ZW50IHdpbGwgbm90IGJlIGVtaXR0ZWQgaW4gTm9kZS5qcyAwLjgueC5cbiAqXG4gKiBAIWV2ZW50IGh0dHBEb3dubG9hZFByb2dyZXNzKHByb2dyZXNzLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIEhUVFAgcmVxdWVzdCBoYXMgZG93bmxvYWRlZCBtb3JlIGRhdGFcbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBub3RlIFRoaXMgZXZlbnQgd2lsbCBub3QgYmUgZW1pdHRlZCBpbiBOb2RlLmpzIDAuOC54LlxuICpcbiAqIEAhZXZlbnQgaHR0cEVycm9yKGVycm9yLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIEhUVFAgcmVxdWVzdCBmYWlsZWRcbiAqICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCB0aGF0IHdhcyB0aHJvd25cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgaHR0cERvbmUocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSBzZXJ2ZXIgaXMgZmluaXNoZWQgc2VuZGluZyBkYXRhXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAc2VlIEFXUy5SZXNwb25zZVxuICovXG5BV1MuUmVxdWVzdCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVxdWVzdCBmb3IgYW4gb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gc2VydmljZSB3aXRoXG4gICAqIGEgc2V0IG9mIGlucHV0IHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2aWNlIFtBV1MuU2VydmljZV0gdGhlIHNlcnZpY2UgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG9wZXJhdGlvbiB0byBwZXJmb3JtIG9uIHRoZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSBwYXJhbXMgW09iamVjdF0gcGFyYW1ldGVycyB0byBzZW5kIHRvIHRoZSBvcGVyYXRpb24uXG4gICAqICAgU2VlIHRoZSBvcGVyYXRpb24ncyBkb2N1bWVudGF0aW9uIGZvciB0aGUgZm9ybWF0IG9mIHRoZVxuICAgKiAgIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUmVxdWVzdChzZXJ2aWNlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIHZhciBlbmRwb2ludCA9IHNlcnZpY2UuZW5kcG9pbnQ7XG4gICAgdmFyIHJlZ2lvbiA9IHNlcnZpY2UuY29uZmlnLnJlZ2lvbjtcbiAgICB2YXIgY3VzdG9tVXNlckFnZW50ID0gc2VydmljZS5jb25maWcuY3VzdG9tVXNlckFnZW50O1xuXG4gICAgaWYgKHNlcnZpY2Uuc2lnbmluZ1JlZ2lvbikge1xuICAgICAgcmVnaW9uID0gc2VydmljZS5zaWduaW5nUmVnaW9uO1xuICAgIH0gZWxzZSBpZiAoc2VydmljZS5pc0dsb2JhbEVuZHBvaW50KSB7XG4gICAgICByZWdpb24gPSAndXMtZWFzdC0xJztcbiAgICB9XG5cbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbiAmJiBkb21haW4uYWN0aXZlO1xuICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QoZW5kcG9pbnQsIHJlZ2lvbik7XG4gICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpO1xuXG4gICAgdGhpcy5yZXNwb25zZSA9IG5ldyBBV1MuUmVzcG9uc2UodGhpcyk7XG4gICAgdGhpcy5fYXNtID0gbmV3IEFjY2VwdG9yU3RhdGVNYWNoaW5lKGZzbS5zdGF0ZXMsICd2YWxpZGF0ZScpO1xuICAgIHRoaXMuX2hhbHRIYW5kbGVyc09uRXJyb3IgPSBmYWxzZTtcblxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVtaXQgPSB0aGlzLmVtaXRFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBTZW5kaW5nIGEgUmVxdWVzdFxuICAgKi9cblxuICAvKipcbiAgICogQG92ZXJsb2FkIHNlbmQoY2FsbGJhY2sgPSBudWxsKVxuICAgKiAgIFNlbmRzIHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogICBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICAgIEBjb250ZXh0IFtBV1MuUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGJlaW5nIHNlbnQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRoIGEgY2FsbGJhY2tcbiAgICogICAgIHJlcXVlc3QgPSBzMy5wdXRPYmplY3Qoe0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9KTtcbiAgICogICAgIHJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgY29uc29sZS5sb2coZXJyLCBkYXRhKTsgfSk7XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aCBubyBjYWxsYmFjayAodXNpbmcgZXZlbnQgaGFuZGxlcnMpXG4gICAqICAgICByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfSk7XG4gICAqICAgICByZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7IC4uLiB9KTsgLy8gcmVnaXN0ZXIgYSBjYWxsYmFja1xuICAgKiAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAqL1xuICBzZW5kOiBmdW5jdGlvbiBzZW5kKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAvLyBhcHBlbmQgdG8gdXNlciBhZ2VudFxuICAgICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudCgnY2FsbGJhY2snKTtcbiAgICAgIHRoaXMub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChyZXNwLCByZXNwLmVycm9yLCByZXNwLmRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucnVuVG8oKTtcblxuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcHJvbWlzZSgpXG4gICAqICAgU2VuZHMgdGhlIHJlcXVlc3QgYW5kIHJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oZGF0YSlcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gICAqICAgICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyb3IpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyb3IgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHJlcXVlc3QuXG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3QgdXNpbmcgcHJvbWlzZXMuXG4gICAqICAgICB2YXIgcmVxdWVzdCA9IHMzLnB1dE9iamVjdCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J30pO1xuICAgKiAgICAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucHJvbWlzZSgpO1xuICAgKiAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24oZGF0YSkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyb3IpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5ydW5Ubygnc2VuZCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBydW5UbzogZnVuY3Rpb24gcnVuVG8oc3RhdGUsIGRvbmUpIHtcbiAgICB0aGlzLl9hc20ucnVuVG8oc3RhdGUsIGRvbmUsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBYm9ydHMgYSByZXF1ZXN0LCBlbWl0dGluZyB0aGUgZXJyb3IgYW5kIGNvbXBsZXRlIGV2ZW50cy5cbiAgICpcbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICogQGV4YW1wbGUgQWJvcnRpbmcgYSByZXF1ZXN0IGFmdGVyIHNlbmRpbmdcbiAgICogICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICAgQnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JyxcbiAgICogICAgIEJvZHk6IEJ1ZmZlci5hbGxvYygxMDI0ICogMTAyNCAqIDUpIC8vIDVNQiBwYXlsb2FkXG4gICAqICAgfTtcbiAgICogICB2YXIgcmVxdWVzdCA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICAgKiAgIHJlcXVlc3Quc2VuZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhcIkVycm9yOlwiLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICAgKiAgICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyBhYm9ydCByZXF1ZXN0IGluIDEgc2Vjb25kXG4gICAqICAgc2V0VGltZW91dChyZXF1ZXN0LmFib3J0LmJpbmQocmVxdWVzdCksIDEwMDApO1xuICAgKlxuICAgKiAgIC8vIHByaW50cyBcIkVycm9yOiBSZXF1ZXN0QWJvcnRlZEVycm9yIFJlcXVlc3QgYWJvcnRlZCBieSB1c2VyXCJcbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdIHRoZSBzYW1lIHJlcXVlc3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygndmFsaWRhdGVSZXNwb25zZScpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdleHRyYWN0RXJyb3InKTtcbiAgICB0aGlzLm9uKCd2YWxpZGF0ZVJlc3BvbnNlJywgZnVuY3Rpb24gYWRkQWJvcnRlZEVycm9yKHJlc3ApIHtcbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCBieSB1c2VyJyksIHtcbiAgICAgICAgIGNvZGU6ICdSZXF1ZXN0QWJvcnRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5odHRwUmVxdWVzdC5zdHJlYW0gJiYgIXRoaXMuaHR0cFJlcXVlc3Quc3RyZWFtLmRpZENhbGxiYWNrKSB7IC8vIGFib3J0IEhUVFAgc3RyZWFtXG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0LnN0cmVhbS5hYm9ydCgpO1xuICAgICAgaWYgKHRoaXMuaHR0cFJlcXVlc3QuX2Fib3J0Q2FsbGJhY2spIHtcbiAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3QuX2Fib3J0Q2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdzZW5kJyk7IC8vIGhhdmVuJ3Qgc2VudCB5ZXQsIHNvIGxldCdzIG5vdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVhY2ggcGFnZSBvZiByZXN1bHRzIGdpdmVuIGEgcGFnZWFibGUgcmVxdWVzdCwgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgd2l0aCBlYWNoIHBhZ2Ugb2YgZGF0YS4gQWZ0ZXIgYWxsIHBhZ2VzIGhhdmUgYmVlblxuICAgKiByZXRyaWV2ZWQsIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBgbnVsbGAgZGF0YS5cbiAgICpcbiAgICogQG5vdGUgVGhpcyBvcGVyYXRpb24gY2FuIGdlbmVyYXRlIG11bHRpcGxlIHJlcXVlc3RzIHRvIGEgc2VydmljZS5cbiAgICogQGV4YW1wbGUgSXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgcGFnZXMgb2Ygb2JqZWN0cyBpbiBhbiBTMyBidWNrZXRcbiAgICogICB2YXIgcGFnZXMgPSAxO1xuICAgKiAgIHMzLmxpc3RPYmplY3RzKCkuZWFjaFBhZ2UoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSByZXR1cm47XG4gICAqICAgICBjb25zb2xlLmxvZyhcIlBhZ2VcIiwgcGFnZXMrKyk7XG4gICAqICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgSXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgcGFnZXMgd2l0aCBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2tcbiAgICogICBzMy5saXN0T2JqZWN0cyhwYXJhbXMpLmVhY2hQYWdlKGZ1bmN0aW9uKGVyciwgZGF0YSwgZG9uZSkge1xuICAgKiAgICAgZG9Tb21ldGhpbmdBc3luY0FuZE9yRXhwZW5zaXZlKGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAvLyBUaGUgbmV4dCBwYWdlIG9mIHJlc3VsdHMgaXNuJ3QgZmV0Y2hlZCB1bnRpbCBkb25lIGlzIGNhbGxlZFxuICAgKiAgICAgICBkb25lKCk7XG4gICAqICAgICB9KTtcbiAgICogICB9KTtcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSwgW2RvbmVDYWxsYmFja10pXG4gICAqICAgQ2FsbGVkIHdpdGggZWFjaCBwYWdlIG9mIHJlc3VsdGluZyBkYXRhIGZyb20gdGhlIHJlcXVlc3QuIElmIHRoZVxuICAgKiAgIG9wdGlvbmFsIGBkb25lQ2FsbGJhY2tgIGlzIHByb3ZpZGVkIGluIHRoZSBmdW5jdGlvbiwgaXQgbXVzdCBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBjYWxsYmFjayBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gYW4gZXJyb3Igb2JqZWN0LCBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSBhIHNpbmdsZSBwYWdlIG9mIHJlc3BvbnNlIGRhdGEuIElmIHRoZXJlIGlzIG5vXG4gICAqICAgICBtb3JlIGRhdGEsIHRoaXMgb2JqZWN0IHdpbGwgYmUgYG51bGxgLlxuICAgKiAgIEBwYXJhbSBkb25lQ2FsbGJhY2sgW0Z1bmN0aW9uXSBhbiBvcHRpb25hbCBkb25lIGNhbGxiYWNrLiBJZiB0aGlzXG4gICAqICAgICBhcmd1bWVudCBpcyBkZWZpbmVkIGluIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiwgaXQgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiAgICAgd2hlbiB0aGUgbmV4dCBwYWdlIGlzIHJlYWR5IHRvIGJlIHJldHJpZXZlZC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqICAgICBjb250cm9sbGluZyBzZXJpYWwgcGFnaW5hdGlvbiBhY3Jvc3MgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gICAqICAgQHJldHVybiBbQm9vbGVhbl0gaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgcGFnaW5hdGlvbiB3aWxsXG4gICAqICAgICBzdG9wLlxuICAgKlxuICAgKiBAc2VlIEFXUy5SZXF1ZXN0LmVhY2hJdGVtXG4gICAqIEBzZWUgQVdTLlJlc3BvbnNlLm5leHRQYWdlXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGVhY2hQYWdlOiBmdW5jdGlvbiBlYWNoUGFnZShjYWxsYmFjaykge1xuICAgIC8vIE1ha2UgYWxsIGNhbGxiYWNrcyBhc3luYy1pc2hcbiAgICBjYWxsYmFjayA9IEFXUy51dGlsLmZuLm1ha2VBc3luYyhjYWxsYmFjaywgMyk7XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwocmVzcG9uc2UsIHJlc3BvbnNlLmVycm9yLCByZXNwb25zZS5kYXRhLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICByZXNwb25zZS5uZXh0UGFnZSgpLm9uKCdjb21wbGV0ZScsIHdyYXBwZWRDYWxsYmFjaykuc2VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocmVzcG9uc2UsIG51bGwsIG51bGwsIEFXUy51dGlsLmZuLm5vb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdjb21wbGV0ZScsIHdyYXBwZWRDYWxsYmFjaykuc2VuZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnVtZXJhdGVzIG92ZXIgaW5kaXZpZHVhbCBpdGVtcyBvZiBhIHJlcXVlc3QsIHBhZ2luZyB0aGUgcmVzcG9uc2VzIGlmXG4gICAqIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQGFwaSBleHBlcmltZW50YWxcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgZWFjaEl0ZW06IGZ1bmN0aW9uIGVhY2hJdGVtKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRDYWxsYmFjayhlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcblxuICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKHNlbGYub3BlcmF0aW9uKTtcbiAgICAgIHZhciByZXN1bHRLZXkgPSBjb25maWcucmVzdWx0S2V5O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0S2V5KSkgcmVzdWx0S2V5ID0gcmVzdWx0S2V5WzBdO1xuICAgICAgdmFyIGl0ZW1zID0gam1lc3BhdGguc2VhcmNoKGRhdGEsIHJlc3VsdEtleSk7XG4gICAgICB2YXIgY29udGludWVJdGVyYXRpb24gPSB0cnVlO1xuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGNvbnRpbnVlSXRlcmF0aW9uID0gY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgICAgIGlmIChjb250aW51ZUl0ZXJhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gQVdTLnV0aWwuYWJvcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRpbnVlSXRlcmF0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaFBhZ2Uod3JhcHBlZENhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgb3BlcmF0aW9uIGNhbiByZXR1cm4gbXVsdGlwbGUgcGFnZXMgb2ZcbiAgICogICByZXNwb25zZSBkYXRhLlxuICAgKiBAc2VlIEFXUy5SZXNwb25zZS5lYWNoUGFnZVxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBpc1BhZ2VhYmxlOiBmdW5jdGlvbiBpc1BhZ2VhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyh0aGlzLm9wZXJhdGlvbikgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSByZXF1ZXN0IGFuZCBjb252ZXJ0cyB0aGUgcmVxdWVzdCBvYmplY3QgaW50byBhIHJlYWRhYmxlIHN0cmVhbVxuICAgKiB0aGF0IGNhbiBiZSByZWFkIGZyb20gb3IgcGlwZWQgaW50byBhIHdyaXRhYmxlIHN0cmVhbS5cbiAgICpcbiAgICogQG5vdGUgVGhlIGRhdGEgcmVhZCBmcm9tIGEgcmVhZGFibGUgc3RyZWFtIGNvbnRhaW5zIG9ubHlcbiAgICogICB0aGUgcmF3IEhUVFAgYm9keSBjb250ZW50cy5cbiAgICogQGV4YW1wbGUgTWFudWFsbHkgcmVhZGluZyBmcm9tIGEgc3RyZWFtXG4gICAqICAgcmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtKCkub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcIkdvdCBkYXRhOlwiLCBkYXRhLnRvU3RyaW5nKCkpO1xuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBQaXBpbmcgYSByZXF1ZXN0IGJvZHkgaW50byBhIGZpbGVcbiAgICogICB2YXIgb3V0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oJy9wYXRoL3RvL291dGZpbGUuanBnJyk7XG4gICAqICAgczMuc2VydmljZS5nZXRPYmplY3QocGFyYW1zKS5jcmVhdGVSZWFkU3RyZWFtKCkucGlwZShvdXQpO1xuICAgKiBAcmV0dXJuIFtTdHJlYW1dIHRoZSByZWFkYWJsZSBzdHJlYW0gb2JqZWN0IHRoYXQgY2FuIGJlIHBpcGVkXG4gICAqICAgb3IgcmVhZCBmcm9tIChieSByZWdpc3RlcmluZyAnZGF0YScgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICovXG4gIGNyZWF0ZVJlYWRTdHJlYW06IGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0oKSB7XG4gICAgdmFyIHN0cmVhbXMgPSBBV1MudXRpbC5zdHJlYW07XG4gICAgdmFyIHJlcSA9IHRoaXM7XG4gICAgdmFyIHN0cmVhbSA9IG51bGw7XG5cbiAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgIHN0cmVhbSA9IG5ldyBzdHJlYW1zLlBhc3NUaHJvdWdoKCk7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyByZXEuc2VuZCgpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtID0gbmV3IHN0cmVhbXMuU3RyZWFtKCk7XG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuXG4gICAgICBzdHJlYW0uc2VudCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghc3RyZWFtLnNlbnQgJiYgZXZlbnQgPT09ICdkYXRhJykge1xuICAgICAgICAgIHN0cmVhbS5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyByZXEuc2VuZCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdodHRwSGVhZGVycycsIGZ1bmN0aW9uIHN0cmVhbUhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdodHRwRGF0YScsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQSk7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignaHR0cEVycm9yJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9FUlJPUik7XG4gICAgICAgIHJlcS5vbignaHR0cEVycm9yJywgZnVuY3Rpb24gc3RyZWFtSHR0cEVycm9yKGVycm9yKSB7XG4gICAgICAgICAgcmVzcC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4cGVjdGVkTGVuO1xuICAgICAgICBpZiAocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgZXhwZWN0ZWRMZW4gPSBwYXJzZUludChoZWFkZXJzWydjb250ZW50LWxlbmd0aCddLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdGVkTGVuICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKGV4cGVjdGVkTGVuKSAmJiBleHBlY3RlZExlbiA+PSAwKSB7XG4gICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVjZWl2ZWRMZW4gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQgPSBmdW5jdGlvbiBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KCkge1xuICAgICAgICAgIGlmIChzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggJiYgcmVjZWl2ZWRMZW4gIT09IGV4cGVjdGVkTGVuKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdTdHJlYW0gY29udGVudCBsZW5ndGggbWlzbWF0Y2guIFJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICsgJyBvZiAnICsgZXhwZWN0ZWRMZW4gKyAnIGJ5dGVzLicpLFxuICAgICAgICAgICAgICB7IGNvZGU6ICdTdHJlYW1Db250ZW50TGVuZ3RoTWlzbWF0Y2gnIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaHR0cFN0cmVhbSA9IHJlc3AuaHR0cFJlc3BvbnNlLmNyZWF0ZVVuYnVmZmVyZWRTdHJlYW0oKTtcblxuICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoQWNjdW11bGF0b3IgPSBuZXcgc3RyZWFtcy5QYXNzVGhyb3VnaCgpO1xuICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3IuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtcy5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3dyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5vbignZW5kJywgY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICBodHRwU3RyZWFtLnVucGlwZShsZW5ndGhBY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5waXBlKGxlbmd0aEFjY3VtdWxhdG9yKS5waXBlKHN0cmVhbSwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodHRwU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBodHRwU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICs9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGh0dHBTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBodHRwU3RyZWFtLm9uKCdlbmQnLCBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0dHBTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gW0FycmF5LFJlc3BvbnNlXSBhcmdzIFRoaXMgc2hvdWxkIGJlIHRoZSByZXNwb25zZSBvYmplY3QsXG4gICAqICAgb3IgYW4gYXJyYXkgb2YgYXJncyB0byBzZW5kIHRvIHRoZSBldmVudC5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBlbWl0RXZlbnQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBhcmdzLCBkb25lKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnZnVuY3Rpb24nKSB7IGRvbmUgPSBhcmdzOyBhcmdzID0gbnVsbDsgfVxuICAgIGlmICghZG9uZSkgZG9uZSA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIGlmICghYXJncykgYXJncyA9IHRoaXMuZXZlbnRQYXJhbWV0ZXJzKGV2ZW50TmFtZSwgdGhpcy5yZXNwb25zZSk7XG5cbiAgICB2YXIgb3JpZ0VtaXQgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLnByb3RvdHlwZS5lbWl0O1xuICAgIG9yaWdFbWl0LmNhbGwodGhpcywgZXZlbnROYW1lLCBhcmdzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB0aGlzLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgZG9uZS5jYWxsKHRoaXMsIGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXZlbnRQYXJhbWV0ZXJzOiBmdW5jdGlvbiBldmVudFBhcmFtZXRlcnMoZXZlbnROYW1lKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgIGNhc2UgJ3Jlc3RhcnQnOlxuICAgICAgY2FzZSAndmFsaWRhdGUnOlxuICAgICAgY2FzZSAnc2lnbic6XG4gICAgICBjYXNlICdidWlsZCc6XG4gICAgICBjYXNlICdhZnRlclZhbGlkYXRlJzpcbiAgICAgIGNhc2UgJ2FmdGVyQnVpbGQnOlxuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gW3RoaXMucmVzcG9uc2UuZXJyb3IsIHRoaXMucmVzcG9uc2VdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt0aGlzLnJlc3BvbnNlXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJlc2lnbjogZnVuY3Rpb24gcHJlc2lnbihleHBpcmVzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGV4cGlyZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXhwaXJlcztcbiAgICAgIGV4cGlyZXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFXUy5TaWduZXJzLlByZXNpZ24oKS5zaWduKHRoaXMudG9HZXQoKSwgZXhwaXJlcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzUHJlc2lnbmVkOiBmdW5jdGlvbiBpc1ByZXNpZ25lZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaHR0cFJlcXVlc3QuaGVhZGVycywgJ3ByZXNpZ25lZC1leHBpcmVzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG9VbmF1dGhlbnRpY2F0ZWQ6IGZ1bmN0aW9uIHRvVW5hdXRoZW50aWNhdGVkKCkge1xuICAgIHRoaXMuX3VuQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9DUkVERU5USUFMUyk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignc2lnbicsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNJR04pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvR2V0OiBmdW5jdGlvbiB0b0dldCgpIHtcbiAgICBpZiAodGhpcy5zZXJ2aWNlLmFwaS5wcm90b2NvbCA9PT0gJ3F1ZXJ5JyB8fFxuICAgICAgICB0aGlzLnNlcnZpY2UuYXBpLnByb3RvY29sID09PSAnZWMyJykge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmJ1aWxkQXNHZXQpO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmJ1aWxkQXNHZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBidWlsZEFzR2V0OiBmdW5jdGlvbiBidWlsZEFzR2V0KHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnO1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QucGF0aCA9IHJlcXVlc3Quc2VydmljZS5lbmRwb2ludC5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPycgKyByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmJvZHk7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5ib2R5ID0gJyc7XG5cbiAgICAvLyBkb24ndCBuZWVkIHRoZXNlIGhlYWRlcnMgb24gYSBHRVQgcmVxdWVzdFxuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ107XG4gICAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFsdEhhbmRsZXJzT25FcnJvcjogZnVuY3Rpb24gaGFsdEhhbmRsZXJzT25FcnJvcigpIHtcbiAgICB0aGlzLl9oYWx0SGFuZGxlcnNPbkVycm9yID0gdHJ1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5SZXF1ZXN0LmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gYXBwZW5kIHRvIHVzZXIgYWdlbnRcbiAgICB0aGlzLmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdwcm9taXNlJyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlRGVwZW5kZW5jeShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICAgIHJlamVjdChyZXNwLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZpbmUgJHJlc3BvbnNlIHByb3BlcnR5IHNvIHRoYXQgaXQgaXMgbm90IGVudW1lcmFibGVcbiAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIGNpcmN1bGFyIHJlZmVyZW5jZSBlcnJvcnMgd2hlbiBzdHJpbmdpZnlpbmcgdGhlIEpTT04gb2JqZWN0XG4gICAgICAgICAgcmVzb2x2ZShPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICByZXNwLmRhdGEgfHwge30sXG4gICAgICAgICAgICAnJHJlc3BvbnNlJyxcbiAgICAgICAgICAgIHt2YWx1ZTogcmVzcH1cbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmLnJ1blRvKCk7XG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVxdWVzdC5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5SZXF1ZXN0KTtcblxuQVdTLnV0aWwubWl4aW4oQVdTLlJlcXVlc3QsIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKS4gWW91XG4gKiBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gQSBjb3B5IG9mXG4gKiB0aGUgTGljZW5zZSBpcyBsb2NhdGVkIGF0XG4gKlxuICogICAgIGh0dHA6Ly9hd3MuYW1hem9uLmNvbS9hcGFjaGUyLjAvXG4gKlxuICogb3IgaW4gdGhlIFwibGljZW5zZVwiIGZpbGUgYWNjb21wYW55aW5nIHRoaXMgZmlsZS4gVGhpcyBmaWxlIGlzXG4gKiBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWNcbiAqIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGptZXNwYXRoID0gcmVxdWlyZSgnam1lc3BhdGgnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ0hFQ0tfQUNDRVBUT1JTKHJlc3ApIHtcbiAgdmFyIHdhaXRlciA9IHJlc3AucmVxdWVzdC5fd2FpdGVyO1xuICB2YXIgYWNjZXB0b3JzID0gd2FpdGVyLmNvbmZpZy5hY2NlcHRvcnM7XG4gIHZhciBhY2NlcHRvck1hdGNoZWQgPSBmYWxzZTtcbiAgdmFyIHN0YXRlID0gJ3JldHJ5JztcblxuICBhY2NlcHRvcnMuZm9yRWFjaChmdW5jdGlvbihhY2NlcHRvcikge1xuICAgIGlmICghYWNjZXB0b3JNYXRjaGVkKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IHdhaXRlci5tYXRjaGVyc1thY2NlcHRvci5tYXRjaGVyXTtcbiAgICAgIGlmIChtYXRjaGVyICYmIG1hdGNoZXIocmVzcCwgYWNjZXB0b3IuZXhwZWN0ZWQsIGFjY2VwdG9yLmFyZ3VtZW50KSkge1xuICAgICAgICBhY2NlcHRvck1hdGNoZWQgPSB0cnVlO1xuICAgICAgICBzdGF0ZSA9IGFjY2VwdG9yLnN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFhY2NlcHRvck1hdGNoZWQgJiYgcmVzcC5lcnJvcikgc3RhdGUgPSAnZmFpbHVyZSc7XG5cbiAgaWYgKHN0YXRlID09PSAnc3VjY2VzcycpIHtcbiAgICB3YWl0ZXIuc2V0U3VjY2VzcyhyZXNwKTtcbiAgfSBlbHNlIHtcbiAgICB3YWl0ZXIuc2V0RXJyb3IocmVzcCwgc3RhdGUgPT09ICdyZXRyeScpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5SZXNvdXJjZVdhaXRlciA9IGluaGVyaXQoe1xuICAvKipcbiAgICogV2FpdHMgZm9yIGEgZ2l2ZW4gc3RhdGUgb24gYSBzZXJ2aWNlIG9iamVjdFxuICAgKiBAcGFyYW0gc2VydmljZSBbU2VydmljZV0gdGhlIHNlcnZpY2Ugb2JqZWN0IHRvIHdhaXQgb25cbiAgICogQHBhcmFtIHN0YXRlIFtTdHJpbmddIHRoZSBzdGF0ZSAoZGVmaW5lZCBpbiB3YWl0ZXIgY29uZmlndXJhdGlvbikgdG8gd2FpdFxuICAgKiAgIGZvci5cbiAgICogQGV4YW1wbGUgQ3JlYXRlIGEgd2FpdGVyIGZvciBydW5uaW5nIEVDMiBpbnN0YW5jZXNcbiAgICogICB2YXIgZWMyID0gbmV3IEFXUy5FQzI7XG4gICAqICAgdmFyIHdhaXRlciA9IG5ldyBBV1MuUmVzb3VyY2VXYWl0ZXIoZWMyLCAnaW5zdGFuY2VSdW5uaW5nJyk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3Ioc2VydmljZSwgc3RhdGUpIHtcbiAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmxvYWRXYWl0ZXJDb25maWcodGhpcy5zdGF0ZSk7XG4gIH0sXG5cbiAgc2VydmljZTogbnVsbCxcblxuICBzdGF0ZTogbnVsbCxcblxuICBjb25maWc6IG51bGwsXG5cbiAgbWF0Y2hlcnM6IHtcbiAgICBwYXRoOiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCwgYXJndW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBqbWVzcGF0aC5zZWFyY2gocmVzcC5kYXRhLCBhcmd1bWVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gam1lc3BhdGguc3RyaWN0RGVlcEVxdWFsKHJlc3VsdCxleHBlY3RlZCk7XG4gICAgfSxcblxuICAgIHBhdGhBbGw6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkLCBhcmd1bWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBqbWVzcGF0aC5zZWFyY2gocmVzcC5kYXRhLCBhcmd1bWVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHJlc3VsdHMgPSBbcmVzdWx0c107XG4gICAgICB2YXIgbnVtUmVzdWx0cyA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgaWYgKCFudW1SZXN1bHRzKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpbmQgPSAwIDsgaW5kIDwgbnVtUmVzdWx0czsgaW5kKyspIHtcbiAgICAgICAgaWYgKCFqbWVzcGF0aC5zdHJpY3REZWVwRXF1YWwocmVzdWx0c1tpbmRdLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBwYXRoQW55OiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCwgYXJndW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSByZXN1bHRzID0gW3Jlc3VsdHNdO1xuICAgICAgdmFyIG51bVJlc3VsdHMgPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGluZCA9IDAgOyBpbmQgPCBudW1SZXN1bHRzOyBpbmQrKykge1xuICAgICAgICBpZiAoam1lc3BhdGguc3RyaWN0RGVlcEVxdWFsKHJlc3VsdHNbaW5kXSwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc3RhdHVzOiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCkge1xuICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgcmV0dXJuICh0eXBlb2Ygc3RhdHVzQ29kZSA9PT0gJ251bWJlcicpICYmIChzdGF0dXNDb2RlID09PSBleHBlY3RlZCk7XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCkge1xuICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgcmVzcC5lcnJvcikge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHJlc3AuZXJyb3IuY29kZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGV4cGVjdGVkIGlzIG5vdCBzdHJpbmcsIGNhbiBiZSBib29sZWFuIGluZGljYXRpbmcgcHJlc2VuY2Ugb2YgZXJyb3JcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gISFyZXNwLmVycm9yO1xuICAgIH1cbiAgfSxcblxuICBsaXN0ZW5lcnM6IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgYWRkKCdSRVRSWV9DSEVDSycsICdyZXRyeScsIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIHZhciB3YWl0ZXIgPSByZXNwLnJlcXVlc3QuX3dhaXRlcjtcbiAgICAgIGlmIChyZXNwLmVycm9yICYmIHJlc3AuZXJyb3IuY29kZSA9PT0gJ1Jlc291cmNlTm90UmVhZHknKSB7XG4gICAgICAgIHJlc3AuZXJyb3IucmV0cnlEZWxheSA9ICh3YWl0ZXIuY29uZmlnLmRlbGF5IHx8IDApICogMTAwMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnQ0hFQ0tfT1VUUFVUJywgJ2V4dHJhY3REYXRhJywgQ0hFQ0tfQUNDRVBUT1JTKTtcblxuICAgIGFkZCgnQ0hFQ0tfRVJST1InLCAnZXh0cmFjdEVycm9yJywgQ0hFQ0tfQUNDRVBUT1JTKTtcbiAgfSksXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0FXUy5SZXF1ZXN0XVxuICAgKi9cbiAgd2FpdDogZnVuY3Rpb24gd2FpdChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcGFyYW1zOyBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuJHdhaXRlcikge1xuICAgICAgcGFyYW1zID0gQVdTLnV0aWwuY29weShwYXJhbXMpO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuJHdhaXRlci5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsYXkgPSBwYXJhbXMuJHdhaXRlci5kZWxheTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLiR3YWl0ZXIubWF4QXR0ZW1wdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heEF0dGVtcHRzID0gcGFyYW1zLiR3YWl0ZXIubWF4QXR0ZW1wdHM7XG4gICAgICB9XG4gICAgICBkZWxldGUgcGFyYW1zLiR3YWl0ZXI7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QodGhpcy5jb25maWcub3BlcmF0aW9uLCBwYXJhbXMpO1xuICAgIHJlcXVlc3QuX3dhaXRlciA9IHRoaXM7XG4gICAgcmVxdWVzdC5yZXNwb25zZS5tYXhSZXRyaWVzID0gdGhpcy5jb25maWcubWF4QXR0ZW1wdHM7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcnModGhpcy5saXN0ZW5lcnMpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSByZXF1ZXN0LnNlbmQoY2FsbGJhY2spO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9LFxuXG4gIHNldFN1Y2Nlc3M6IGZ1bmN0aW9uIHNldFN1Y2Nlc3MocmVzcCkge1xuICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgIHJlc3AuZGF0YSA9IHJlc3AuZGF0YSB8fCB7fTtcbiAgICByZXNwLnJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCdleHRyYWN0RGF0YScpO1xuICB9LFxuXG4gIHNldEVycm9yOiBmdW5jdGlvbiBzZXRFcnJvcihyZXNwLCByZXRyeWFibGUpIHtcbiAgICByZXNwLmRhdGEgPSBudWxsO1xuICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihyZXNwLmVycm9yIHx8IG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiAnUmVzb3VyY2VOb3RSZWFkeScsXG4gICAgICBtZXNzYWdlOiAnUmVzb3VyY2UgaXMgbm90IGluIHRoZSBzdGF0ZSAnICsgdGhpcy5zdGF0ZSxcbiAgICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWRzIHdhaXRlciBjb25maWd1cmF0aW9uIGZyb20gQVBJIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkV2FpdGVyQ29uZmlnOiBmdW5jdGlvbiBsb2FkV2FpdGVyQ29uZmlnKHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2UuYXBpLndhaXRlcnNbc3RhdGVdKSB7XG4gICAgICB0aHJvdyBuZXcgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ1N0YXRlTm90Rm91bmRFcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdTdGF0ZSAnICsgc3RhdGUgKyAnIG5vdCBmb3VuZC4nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IEFXUy51dGlsLmNvcHkodGhpcy5zZXJ2aWNlLmFwaS53YWl0ZXJzW3N0YXRlXSk7XG4gIH1cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGptZXNwYXRoID0gcmVxdWlyZSgnam1lc3BhdGgnKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgcmVzcG9uc2UgaW5mb3JtYXRpb25cbiAqIGZyb20gYSBzZXJ2aWNlIHJlcXVlc3Qgb3BlcmF0aW9uIHNlbnQgdGhyb3VnaCB7QVdTLlJlcXVlc3R9LlxuICogVGhlIHJlc3BvbnNlIG9iamVjdCBoYXMgdHdvIG1haW4gcHJvcGVydGllcyBmb3IgZ2V0dGluZyBpbmZvcm1hdGlvblxuICogYmFjayBmcm9tIGEgcmVxdWVzdDpcbiAqXG4gKiAjIyBUaGUgYGRhdGFgIHByb3BlcnR5XG4gKlxuICogVGhlIGByZXNwb25zZS5kYXRhYCBwcm9wZXJ0eSBjb250YWlucyB0aGUgc2VyaWFsaXplZCBvYmplY3QgZGF0YVxuICogcmV0cmlldmVkIGZyb20gdGhlIHNlcnZpY2UgcmVxdWVzdC4gRm9yIGluc3RhbmNlLCBmb3IgYW5cbiAqIEFtYXpvbiBEeW5hbW9EQiBgbGlzdFRhYmxlc2AgbWV0aG9kIGNhbGwsIHRoZSByZXNwb25zZSBkYXRhIG1pZ2h0XG4gKiBsb29rIGxpa2U6XG4gKlxuICogYGBgXG4gKiA+IHJlc3AuZGF0YVxuICogeyBUYWJsZU5hbWVzOlxuICogICAgWyAndGFibGUxJywgJ3RhYmxlMicsIC4uLiBdIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBgZGF0YWAgcHJvcGVydHkgY2FuIGJlIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJzIChzZWUgYmVsb3cpLlxuICpcbiAqICMjIFRoZSBgZXJyb3JgIHByb3BlcnR5XG4gKlxuICogSW4gdGhlIGV2ZW50IG9mIGEgc2VydmljZSBlcnJvciAob3IgdHJhbnNmZXIgZXJyb3IpLCB0aGVcbiAqIGByZXNwb25zZS5lcnJvcmAgcHJvcGVydHkgd2lsbCBiZSBmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGVycm9yIGRhdGEgaW4gdGhlIGZvcm06XG4gKlxuICogYGBgXG4gKiB7IGNvZGU6ICdTSE9SVF9VTklRVUVfRVJST1JfQ09ERScsXG4gKiAgIG1lc3NhZ2U6ICdTb21lIGh1bWFuIHJlYWRhYmxlIGVycm9yIG1lc3NhZ2UnIH1cbiAqIGBgYFxuICpcbiAqIEluIHRoZSBjYXNlIG9mIGFuIGVycm9yLCB0aGUgYGRhdGFgIHByb3BlcnR5IHdpbGwgYmUgYG51bGxgLlxuICogTm90ZSB0aGF0IGlmIHlvdSBoYW5kbGUgZXZlbnRzIHRoYXQgY2FuIGJlIGluIGEgZmFpbHVyZSBzdGF0ZSxcbiAqIHlvdSBzaG91bGQgYWx3YXlzIGNoZWNrIHdoZXRoZXIgYHJlc3BvbnNlLmVycm9yYCBpcyBzZXRcbiAqIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjY2VzcyB0aGUgYHJlc3BvbnNlLmRhdGFgIHByb3BlcnR5LlxuICpcbiAqIEAhYXR0cmlidXRlIGRhdGFcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgRGF0YSBQcm9wZXJ0aWVzXG4gKiAgIEBub3RlIEluc2lkZSBvZiBhIHtBV1MuUmVxdWVzdH5odHRwRGF0YX0gZXZlbnQsIHRoaXNcbiAqICAgICBwcm9wZXJ0eSBjb250YWlucyBhIHNpbmdsZSByYXcgcGFja2V0IGluc3RlYWQgb2YgdGhlXG4gKiAgICAgZnVsbCBkZS1zZXJpYWxpemVkIHNlcnZpY2UgcmVzcG9uc2UuXG4gKiAgIEByZXR1cm4gW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgcmVzcG9uc2UgZGF0YVxuICogICAgIGZyb20gdGhlIHNlcnZpY2UuXG4gKlxuICogQCFhdHRyaWJ1dGUgZXJyb3JcbiAqICAgQW4gc3RydWN0dXJlIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgYSBzZXJ2aWNlXG4gKiAgIG9yIG5ldHdvcmtpbmcgZXJyb3IuXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIERhdGEgUHJvcGVydGllc1xuICogICBAbm90ZSBUaGlzIGF0dHJpYnV0ZSBpcyBvbmx5IGZpbGxlZCBpZiBhIHNlcnZpY2Ugb3JcbiAqICAgICBuZXR3b3JraW5nIGVycm9yIG9jY3Vycy5cbiAqICAgQHJldHVybiBbRXJyb3JdXG4gKiAgICAgKiBjb2RlIFtTdHJpbmddIGEgdW5pcXVlIHNob3J0IGNvZGUgcmVwcmVzZW50aW5nIHRoZVxuICogICAgICAgZXJyb3IgdGhhdCB3YXMgZW1pdHRlZC5cbiAqICAgICAqIG1lc3NhZ2UgW1N0cmluZ10gYSBsb25nZXIgaHVtYW4gcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuICogICAgICogcmV0cnlhYmxlIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gKiAgICAgICByZXRyeWFibGUuXG4gKiAgICAgKiBzdGF0dXNDb2RlIFtOdW1lcmljXSBpbiB0aGUgY2FzZSBvZiBhIHJlcXVlc3QgdGhhdCByZWFjaGVkIHRoZSBzZXJ2aWNlLFxuICogICAgICAgdGhpcyB2YWx1ZSBjb250YWlucyB0aGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gKiAgICAgKiB0aW1lIFtEYXRlXSB0aGUgZGF0ZSB0aW1lIG9iamVjdCB3aGVuIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAqICAgICAqIGhvc3RuYW1lIFtTdHJpbmddIHNldCB3aGVuIGEgbmV0d29ya2luZyBlcnJvciBvY2N1cnMgdG8gZWFzaWx5XG4gKiAgICAgICBpZGVudGlmeSB0aGUgZW5kcG9pbnQgb2YgdGhlIHJlcXVlc3QuXG4gKiAgICAgKiByZWdpb24gW1N0cmluZ10gc2V0IHdoZW4gYSBuZXR3b3JraW5nIGVycm9yIG9jY3VycyB0byBlYXNpbHlcbiAqICAgICAgIGlkZW50aWZ5IHRoZSByZWdpb24gb2YgdGhlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVxdWVzdElkXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIERhdGEgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSB1bmlxdWUgcmVxdWVzdCBJRCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3BvbnNlLlxuICogICAgIExvZyB0aGlzIHZhbHVlIHdoZW4gZGVidWdnaW5nIHJlcXVlc3RzIGZvciBBV1Mgc3VwcG9ydC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZXRyeUNvdW50XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIE9wZXJhdGlvbiBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBudW1iZXIgb2YgcmV0cmllcyB0aGF0IHdlcmVcbiAqICAgICBhdHRlbXB0ZWQgYmVmb3JlIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVkaXJlY3RDb3VudFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBPcGVyYXRpb24gUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIHJlZGlyZWN0cyB0aGF0IHdlcmVcbiAqICAgICBmb2xsb3dlZCBiZWZvcmUgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBodHRwUmVzcG9uc2VcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgSFRUUCBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0FXUy5IdHRwUmVzcG9uc2VdIHRoZSByYXcgSFRUUCByZXNwb25zZSBvYmplY3RcbiAqICAgICBjb250YWluaW5nIHRoZSByZXNwb25zZSBoZWFkZXJzIGFuZCBib2R5IGluZm9ybWF0aW9uXG4gKiAgICAgZnJvbSB0aGUgc2VydmVyLlxuICpcbiAqIEBzZWUgQVdTLlJlcXVlc3RcbiAqL1xuQVdTLlJlc3BvbnNlID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLnJlZGlyZWN0Q291bnQgPSAwO1xuICAgIHRoaXMuaHR0cFJlc3BvbnNlID0gbmV3IEFXUy5IdHRwUmVzcG9uc2UoKTtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcmVxdWVzdC5zZXJ2aWNlLm51bVJldHJpZXMoKTtcbiAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5tYXhSZWRpcmVjdHM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJlcXVlc3QgZm9yIHRoZSBuZXh0IHBhZ2Ugb2YgcmVzcG9uc2UgZGF0YSwgY2FsbGluZyB0aGVcbiAgICogY2FsbGJhY2sgd2l0aCB0aGUgcGFnZSBkYXRhIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQ2FsbGVkIHdoZW4gYSBwYWdlIG9mIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgbmV4dCByZXF1ZXN0LlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvYmplY3QsIGlmIGFuIGVycm9yIG9jY3VycmVkIGluIHRoZSByZXF1ZXN0XG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIG5leHQgcGFnZSBvZiBkYXRhLCBvciBudWxsLCBpZiB0aGVyZSBhcmUgbm9cbiAgICogICAgIG1vcmUgcGFnZXMgbGVmdC5cbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCBmb3IgdGhlIG5leHQgcGFnZSBvZiBkYXRhXG4gICAqIEByZXR1cm4gW251bGxdIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGFuZCB0aGVyZSBhcmUgbm8gcGFnZXMgbGVmdFxuICAgKiAgIHRvIHJldHJpZXZlLlxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBuZXh0UGFnZTogZnVuY3Rpb24gbmV4dFBhZ2UoY2FsbGJhY2spIHtcbiAgICB2YXIgY29uZmlnO1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcy5yZXF1ZXN0LnNlcnZpY2U7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMucmVxdWVzdC5vcGVyYXRpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IHNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyhvcGVyYXRpb24sIHRydWUpO1xuICAgIH0gY2F0Y2ggKGUpIHsgdGhpcy5lcnJvciA9IGU7IH1cblxuICAgIGlmICghdGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMuZXJyb3IsIG51bGwpO1xuICAgICAgZWxzZSBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHRoaXMucmVxdWVzdC5wYXJhbXMpO1xuICAgIGlmICghdGhpcy5uZXh0UGFnZVRva2Vucykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2sobnVsbCwgbnVsbCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5wdXRUb2tlbnMgPSBjb25maWcuaW5wdXRUb2tlbjtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXRUb2tlbnMgPT09ICdzdHJpbmcnKSBpbnB1dFRva2VucyA9IFtpbnB1dFRva2Vuc107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0VG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcmFtc1tpbnB1dFRva2Vuc1tpXV0gPSB0aGlzLm5leHRQYWdlVG9rZW5zW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcnZpY2UubWFrZVJlcXVlc3QodGhpcy5yZXF1ZXN0Lm9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIG1vcmUgcGFnZXMgb2YgZGF0YSBjYW4gYmUgcmV0dXJuZWQgYnkgZnVydGhlclxuICAgKiAgIHJlcXVlc3RzXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGhhc05leHRQYWdlOiBmdW5jdGlvbiBoYXNOZXh0UGFnZSgpIHtcbiAgICB0aGlzLmNhY2hlTmV4dFBhZ2VUb2tlbnMoKTtcbiAgICBpZiAodGhpcy5uZXh0UGFnZVRva2VucykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMubmV4dFBhZ2VUb2tlbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjYWNoZU5leHRQYWdlVG9rZW5zOiBmdW5jdGlvbiBjYWNoZU5leHRQYWdlVG9rZW5zKCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ25leHRQYWdlVG9rZW5zJykpIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29uZmlnID0gdGhpcy5yZXF1ZXN0LnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyh0aGlzLnJlcXVlc3Qub3BlcmF0aW9uKTtcbiAgICBpZiAoIWNvbmZpZykgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG5cbiAgICB0aGlzLm5leHRQYWdlVG9rZW5zID0gbnVsbDtcbiAgICBpZiAoY29uZmlnLm1vcmVSZXN1bHRzKSB7XG4gICAgICBpZiAoIWptZXNwYXRoLnNlYXJjaCh0aGlzLmRhdGEsIGNvbmZpZy5tb3JlUmVzdWx0cykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4cHJzID0gY29uZmlnLm91dHB1dFRva2VuO1xuICAgIGlmICh0eXBlb2YgZXhwcnMgPT09ICdzdHJpbmcnKSBleHBycyA9IFtleHByc107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgZXhwcnMsIGZ1bmN0aW9uIChleHByKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gam1lc3BhdGguc2VhcmNoKHRoaXMuZGF0YSwgZXhwcik7XG4gICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMgPSB0aGlzLm5leHRQYWdlVG9rZW5zIHx8IFtdO1xuICAgICAgICB0aGlzLm5leHRQYWdlVG9rZW5zLnB1c2gob3V0cHV0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuICB9XG5cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICogQCFtZXRob2Qgb24oZXZlbnROYW1lLCBjYWxsYmFjaylcbiAqICAgUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrIGZvciB0aGUgZXZlbnQgZ2l2ZW4gYnkgYGV2ZW50TmFtZWAuXG4gKiAgIFBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBkZXBlbmQgb24gdGhlIGluZGl2aWR1YWwgZXZlbnRcbiAqICAgYmVpbmcgdHJpZ2dlcmVkLiBTZWUgdGhlIGV2ZW50IGRvY3VtZW50YXRpb24gZm9yIHRob3NlIHBhcmFtZXRlcnMuXG4gKlxuICogICBAcGFyYW0gZXZlbnROYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciBmb3JcbiAqICAgQHBhcmFtIGNhbGxiYWNrIFtGdW5jdGlvbl0gdGhlIGxpc3RlbmVyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgIEBwYXJhbSB0b0hlYWQgW0Jvb2xlYW5dIGF0dGFjaCB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gdGhlIGhlYWQgb2YgY2FsbGJhY2sgYXJyYXkgaWYgc2V0IHRvIHRydWUuXG4gKiAgICAgRGVmYXVsdCB0byBiZSBmYWxzZS5cbiAqICAgQHJldHVybiBbQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl0gdGhlIHNhbWUgb2JqZWN0IGZvciBjaGFpbmluZ1xuICovXG5BV1MuU2VxdWVudGlhbEV4ZWN1dG9yID0gQVdTLnV0aWwuaW5oZXJpdCh7XG5cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFNlcXVlbnRpYWxFeGVjdXRvcigpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsaXN0ZW5lcnM6IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPyB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5zbGljZSgwKSA6IFtdO1xuICB9LFxuXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudE5hbWUsIGxpc3RlbmVyLCB0b0hlYWQpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRvSGVhZCA/XG4gICAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnVuc2hpZnQobGlzdGVuZXIpIDpcbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25Bc3luYzogZnVuY3Rpb24gb25Bc3luYyhldmVudE5hbWUsIGxpc3RlbmVyLCB0b0hlYWQpIHtcbiAgICBsaXN0ZW5lci5faXNBc3luYyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lciwgdG9IZWFkKTtcbiAgfSxcblxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID4gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBldmVudEFyZ3MsIGRvbmVDYWxsYmFjaykge1xuICAgIGlmICghZG9uZUNhbGxiYWNrKSBkb25lQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHsgfTtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICB2YXIgY291bnQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIHRoaXMuY2FsbExpc3RlbmVycyhsaXN0ZW5lcnMsIGV2ZW50QXJncywgZG9uZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gY291bnQgPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcnMobGlzdGVuZXJzLCBhcmdzLCBkb25lQ2FsbGJhY2ssIHByZXZFcnJvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXJyb3IgPSBwcmV2RXJyb3IgfHwgbnVsbDtcblxuICAgIGZ1bmN0aW9uIGNhbGxOZXh0TGlzdGVuZXIoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyb3IgfHwgbmV3IEVycm9yKCksIGVycik7XG4gICAgICAgIGlmIChzZWxmLl9oYWx0SGFuZGxlcnNPbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5jYWxsTGlzdGVuZXJzKGxpc3RlbmVycywgYXJncywgZG9uZUNhbGxiYWNrLCBlcnJvcik7XG4gICAgfVxuXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnMuc2hpZnQoKTtcbiAgICAgIGlmIChsaXN0ZW5lci5faXNBc3luYykgeyAvLyBhc3luY2hyb25vdXMgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoW2NhbGxOZXh0TGlzdGVuZXJdKSk7XG4gICAgICAgIHJldHVybjsgLy8gc3RvcCBoZXJlLCBjYWxsTmV4dExpc3RlbmVyIHdpbGwgY29udGludWVcbiAgICAgIH0gZWxzZSB7IC8vIHN5bmNocm9ub3VzIGxpc3RlbmVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyb3IgfHwgbmV3IEVycm9yKCksIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmIHNlbGYuX2hhbHRIYW5kbGVyc09uRXJyb3IpIHtcbiAgICAgICAgICBkb25lQ2FsbGJhY2suY2FsbChzZWxmLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBvciBjb3BpZXMgYSBzZXQgb2YgbGlzdGVuZXJzIGZyb20gYW5vdGhlciBsaXN0IG9mXG4gICAqIGxpc3RlbmVycyBvciBTZXF1ZW50aWFsRXhlY3V0b3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGVuZXJzIFttYXA8U3RyaW5nLEFycmF5PEZ1bmN0aW9uPj4sIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3JdXG4gICAqICAgYSBsaXN0IG9mIGV2ZW50cyBhbmQgY2FsbGJhY2tzLCBvciBhbiBldmVudCBlbWl0dGVyIG9iamVjdFxuICAgKiAgIGNvbnRhaW5pbmcgbGlzdGVuZXJzIHRvIGFkZCB0byB0aGlzIGVtaXR0ZXIgb2JqZWN0LlxuICAgKiBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSB0aGUgZW1pdHRlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICogQGV4YW1wbGUgQWRkaW5nIGxpc3RlbmVycyBmcm9tIGEgbWFwIG9mIGxpc3RlbmVyc1xuICAgKiAgIGVtaXR0ZXIuYWRkTGlzdGVuZXJzKHtcbiAgICogICAgIGV2ZW50MTogW2Z1bmN0aW9uKCkgeyAuLi4gfSwgZnVuY3Rpb24oKSB7IC4uLiB9XSxcbiAgICogICAgIGV2ZW50MjogW2Z1bmN0aW9uKCkgeyAuLi4gfV1cbiAgICogICB9KTtcbiAgICogICBlbWl0dGVyLmVtaXQoJ2V2ZW50MScpOyAvLyBlbWl0dGVyIGhhcyBldmVudDFcbiAgICogICBlbWl0dGVyLmVtaXQoJ2V2ZW50MicpOyAvLyBlbWl0dGVyIGhhcyBldmVudDJcbiAgICogQGV4YW1wbGUgQWRkaW5nIGxpc3RlbmVycyBmcm9tIGFub3RoZXIgZW1pdHRlciBvYmplY3RcbiAgICogICB2YXIgZW1pdHRlcjEgPSBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpO1xuICAgKiAgIGVtaXR0ZXIxLm9uKCdldmVudDEnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgIGVtaXR0ZXIxLm9uKCdldmVudDInLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgIHZhciBlbWl0dGVyMiA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG4gICAqICAgZW1pdHRlcjIuYWRkTGlzdGVuZXJzKGVtaXR0ZXIxKTtcbiAgICogICBlbWl0dGVyMi5lbWl0KCdldmVudDEnKTsgLy8gZW1pdHRlcjIgaGFzIGV2ZW50MVxuICAgKiAgIGVtaXR0ZXIyLmVtaXQoJ2V2ZW50MicpOyAvLyBlbWl0dGVyMiBoYXMgZXZlbnQyXG4gICAqL1xuICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhsaXN0ZW5lcnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycyBpZiBwYXJhbWV0ZXIgaXMgYW4gU2VxdWVudGlhbEV4ZWN1dG9yIG9iamVjdFxuICAgIGlmIChsaXN0ZW5lcnMuX2V2ZW50cykgbGlzdGVuZXJzID0gbGlzdGVuZXJzLl9ldmVudHM7XG5cbiAgICBBV1MudXRpbC5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrcykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrcyA9IFtjYWxsYmFja3NdO1xuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKGNhbGxiYWNrcywgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgc2VsZi5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IHdpdGgge29ufSBhbmQgc2F2ZXMgdGhlIGNhbGxiYWNrIGhhbmRsZSBmdW5jdGlvblxuICAgKiBhcyBhIHByb3BlcnR5IG9uIHRoZSBlbWl0dGVyIG9iamVjdCB1c2luZyBhIGdpdmVuIGBuYW1lYC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0IG9uIHRoaXMgb2JqZWN0IGNvbnRhaW5pbmdcbiAgICogICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaGFuZGxlIHNvIHRoYXQgdGhlIGxpc3RlbmVyIGNhbiBiZSByZW1vdmVkIGluXG4gICAqICAgdGhlIGZ1dHVyZS5cbiAgICogQHBhcmFtIChzZWUgb24pXG4gICAqIEByZXR1cm4gKHNlZSBvbilcbiAgICogQGV4YW1wbGUgQWRkaW5nIGEgbmFtZWQgbGlzdGVuZXIgREFUQV9DQUxMQkFDS1xuICAgKiAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkgeyBkb1NvbWV0aGluZygpOyB9O1xuICAgKiAgIGVtaXR0ZXIuYWRkTmFtZWRMaXN0ZW5lcignREFUQV9DQUxMQkFDSycsICdkYXRhJywgbGlzdGVuZXIpO1xuICAgKlxuICAgKiAgIC8vIHRoZSBmb2xsb3dpbmcgcHJpbnRzOiB0cnVlXG4gICAqICAgY29uc29sZS5sb2coZW1pdHRlci5EQVRBX0NBTExCQUNLID09IGxpc3RlbmVyKTtcbiAgICovXG4gIGFkZE5hbWVkTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZE5hbWVkTGlzdGVuZXIobmFtZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdG9IZWFkKSB7XG4gICAgdGhpc1tuYW1lXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgdG9IZWFkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGROYW1lZEFzeW5jTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZE5hbWVkQXN5bmNMaXN0ZW5lcihuYW1lLCBldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpIHtcbiAgICBjYWxsYmFjay5faXNBc3luYyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuYWRkTmFtZWRMaXN0ZW5lcihuYW1lLCBldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBhIHNldCBvZiBuYW1lZCBsaXN0ZW5lcnMgdXNpbmdcbiAgICoge2FkZE5hbWVkTGlzdGVuZXJ9LiBUaGUgY2FsbGJhY2sgY29udGFpbnMgYSBwYXJhbWV0ZXJcbiAgICogd2l0aCBhIGhhbmRsZSB0byB0aGUgYGFkZE5hbWVkTGlzdGVuZXJgIG1ldGhvZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGFkZClcbiAgICogICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGluIG9yZGVyIHRvIHByb3ZpZGVcbiAgICogICB0aGUgYGFkZGAgZnVuY3Rpb24gdG8gdGhlIGJsb2NrLiBUaGlzIHNpbXBsaWZpZXMgdGhlIGFkZGl0aW9uIG9mXG4gICAqICAgYSBsYXJnZSBncm91cCBvZiBuYW1lZCBsaXN0ZW5lcnMuXG4gICAqICAgQHBhcmFtIGFkZCBbRnVuY3Rpb25dIHRoZSB7YWRkTmFtZWRMaXN0ZW5lcn0gZnVuY3Rpb24gdG8gY2FsbFxuICAgKiAgICAgd2hlbiByZWdpc3RlcmluZyBsaXN0ZW5lcnMuXG4gICAqIEBleGFtcGxlIEFkZGluZyBhIHNldCBvZiBuYW1lZCBsaXN0ZW5lcnNcbiAgICogICBlbWl0dGVyLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgKiAgICAgYWRkKCdEQVRBX0NBTExCQUNLJywgJ2RhdGEnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgICAgYWRkKCdPVEhFUicsICdvdGhlckV2ZW50JywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICAgIGFkZCgnTEFTVCcsICdsYXN0RXZlbnQnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIC8vIHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdyBzZXQ6XG4gICAqICAgZW1pdHRlci5EQVRBX0NBTExCQUNLO1xuICAgKiAgIGVtaXR0ZXIuT1RIRVI7XG4gICAqICAgZW1pdHRlci5MQVNUO1xuICAgKi9cbiAgYWRkTmFtZWRMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZE5hbWVkTGlzdGVuZXJzKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNhbGxiYWNrKFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuYWRkTmFtZWRMaXN0ZW5lci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmFkZE5hbWVkQXN5bmNMaXN0ZW5lci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIHtvbn0gaXMgdGhlIHByZWZlcmVkIG1ldGhvZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2VxdWVudGlhbEV4ZWN1dG9yLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IucHJvdG90eXBlLm9uO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3I7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgQXBpID0gcmVxdWlyZSgnLi9tb2RlbC9hcGknKTtcbnZhciByZWdpb25Db25maWcgPSByZXF1aXJlKCcuL3JlZ2lvbl9jb25maWcnKTtcblxudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGNsaWVudENvdW50ID0gMDtcbnZhciByZWdpb25fdXRpbHMgPSByZXF1aXJlKCcuL3JlZ2lvbi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBzZXJ2aWNlIGNsYXNzIHJlcHJlc2VudGluZyBhbiBBV1Mgc2VydmljZS5cbiAqXG4gKiBAY2xhc3NfYWJzdHJhY3QgVGhpcyBjbGFzcyBpcyBhbiBhYnN0cmFjdCBjbGFzcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBhcGlWZXJzaW9uc1xuICogICBAcmV0dXJuIFtBcnJheTxTdHJpbmc+XSB0aGUgbGlzdCBvZiBBUEkgdmVyc2lvbnMgc3VwcG9ydGVkIGJ5IHRoaXMgc2VydmljZS5cbiAqICAgQHJlYWRvbmx5XG4gKi9cbkFXUy5TZXJ2aWNlID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2VydmljZSBvYmplY3Qgd2l0aCBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgW21hcF0gYSBtYXAgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2VydmljZShjb25maWcpIHtcbiAgICBpZiAoIXRoaXMubG9hZFNlcnZpY2VDbGFzcykge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICdTZXJ2aWNlIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBgbmV3XFwnIG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5yZWdpb24pIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IGNvbmZpZy5yZWdpb247XG4gICAgICAgIGlmIChyZWdpb25fdXRpbHMuaXNGaXBzUmVnaW9uKHJlZ2lvbikpIHtcbiAgICAgICAgICBjb25maWcucmVnaW9uID0gcmVnaW9uX3V0aWxzLmdldFJlYWxSZWdpb24ocmVnaW9uKTtcbiAgICAgICAgICBjb25maWcudXNlRmlwc0VuZHBvaW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnaW9uX3V0aWxzLmlzR2xvYmFsUmVnaW9uKHJlZ2lvbikpIHtcbiAgICAgICAgICBjb25maWcucmVnaW9uID0gcmVnaW9uX3V0aWxzLmdldFJlYWxSZWdpb24ocmVnaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudXNlRHVhbHN0YWNrID09PSAnYm9vbGVhbidcbiAgICAgICAgJiYgdHlwZW9mIGNvbmZpZy51c2VEdWFsc3RhY2tFbmRwb2ludCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbmZpZy51c2VEdWFsc3RhY2tFbmRwb2ludCA9IGNvbmZpZy51c2VEdWFsc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFNlcnZpY2VDbGFzcyA9IHRoaXMubG9hZFNlcnZpY2VDbGFzcyhjb25maWcgfHwge30pO1xuICAgIGlmIChTZXJ2aWNlQ2xhc3MpIHtcbiAgICAgIHZhciBvcmlnaW5hbENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY29uZmlnKTtcbiAgICAgIHZhciBzdmMgPSBuZXcgU2VydmljZUNsYXNzKGNvbmZpZyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ZjLCAnX29yaWdpbmFsQ29uZmlnJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gb3JpZ2luYWxDb25maWc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc3ZjLl9jbGllbnRJZCA9ICsrY2xpZW50Q291bnQ7XG4gICAgICByZXR1cm4gc3ZjO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemUoY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGNvbmZpZykge1xuICAgIHZhciBzdmNDb25maWcgPSBBV1MuY29uZmlnW3RoaXMuc2VydmljZUlkZW50aWZpZXJdO1xuICAgIHRoaXMuY29uZmlnID0gbmV3IEFXUy5Db25maWcoQVdTLmNvbmZpZyk7XG4gICAgaWYgKHN2Y0NvbmZpZykgdGhpcy5jb25maWcudXBkYXRlKHN2Y0NvbmZpZywgdHJ1ZSk7XG4gICAgaWYgKGNvbmZpZykgdGhpcy5jb25maWcudXBkYXRlKGNvbmZpZywgdHJ1ZSk7XG5cbiAgICB0aGlzLnZhbGlkYXRlU2VydmljZSgpO1xuICAgIGlmICghdGhpcy5jb25maWcuZW5kcG9pbnQpIHJlZ2lvbkNvbmZpZy5jb25maWd1cmVFbmRwb2ludCh0aGlzKTtcblxuICAgIHRoaXMuY29uZmlnLmVuZHBvaW50ID0gdGhpcy5lbmRwb2ludEZyb21UZW1wbGF0ZSh0aGlzLmNvbmZpZy5lbmRwb2ludCk7XG4gICAgdGhpcy5zZXRFbmRwb2ludCh0aGlzLmNvbmZpZy5lbmRwb2ludCk7XG4gICAgLy9lbmFibGUgYXR0YWNoaW5nIGxpc3RlbmVycyB0byBzZXJ2aWNlIGNsaWVudFxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbCh0aGlzKTtcbiAgICBBV1MuU2VydmljZS5hZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVycyh0aGlzKTtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmNsaWVudFNpZGVNb25pdG9yaW5nIHx8IEFXUy5TZXJ2aWNlLl9jbGllbnRTaWRlTW9uaXRvcmluZykgJiYgdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgIHZhciBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcbiAgICAgIHRoaXMuYWRkTmFtZWRMaXN0ZW5lcignUFVCTElTSF9BUElfQ0FMTCcsICdhcGlDYWxsJywgZnVuY3Rpb24gUFVCTElTSF9BUElfQ0FMTChldmVudCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge3B1Ymxpc2hlci5ldmVudEhhbmRsZXIoZXZlbnQpO30pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZE5hbWVkTGlzdGVuZXIoJ1BVQkxJU0hfQVBJX0FUVEVNUFQnLCAnYXBpQ2FsbEF0dGVtcHQnLCBmdW5jdGlvbiBQVUJMSVNIX0FQSV9BVFRFTVBUKGV2ZW50KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7cHVibGlzaGVyLmV2ZW50SGFuZGxlcihldmVudCk7fSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVTZXJ2aWNlOiBmdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2UoKSB7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFNlcnZpY2VDbGFzczogZnVuY3Rpb24gbG9hZFNlcnZpY2VDbGFzcyhzZXJ2aWNlQ29uZmlnKSB7XG4gICAgdmFyIGNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgaWYgKCFBV1MudXRpbC5pc0VtcHR5KHRoaXMuYXBpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25maWcuYXBpQ29uZmlnKSB7XG4gICAgICByZXR1cm4gQVdTLlNlcnZpY2UuZGVmaW5lU2VydmljZUFwaSh0aGlzLmNvbnN0cnVjdG9yLCBjb25maWcuYXBpQ29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0gbmV3IEFXUy5Db25maWcoQVdTLmNvbmZpZyk7XG4gICAgICBjb25maWcudXBkYXRlKHNlcnZpY2VDb25maWcsIHRydWUpO1xuICAgICAgdmFyIHZlcnNpb24gPSBjb25maWcuYXBpVmVyc2lvbnNbdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlSWRlbnRpZmllcl07XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbiB8fCBjb25maWcuYXBpVmVyc2lvbjtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdFNlcnZpY2VDbGFzcyh2ZXJzaW9uKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGF0ZXN0U2VydmljZUNsYXNzOiBmdW5jdGlvbiBnZXRMYXRlc3RTZXJ2aWNlQ2xhc3ModmVyc2lvbikge1xuICAgIHZlcnNpb24gPSB0aGlzLmdldExhdGVzdFNlcnZpY2VWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzW3ZlcnNpb25dID09PSBudWxsKSB7XG4gICAgICBBV1MuU2VydmljZS5kZWZpbmVTZXJ2aWNlQXBpKHRoaXMuY29uc3RydWN0b3IsIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzW3ZlcnNpb25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldExhdGVzdFNlcnZpY2VWZXJzaW9uOiBmdW5jdGlvbiBnZXRMYXRlc3RTZXJ2aWNlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzIHx8IHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlcnZpY2VzIGRlZmluZWQgb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfVxuXG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gJ2xhdGVzdCc7XG4gICAgfSBlbHNlIGlmIChBV1MudXRpbC5pc1R5cGUodmVyc2lvbiwgRGF0ZSkpIHtcbiAgICAgIHZlcnNpb24gPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEodmVyc2lvbikuc3BsaXQoJ1QnKVswXTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMsIHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMpLnNvcnQoKTtcbiAgICB2YXIgc2VsZWN0ZWRWZXJzaW9uID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgLy8gdmVyc2lvbnMgdGhhdCBlbmQgaW4gXCIqXCIgYXJlIG5vdCBhdmFpbGFibGUgb24gZGlzayBhbmQgY2FuIGJlXG4gICAgICAvLyBza2lwcGVkLCBzbyBkbyBub3QgY2hvb3NlIHRoZXNlIGFzIHNlbGVjdGVkVmVyc2lvbnNcbiAgICAgIGlmIChrZXlzW2ldW2tleXNbaV0ubGVuZ3RoIC0gMV0gIT09ICcqJykge1xuICAgICAgICBzZWxlY3RlZFZlcnNpb24gPSBrZXlzW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGtleXNbaV0uc3Vic3RyKDAsIDEwKSA8PSB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFZlcnNpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCAnICsgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlSWRlbnRpZmllciArXG4gICAgICAgICAgICAgICAgICAgICcgQVBJIHRvIHNhdGlzZnkgdmVyc2lvbiBjb25zdHJhaW50IGAnICsgdmVyc2lvbiArICdcXCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGk6IHt9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRSZXRyeUNvdW50OiAzLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGN1c3RvbWl6ZVJlcXVlc3RzOiBmdW5jdGlvbiBjdXN0b21pemVSZXF1ZXN0cyhjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyID0gY2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjYWxsYmFjayB0eXBlIFxcJycgKyB0eXBlb2YgY2FsbGJhY2sgKyAnXFwnIHByb3ZpZGVkIGluIGN1c3RvbWl6ZVJlcXVlc3RzJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxscyBhbiBvcGVyYXRpb24gb24gYSBzZXJ2aWNlIHdpdGggdGhlIGdpdmVuIGlucHV0IHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsIG9uIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIGlucHV0IG9wdGlvbnMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIG1ha2VSZXF1ZXN0OiBmdW5jdGlvbiBtYWtlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBpZiAodGhpcy5jb25maWcucGFyYW1zKSB7IC8vIGNvcHkgb25seSB0b3BsZXZlbCBib3VuZCBwYXJhbXNcbiAgICAgIHZhciBydWxlcyA9IHRoaXMuYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uXTtcbiAgICAgIGlmIChydWxlcykge1xuICAgICAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyk7XG4gICAgICAgIEFXUy51dGlsLmVhY2godGhpcy5jb25maWcucGFyYW1zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHJ1bGVzLmlucHV0Lm1lbWJlcnNba2V5XSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldID09PSB1bmRlZmluZWQgfHwgcGFyYW1zW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IEFXUy5SZXF1ZXN0KHRoaXMsIG9wZXJhdGlvbiwgcGFyYW1zKTtcbiAgICB0aGlzLmFkZEFsbFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCk7XG4gICAgdGhpcy5hdHRhY2hNb25pdG9yaW5nRW1pdHRlcihyZXF1ZXN0KTtcbiAgICBpZiAoY2FsbGJhY2spIHJlcXVlc3Quc2VuZChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxzIGFuIG9wZXJhdGlvbiBvbiBhIHNlcnZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgcGFyYW1ldGVycywgd2l0aG91dFxuICAgKiBhbnkgYXV0aGVudGljYXRpb24gZGF0YS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBcInB1YmxpY1wiIEFQSSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdG8gY2FsbCBvbiB0aGUgc2VydmljZS5cbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBpbnB1dCBvcHRpb25zIGZvciB0aGUgb3BlcmF0aW9uXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBtYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdDogZnVuY3Rpb24gbWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zKS50b1VuYXV0aGVudGljYXRlZCgpO1xuICAgIHJldHVybiBjYWxsYmFjayA/IHJlcXVlc3Quc2VuZChjYWxsYmFjaykgOiByZXF1ZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYSBnaXZlbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgW1N0cmluZ10gdGhlIHN0YXRlIG9uIHRoZSBzZXJ2aWNlIHRvIHdhaXQgZm9yXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2YgcGFyYW1ldGVycyB0byBwYXNzIHdpdGggZWFjaCByZXF1ZXN0XG4gICAqIEBvcHRpb24gcGFyYW1zICR3YWl0ZXIgW21hcF0gYSBtYXAgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgd2FpdGVyXG4gICAqIEBvcHRpb24gcGFyYW1zICR3YWl0ZXIuZGVsYXkgW051bWJlcl0gVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQgYmV0d2VlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzXG4gICAqIEBvcHRpb24gcGFyYW1zICR3YWl0ZXIubWF4QXR0ZW1wdHMgW051bWJlcl0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc2VuZCB3aGlsZSB3YWl0aW5nXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqL1xuICB3YWl0Rm9yOiBmdW5jdGlvbiB3YWl0Rm9yKHN0YXRlLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHdhaXRlciA9IG5ldyBBV1MuUmVzb3VyY2VXYWl0ZXIodGhpcywgc3RhdGUpO1xuICAgIHJldHVybiB3YWl0ZXIud2FpdChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRBbGxSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBhZGRBbGxSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICB2YXIgbGlzdCA9IFtBV1MuZXZlbnRzLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZSwgdGhpcy5zZXJ2aWNlSW50ZXJmYWNlKCksXG4gICAgICAgICAgICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmVQb3N0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldKSByZXF1ZXN0LmFkZExpc3RlbmVycyhsaXN0W2ldKTtcbiAgICB9XG5cbiAgICAvLyBkaXNhYmxlIHBhcmFtZXRlciB2YWxpZGF0aW9uXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5wYXJhbVZhbGlkYXRpb24pIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJyxcbiAgICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmxvZ2dlcikgeyAvLyBhZGQgbG9nZ2luZyBldmVudHNcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXJzKEFXUy5FdmVudExpc3RlbmVycy5Mb2dnZXIpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpO1xuICAgIC8vIGNhbGwgcHJvdG90eXBlJ3MgY3VzdG9tUmVxdWVzdEhhbmRsZXJcbiAgICBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmN1c3RvbVJlcXVlc3RIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jdXN0b21SZXF1ZXN0SGFuZGxlcihyZXF1ZXN0KTtcbiAgICB9XG4gICAgLy8gY2FsbCBpbnN0YW5jZSdzIGN1c3RvbVJlcXVlc3RIYW5kbGVyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnY3VzdG9tUmVxdWVzdEhhbmRsZXInKSAmJiB0eXBlb2YgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlcihyZXF1ZXN0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2ZW50IHJlY29yZGluZyBtZXRyaWNzIGZvciBhIHdob2xlIEFQSSBjYWxsLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhIHN1YnNldCBvZiBhcGkgY2FsbCBtZXRyaWNzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBpQ2FsbEV2ZW50OiBmdW5jdGlvbiBhcGlDYWxsRXZlbnQocmVxdWVzdCkge1xuICAgIHZhciBhcGkgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICAgIHZhciBtb25pdG9yaW5nRXZlbnQgPSB7XG4gICAgICBUeXBlOiAnQXBpQ2FsbCcsXG4gICAgICBBcGk6IGFwaSA/IGFwaS5uYW1lIDogcmVxdWVzdC5vcGVyYXRpb24sXG4gICAgICBWZXJzaW9uOiAxLFxuICAgICAgU2VydmljZTogcmVxdWVzdC5zZXJ2aWNlLmFwaS5zZXJ2aWNlSWQgfHwgcmVxdWVzdC5zZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeCxcbiAgICAgIFJlZ2lvbjogcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24sXG4gICAgICBNYXhSZXRyaWVzRXhjZWVkZWQ6IDAsXG4gICAgICBVc2VyQWdlbnQ6IHJlcXVlc3QuaHR0cFJlcXVlc3QuZ2V0VXNlckFnZW50KCksXG4gICAgfTtcbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LkZpbmFsSHR0cFN0YXR1c0NvZGUgPSByZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA+IDI5OSkge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsQXdzRXhjZXB0aW9uID0gZXJyb3IuY29kZTtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIG1vbml0b3JpbmdFdmVudC5GaW5hbEF3c0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgfHwgZXJyb3IubmFtZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsU2RrRXhjZXB0aW9uID0gZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsU2RrRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2ZW50IHJlY29yZGluZyBtZXRyaWNzIGZvciBhbiBBUEkgY2FsbCBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhIHN1YnNldCBvZiBhcGkgY2FsbCBhdHRlbXB0IG1ldHJpY3NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGlBdHRlbXB0RXZlbnQ6IGZ1bmN0aW9uIGFwaUF0dGVtcHRFdmVudChyZXF1ZXN0KSB7XG4gICAgdmFyIGFwaSA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIG1vbml0b3JpbmdFdmVudCA9IHtcbiAgICAgIFR5cGU6ICdBcGlDYWxsQXR0ZW1wdCcsXG4gICAgICBBcGk6IGFwaSA/IGFwaS5uYW1lIDogcmVxdWVzdC5vcGVyYXRpb24sXG4gICAgICBWZXJzaW9uOiAxLFxuICAgICAgU2VydmljZTogcmVxdWVzdC5zZXJ2aWNlLmFwaS5zZXJ2aWNlSWQgfHwgcmVxdWVzdC5zZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeCxcbiAgICAgIEZxZG46IHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdG5hbWUsXG4gICAgICBVc2VyQWdlbnQ6IHJlcXVlc3QuaHR0cFJlcXVlc3QuZ2V0VXNlckFnZW50KCksXG4gICAgfTtcbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50Lkh0dHBTdGF0dXNDb2RlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFyZXF1ZXN0Ll91bkF1dGhlbnRpY2F0ZWQgJiZcbiAgICAgIHJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMgJiZcbiAgICAgIHJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWRcbiAgICApIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5BY2Nlc3NLZXkgPSByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzKSByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICAgIGlmIChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10pIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5TZXNzaW9uVG9rZW4gPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ107XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLXJlcXVlc3RpZCddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuWEFtem5SZXF1ZXN0SWQgPSByZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLXJlcXVlc3RpZCddO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LXJlcXVlc3QtaWQnXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlhBbXpSZXF1ZXN0SWQgPSByZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotcmVxdWVzdC1pZCddO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWlkLTInXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlhBbXpJZDIgPSByZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotaWQtMiddO1xuICAgIH1cbiAgICByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgbWV0cmljcyBvZiBmYWlsZWQgcmVxdWVzdC5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhdHRlbXB0RmFpbEV2ZW50OiBmdW5jdGlvbiBhdHRlbXB0RmFpbEV2ZW50KHJlcXVlc3QpIHtcbiAgICB2YXIgbW9uaXRvcmluZ0V2ZW50ID0gdGhpcy5hcGlBdHRlbXB0RXZlbnQocmVxdWVzdCk7XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICB2YXIgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPiAyOTkgKSB7XG4gICAgICBpZiAoZXJyb3IuY29kZSkgbW9uaXRvcmluZ0V2ZW50LkF3c0V4Y2VwdGlvbiA9IGVycm9yLmNvZGU7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LkF3c0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lKSBtb25pdG9yaW5nRXZlbnQuU2RrRXhjZXB0aW9uID0gZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lO1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIG1vbml0b3JpbmdFdmVudC5TZGtFeGNlcHRpb25NZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbml0b3JpbmdFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQXR0YWNoIGxpc3RlbmVycyB0byByZXF1ZXN0IG9iamVjdCB0byBmZXRjaCBtZXRyaWNzIG9mIGVhY2ggcmVxdWVzdFxuICAgKiBhbmQgZW1pdCBkYXRhIG9iamVjdCB0aHJvdWdoIFxcJ0FwaUNhbGxcXCcgYW5kIFxcJ0FwaUNhbGxBdHRlbXB0XFwnIGV2ZW50cy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hNb25pdG9yaW5nRW1pdHRlcjogZnVuY3Rpb24gYXR0YWNoTW9uaXRvcmluZ0VtaXR0ZXIocmVxdWVzdCkge1xuICAgIHZhciBhdHRlbXB0VGltZXN0YW1wOyAvL3RpbWVzdGFtcCBtYXJraW5nIHRoZSBiZWdpbm5pbmcgb2YgYSByZXF1ZXN0IGF0dGVtcHRcbiAgICB2YXIgYXR0ZW1wdFN0YXJ0UmVhbFRpbWU7IC8vU3RhcnQgdGltZSBvZiByZXF1ZXN0IGF0dGVtcHQuIFVzZWQgdG8gY2FsY3VsYXRpbmcgYXR0ZW1wdExhdGVuY3lcbiAgICB2YXIgYXR0ZW1wdExhdGVuY3k7IC8vbGF0ZW5jeSBmcm9tIHJlcXVlc3Qgc2VudCBvdXQgdG8gaHR0cCByZXNwb25zZSByZWFjaGluZyBTREtcbiAgICB2YXIgY2FsbFN0YXJ0UmVhbFRpbWU7IC8vU3RhcnQgdGltZSBvZiBBUEkgY2FsbC4gVXNlZCB0byBjYWxjdWxhdGluZyBBUEkgY2FsbCBsYXRlbmN5XG4gICAgdmFyIGF0dGVtcHRDb3VudCA9IDA7IC8vcmVxdWVzdC5yZXRyeUNvdW50IGlzIG5vdCByZWxpYWJsZSBoZXJlXG4gICAgdmFyIHJlZ2lvbjsgLy9yZWdpb24gY2FjaGUgcmVnaW9uIGZvciBlYWNoIGF0dGVtcHQgc2luY2UgaXQgY2FuIGJlIHVwZGF0ZWQgaW4gcGxhc2UgKGUuZy4gczMpXG4gICAgdmFyIGNhbGxUaW1lc3RhbXA7IC8vdGltZXN0YW1wIHdoZW4gdGhlIHJlcXVlc3QgaXMgY3JlYXRlZFxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWRkVG9IZWFkID0gdHJ1ZTtcblxuICAgIHJlcXVlc3Qub24oJ3ZhbGlkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbFN0YXJ0UmVhbFRpbWUgPSBBV1MudXRpbC5yZWFsQ2xvY2subm93KCk7XG4gICAgICBjYWxsVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB9LCBhZGRUb0hlYWQpO1xuICAgIHJlcXVlc3Qub24oJ3NpZ24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhdHRlbXB0U3RhcnRSZWFsVGltZSA9IEFXUy51dGlsLnJlYWxDbG9jay5ub3coKTtcbiAgICAgIGF0dGVtcHRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgcmVnaW9uID0gcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb247XG4gICAgICBhdHRlbXB0Q291bnQrKztcbiAgICB9LCBhZGRUb0hlYWQpO1xuICAgIHJlcXVlc3Qub24oJ3ZhbGlkYXRlUmVzcG9uc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGF0dGVtcHRMYXRlbmN5ID0gTWF0aC5yb3VuZChBV1MudXRpbC5yZWFsQ2xvY2subm93KCkgLSBhdHRlbXB0U3RhcnRSZWFsVGltZSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdBUElfQ0FMTF9BVFRFTVBUJywgJ3N1Y2Nlc3MnLCBmdW5jdGlvbiBBUElfQ0FMTF9BVFRFTVBUKCkge1xuICAgICAgdmFyIGFwaUF0dGVtcHRFdmVudCA9IHNlbGYuYXBpQXR0ZW1wdEV2ZW50KHJlcXVlc3QpO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlRpbWVzdGFtcCA9IGF0dGVtcHRUaW1lc3RhbXA7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuQXR0ZW1wdExhdGVuY3kgPSBhdHRlbXB0TGF0ZW5jeSA+PSAwID8gYXR0ZW1wdExhdGVuY3kgOiAwO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgIHNlbGYuZW1pdCgnYXBpQ2FsbEF0dGVtcHQnLCBbYXBpQXR0ZW1wdEV2ZW50XSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdBUElfQ0FMTF9BVFRFTVBUX1JFVFJZJywgJ3JldHJ5JywgZnVuY3Rpb24gQVBJX0NBTExfQVRURU1QVF9SRVRSWSgpIHtcbiAgICAgIHZhciBhcGlBdHRlbXB0RXZlbnQgPSBzZWxmLmF0dGVtcHRGYWlsRXZlbnQocmVxdWVzdCk7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuVGltZXN0YW1wID0gYXR0ZW1wdFRpbWVzdGFtcDtcbiAgICAgIC8vYXR0ZW1wdExhdGVuY3kgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgZmFpbCBiZWZvcmUgcmVzcG9uc2VcbiAgICAgIGF0dGVtcHRMYXRlbmN5ID0gYXR0ZW1wdExhdGVuY3kgfHxcbiAgICAgICAgTWF0aC5yb3VuZChBV1MudXRpbC5yZWFsQ2xvY2subm93KCkgLSBhdHRlbXB0U3RhcnRSZWFsVGltZSk7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuQXR0ZW1wdExhdGVuY3kgPSBhdHRlbXB0TGF0ZW5jeSA+PSAwID8gYXR0ZW1wdExhdGVuY3kgOiAwO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgIHNlbGYuZW1pdCgnYXBpQ2FsbEF0dGVtcHQnLCBbYXBpQXR0ZW1wdEV2ZW50XSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdBUElfQ0FMTCcsICdjb21wbGV0ZScsIGZ1bmN0aW9uIEFQSV9DQUxMKCkge1xuICAgICAgdmFyIGFwaUNhbGxFdmVudCA9IHNlbGYuYXBpQ2FsbEV2ZW50KHJlcXVlc3QpO1xuICAgICAgYXBpQ2FsbEV2ZW50LkF0dGVtcHRDb3VudCA9IGF0dGVtcHRDb3VudDtcbiAgICAgIGlmIChhcGlDYWxsRXZlbnQuQXR0ZW1wdENvdW50IDw9IDApIHJldHVybjtcbiAgICAgIGFwaUNhbGxFdmVudC5UaW1lc3RhbXAgPSBjYWxsVGltZXN0YW1wO1xuICAgICAgdmFyIGxhdGVuY3kgPSBNYXRoLnJvdW5kKEFXUy51dGlsLnJlYWxDbG9jay5ub3coKSAtIGNhbGxTdGFydFJlYWxUaW1lKTtcbiAgICAgIGFwaUNhbGxFdmVudC5MYXRlbmN5ID0gbGF0ZW5jeSA+PSAwID8gbGF0ZW5jeSA6IDA7XG4gICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZS5lcnJvciAmJlxuICAgICAgICByZXNwb25zZS5lcnJvci5yZXRyeWFibGUgJiZcbiAgICAgICAgdHlwZW9mIHJlc3BvbnNlLnJldHJ5Q291bnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiByZXNwb25zZS5tYXhSZXRyaWVzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAocmVzcG9uc2UucmV0cnlDb3VudCA+PSByZXNwb25zZS5tYXhSZXRyaWVzKVxuICAgICAgKSB7XG4gICAgICAgIGFwaUNhbGxFdmVudC5NYXhSZXRyaWVzRXhjZWVkZWQgPSAxO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdhcGlDYWxsJywgW2FwaUNhbGxFdmVudF0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBzZXR1cCBhbnkgY3VzdG9tIHJlcXVlc3QgbGlzdGVuZXJzIGZvciBlYWNoXG4gICAqIG5ldyByZXF1ZXN0IHRvIHRoZSBzZXJ2aWNlLlxuICAgKlxuICAgKiBAbWV0aG9kX2Fic3RyYWN0IFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kLlxuICAgKi9cbiAgc2V0dXBSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBzZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaWduaW5nIG5hbWUgZm9yIGEgZ2l2ZW4gcmVxdWVzdFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFNpZ25pbmdOYW1lOiBmdW5jdGlvbiBnZXRTaWduaW5nTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcGkuc2lnbmluZ05hbWUgfHwgdGhpcy5hcGkuZW5kcG9pbnRQcmVmaXg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpZ25lciBjbGFzcyBmb3IgYSBnaXZlbiByZXF1ZXN0XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmVyQ2xhc3M6IGZ1bmN0aW9uIGdldFNpZ25lckNsYXNzKHJlcXVlc3QpIHtcbiAgICB2YXIgdmVyc2lvbjtcbiAgICAvLyBnZXQgb3BlcmF0aW9uIGF1dGh0eXBlIGlmIHByZXNlbnRcbiAgICB2YXIgb3BlcmF0aW9uID0gbnVsbDtcbiAgICB2YXIgYXV0aHR5cGUgPSAnJztcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgdmFyIG9wZXJhdGlvbnMgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgICBvcGVyYXRpb24gPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSB8fCBudWxsO1xuICAgICAgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSB0aGlzLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uO1xuICAgIH0gZWxzZSBpZiAoYXV0aHR5cGUgPT09ICd2NCcgfHwgYXV0aHR5cGUgPT09ICd2NC11bnNpZ25lZC1ib2R5Jykge1xuICAgICAgdmVyc2lvbiA9ICd2NCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnNpb24gPSB0aGlzLmFwaS5zaWduYXR1cmVWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5nZXRWZXJzaW9uKHZlcnNpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNlcnZpY2VJbnRlcmZhY2U6IGZ1bmN0aW9uIHNlcnZpY2VJbnRlcmZhY2UoKSB7XG4gICAgc3dpdGNoICh0aGlzLmFwaS5wcm90b2NvbCkge1xuICAgICAgY2FzZSAnZWMyJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5RdWVyeTtcbiAgICAgIGNhc2UgJ3F1ZXJ5JzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5RdWVyeTtcbiAgICAgIGNhc2UgJ2pzb24nOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLkpzb247XG4gICAgICBjYXNlICdyZXN0LWpzb24nOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlJlc3RKc29uO1xuICAgICAgY2FzZSAncmVzdC14bWwnOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlJlc3RYbWw7XG4gICAgfVxuICAgIGlmICh0aGlzLmFwaS5wcm90b2NvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgYHByb3RvY29sXFwnICcgK1xuICAgICAgICB0aGlzLmFwaS5wcm90b2NvbCArICcgaW4gQVBJIGNvbmZpZycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzdWNjZXNzZnVsUmVzcG9uc2U6IGZ1bmN0aW9uIHN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwKSB7XG4gICAgcmV0dXJuIHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPCAzMDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IHRpbWVzIGEgZmFpbGVkIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQgYmVmb3JlIGdpdmluZyB1cC5cbiAgICogdGhlIGRlZmF1bHRSZXRyeUNvdW50IGNhbiBiZSBvdmVycmlkZW4gYnkgc2VydmljZSBjbGFzc2VzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG51bVJldHJpZXM6IGZ1bmN0aW9uIG51bVJldHJpZXMoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1heFJldHJpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heFJldHJpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZXRyeUNvdW50O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXRyeURlbGF5czogZnVuY3Rpb24gcmV0cnlEZWxheXMocmV0cnlDb3VudCwgZXJyKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNhbGN1bGF0ZVJldHJ5RGVsYXkocmV0cnlDb3VudCwgdGhpcy5jb25maWcucmV0cnlEZWxheU9wdGlvbnMsIGVycik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlhYmxlRXJyb3I6IGZ1bmN0aW9uIHJldHJ5YWJsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMudGltZW91dEVycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMubmV0d29ya2luZ0Vycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZXhwaXJlZENyZWRlbnRpYWxzRXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy50aHJvdHRsZWRFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnJvci5zdGF0dXNDb2RlID49IDUwMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG5ldHdvcmtpbmdFcnJvcjogZnVuY3Rpb24gbmV0d29ya2luZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09ICdOZXR3b3JraW5nRXJyb3InO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRpbWVvdXRFcnJvcjogZnVuY3Rpb24gdGltZW91dEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4cGlyZWRDcmVkZW50aWFsc0Vycm9yOiBmdW5jdGlvbiBleHBpcmVkQ3JlZGVudGlhbHNFcnJvcihlcnJvcikge1xuICAgIC8vIFRPRE8gOiB0aGlzIG9ubHkgaGFuZGxlcyAqb25lKiBvZiB0aGUgZXhwaXJlZCBjcmVkZW50aWFsIGNvZGVzXG4gICAgcmV0dXJuIChlcnJvci5jb2RlID09PSAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xvY2tTa2V3RXJyb3I6IGZ1bmN0aW9uIGNsb2NrU2tld0Vycm9yKGVycm9yKSB7XG4gICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICBjYXNlICdSZXF1ZXN0VGltZVRvb1NrZXdlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0RXhwaXJlZCc6XG4gICAgICBjYXNlICdJbnZhbGlkU2lnbmF0dXJlRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1NpZ25hdHVyZURvZXNOb3RNYXRjaCc6XG4gICAgICBjYXNlICdBdXRoRmFpbHVyZSc6XG4gICAgICBjYXNlICdSZXF1ZXN0SW5UaGVGdXR1cmUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2tld0NvcnJlY3RlZERhdGU6IGZ1bmN0aW9uIGdldFNrZXdDb3JyZWN0ZWREYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLm5vdygpICsgdGhpcy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwcGx5Q2xvY2tPZmZzZXQ6IGZ1bmN0aW9uIGFwcGx5Q2xvY2tPZmZzZXQobmV3U2VydmVyVGltZSkge1xuICAgIGlmIChuZXdTZXJ2ZXJUaW1lKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCA9IG5ld1NlcnZlclRpbWUgLSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0Nsb2NrU2tld2VkOiBmdW5jdGlvbiBpc0Nsb2NrU2tld2VkKG5ld1NlcnZlclRpbWUpIHtcbiAgICBpZiAobmV3U2VydmVyVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0U2tld0NvcnJlY3RlZERhdGUoKS5nZXRUaW1lKCkgLSBuZXdTZXJ2ZXJUaW1lKSA+PSAzMDAwMDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRocm90dGxlZEVycm9yOiBmdW5jdGlvbiB0aHJvdHRsZWRFcnJvcihlcnJvcikge1xuICAgIC8vIHRoaXMgbG9naWMgdmFyaWVzIGJldHdlZW4gc2VydmljZXNcbiAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA9PT0gNDI5KSByZXR1cm4gdHJ1ZTtcbiAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgIGNhc2UgJ1Byb3Zpc2lvbmVkVGhyb3VnaHB1dEV4Y2VlZGVkRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1Rocm90dGxpbmcnOlxuICAgICAgY2FzZSAnVGhyb3R0bGluZ0V4Y2VwdGlvbic6XG4gICAgICBjYXNlICdSZXF1ZXN0TGltaXRFeGNlZWRlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0VGhyb3R0bGVkJzpcbiAgICAgIGNhc2UgJ1JlcXVlc3RUaHJvdHRsZWRFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnVG9vTWFueVJlcXVlc3RzRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1RyYW5zYWN0aW9uSW5Qcm9ncmVzc0V4Y2VwdGlvbic6IC8vZHluYW1vZGJcbiAgICAgIGNhc2UgJ0VDMlRocm90dGxlZEV4Y2VwdGlvbic6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBlbmRwb2ludEZyb21UZW1wbGF0ZTogZnVuY3Rpb24gZW5kcG9pbnRGcm9tVGVtcGxhdGUoZW5kcG9pbnQpIHtcbiAgICBpZiAodHlwZW9mIGVuZHBvaW50ICE9PSAnc3RyaW5nJykgcmV0dXJuIGVuZHBvaW50O1xuXG4gICAgdmFyIGUgPSBlbmRwb2ludDtcbiAgICBlID0gZS5yZXBsYWNlKC9cXHtzZXJ2aWNlXFx9L2csIHRoaXMuYXBpLmVuZHBvaW50UHJlZml4KTtcbiAgICBlID0gZS5yZXBsYWNlKC9cXHtyZWdpb25cXH0vZywgdGhpcy5jb25maWcucmVnaW9uKTtcbiAgICBlID0gZS5yZXBsYWNlKC9cXHtzY2hlbWVcXH0vZywgdGhpcy5jb25maWcuc3NsRW5hYmxlZCA/ICdodHRwcycgOiAnaHR0cCcpO1xuICAgIHJldHVybiBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldEVuZHBvaW50OiBmdW5jdGlvbiBzZXRFbmRwb2ludChlbmRwb2ludCkge1xuICAgIHRoaXMuZW5kcG9pbnQgPSBuZXcgQVdTLkVuZHBvaW50KGVuZHBvaW50LCB0aGlzLmNvbmZpZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFnaW5hdGlvbkNvbmZpZzogZnVuY3Rpb24gcGFnaW5hdGlvbkNvbmZpZyhvcGVyYXRpb24sIHRocm93RXhjZXB0aW9uKSB7XG4gICAgdmFyIHBhZ2luYXRvciA9IHRoaXMuYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uXS5wYWdpbmF0b3I7XG4gICAgaWYgKCFwYWdpbmF0b3IpIHtcbiAgICAgIGlmICh0aHJvd0V4Y2VwdGlvbikge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihlLCAnTm8gcGFnaW5hdGlvbiBjb25maWd1cmF0aW9uIGZvciAnICsgb3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwYWdpbmF0b3I7XG4gIH1cbn0pO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLlNlcnZpY2UsIHtcblxuICAvKipcbiAgICogQWRkcyBvbmUgbWV0aG9kIGZvciBlYWNoIG9wZXJhdGlvbiBkZXNjcmliZWQgaW4gdGhlIGFwaSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmaW5lTWV0aG9kczogZnVuY3Rpb24gZGVmaW5lTWV0aG9kcyhzdmMpIHtcbiAgICBBV1MudXRpbC5lYWNoKHN2Yy5wcm90b3R5cGUuYXBpLm9wZXJhdGlvbnMsIGZ1bmN0aW9uIGl0ZXJhdG9yKG1ldGhvZCkge1xuICAgICAgaWYgKHN2Yy5wcm90b3R5cGVbbWV0aG9kXSkgcmV0dXJuO1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IHN2Yy5wcm90b3R5cGUuYXBpLm9wZXJhdGlvbnNbbWV0aG9kXTtcbiAgICAgIGlmIChvcGVyYXRpb24uYXV0aHR5cGUgPT09ICdub25lJykge1xuICAgICAgICBzdmMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdmMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBuZXcgU2VydmljZSBjbGFzcyB1c2luZyBhIHNlcnZpY2UgaWRlbnRpZmllciBhbmQgbGlzdCBvZiB2ZXJzaW9uc1xuICAgKiBpbmNsdWRpbmcgYW4gb3B0aW9uYWwgc2V0IG9mIGZlYXR1cmVzIChmdW5jdGlvbnMpIHRvIGFwcGx5IHRvIHRoZSBjbGFzc1xuICAgKiBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2aWNlSWRlbnRpZmllciBbU3RyaW5nXSB0aGUgaWRlbnRpZmllciBmb3IgdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHZlcnNpb25zIFtBcnJheTxTdHJpbmc+XSBhIGxpc3Qgb2YgdmVyc2lvbnMgdGhhdCB3b3JrIHdpdGggdGhpc1xuICAgKiAgIHNlcnZpY2VcbiAgICogQHBhcmFtIGZlYXR1cmVzIFtPYmplY3RdIGFuIG9iamVjdCB0byBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZVxuICAgKiBAcmV0dXJuIFtDbGFzczxTZXJ2aWNlPl0gdGhlIHNlcnZpY2UgY2xhc3MgZGVmaW5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICAgKi9cbiAgZGVmaW5lU2VydmljZTogZnVuY3Rpb24gZGVmaW5lU2VydmljZShzZXJ2aWNlSWRlbnRpZmllciwgdmVyc2lvbnMsIGZlYXR1cmVzKSB7XG4gICAgQVdTLlNlcnZpY2UuX3NlcnZpY2VNYXBbc2VydmljZUlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVyc2lvbnMpKSB7XG4gICAgICBmZWF0dXJlcyA9IHZlcnNpb25zO1xuICAgICAgdmVyc2lvbnMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3ZjID0gaW5oZXJpdChBV1MuU2VydmljZSwgZmVhdHVyZXMgfHwge30pO1xuXG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlSWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIEFXUy5TZXJ2aWNlLmFkZFZlcnNpb25zKHN2YywgdmVyc2lvbnMpO1xuXG4gICAgICB2YXIgaWRlbnRpZmllciA9IHN2Yy5zZXJ2aWNlSWRlbnRpZmllciB8fCBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgIHN2Yy5zZXJ2aWNlSWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgfSBlbHNlIHsgLy8gZGVmaW5lU2VydmljZSBjYWxsZWQgd2l0aCBhbiBBUElcbiAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gc2VydmljZUlkZW50aWZpZXI7XG4gICAgICBBV1MuU2VydmljZS5kZWZpbmVNZXRob2RzKHN2Yyk7XG4gICAgfVxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbCh0aGlzLnByb3RvdHlwZSk7XG4gICAgLy91dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nIGlzIG9ubHkgYXZhaWxhYmxlIGluIG5vZGVcbiAgICBpZiAoIXRoaXMucHJvdG90eXBlLnB1Ymxpc2hlciAmJiBBV1MudXRpbC5jbGllbnRTaWRlTW9uaXRvcmluZykge1xuICAgICAgdmFyIFB1Ymxpc2hlciA9IEFXUy51dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nLlB1Ymxpc2hlcjtcbiAgICAgIHZhciBjb25maWdQcm92aWRlciA9IEFXUy51dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nLmNvbmZpZ1Byb3ZpZGVyO1xuICAgICAgdmFyIHB1Ymxpc2hlckNvbmZpZyA9IGNvbmZpZ1Byb3ZpZGVyKCk7XG4gICAgICB0aGlzLnByb3RvdHlwZS5wdWJsaXNoZXIgPSBuZXcgUHVibGlzaGVyKHB1Ymxpc2hlckNvbmZpZyk7XG4gICAgICBpZiAocHVibGlzaGVyQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgLy9pZiBjc20gaXMgZW5hYmxlZCBpbiBlbnZpcm9ubWVudCwgU0RLIHNob3VsZCBzZW5kIGFsbCBtZXRyaWNzXG4gICAgICAgIEFXUy5TZXJ2aWNlLl9jbGllbnRTaWRlTW9uaXRvcmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbChzdmMucHJvdG90eXBlKTtcbiAgICBBV1MuU2VydmljZS5hZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVycyhzdmMucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc3ZjO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZFZlcnNpb25zOiBmdW5jdGlvbiBhZGRWZXJzaW9ucyhzdmMsIHZlcnNpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZlcnNpb25zKSkgdmVyc2lvbnMgPSBbdmVyc2lvbnNdO1xuXG4gICAgc3ZjLnNlcnZpY2VzID0gc3ZjLnNlcnZpY2VzIHx8IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdmMuc2VydmljZXNbdmVyc2lvbnNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ZjLnNlcnZpY2VzW3ZlcnNpb25zW2ldXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3ZjLmFwaVZlcnNpb25zID0gT2JqZWN0LmtleXMoc3ZjLnNlcnZpY2VzKS5zb3J0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmaW5lU2VydmljZUFwaTogZnVuY3Rpb24gZGVmaW5lU2VydmljZUFwaShzdXBlcmNsYXNzLCB2ZXJzaW9uLCBhcGlDb25maWcpIHtcbiAgICB2YXIgc3ZjID0gaW5oZXJpdChzdXBlcmNsYXNzLCB7XG4gICAgICBzZXJ2aWNlSWRlbnRpZmllcjogc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0QXBpKGFwaSkge1xuICAgICAgaWYgKGFwaS5pc0FwaSkge1xuICAgICAgICBzdmMucHJvdG90eXBlLmFwaSA9IGFwaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gbmV3IEFwaShhcGksIHtcbiAgICAgICAgICBzZXJ2aWNlSWRlbnRpZmllcjogc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoYXBpQ29uZmlnKSB7XG4gICAgICAgIHNldEFwaShhcGlDb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXRBcGkoQVdTLmFwaUxvYWRlcihzdXBlcmNsYXNzLnNlcnZpY2VJZGVudGlmaWVyLCB2ZXJzaW9uKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKGVyciwge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBmaW5kIEFQSSBjb25maWd1cmF0aW9uICcgK1xuICAgICAgICAgICAgICBzdXBlcmNsYXNzLnNlcnZpY2VJZGVudGlmaWVyICsgJy0nICsgdmVyc2lvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdXBlcmNsYXNzLnNlcnZpY2VzLCB2ZXJzaW9uKSkge1xuICAgICAgICBzdXBlcmNsYXNzLmFwaVZlcnNpb25zID0gc3VwZXJjbGFzcy5hcGlWZXJzaW9ucy5jb25jYXQodmVyc2lvbikuc29ydCgpO1xuICAgICAgfVxuICAgICAgc3VwZXJjbGFzcy5zZXJ2aWNlc1t2ZXJzaW9uXSA9IHN2YztcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0QXBpKHZlcnNpb24pO1xuICAgIH1cblxuICAgIEFXUy5TZXJ2aWNlLmRlZmluZU1ldGhvZHMoc3ZjKTtcbiAgICByZXR1cm4gc3ZjO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhhc1NlcnZpY2U6IGZ1bmN0aW9uKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEFXUy5TZXJ2aWNlLl9zZXJ2aWNlTWFwLCBpZGVudGlmaWVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIGF0dGFjaE9uIGF0dGFjaCBkZWZhdWx0IG1vbml0b3JpbmcgbGlzdGVuZXJzIHRvIG9iamVjdFxuICAgKlxuICAgKiBFYWNoIG1vbml0b3JpbmcgZXZlbnQgc2hvdWxkIGJlIGVtaXR0ZWQgZnJvbSBzZXJ2aWNlIGNsaWVudCB0byBzZXJ2aWNlIGNvbnN0cnVjdG9yIHByb3RvdHlwZSBhbmQgdGhlblxuICAgKiB0byBnbG9iYWwgc2VydmljZSBwcm90b3R5cGUgbGlrZSBidWJibGluZyB1cC4gVGhlc2UgZGVmYXVsdCBtb25pdG9yaW5nIGV2ZW50cyBsaXN0ZW5lciB3aWxsIHRyYW5zZmVyXG4gICAqIHRoZSBtb25pdG9yaW5nIGV2ZW50cyB0byB0aGUgdXBwZXIgbGF5ZXIuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkRGVmYXVsdE1vbml0b3JpbmdMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzKGF0dGFjaE9uKSB7XG4gICAgYXR0YWNoT24uYWRkTmFtZWRMaXN0ZW5lcignTU9OSVRPUl9FVkVOVFNfQlVCQkxFJywgJ2FwaUNhbGxBdHRlbXB0JywgZnVuY3Rpb24gRVZFTlRTX0JVQkJMRShldmVudCkge1xuICAgICAgdmFyIGJhc2VDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhdHRhY2hPbik7XG4gICAgICBpZiAoYmFzZUNsYXNzLl9ldmVudHMpIGJhc2VDbGFzcy5lbWl0KCdhcGlDYWxsQXR0ZW1wdCcsIFtldmVudF0pO1xuICAgIH0pO1xuICAgIGF0dGFjaE9uLmFkZE5hbWVkTGlzdGVuZXIoJ0NBTExfRVZFTlRTX0JVQkJMRScsICdhcGlDYWxsJywgZnVuY3Rpb24gQ0FMTF9FVkVOVFNfQlVCQkxFKGV2ZW50KSB7XG4gICAgICB2YXIgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGF0dGFjaE9uKTtcbiAgICAgIGlmIChiYXNlQ2xhc3MuX2V2ZW50cykgYmFzZUNsYXNzLmVtaXQoJ2FwaUNhbGwnLCBbZXZlbnRdKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBfc2VydmljZU1hcDoge31cbn0pO1xuXG5BV1MudXRpbC5taXhpbihBV1MuU2VydmljZSwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcik7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNlcnZpY2U7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xucmVxdWlyZSgnLi4vZHluYW1vZGIvZG9jdW1lbnRfY2xpZW50Jyk7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuRHluYW1vREIucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVxdWVzdExpc3RlbmVyczogZnVuY3Rpb24gc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5keW5hbW9EYkNyYzMyKSB7XG4gICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdleHRyYWN0RGF0YScsIEFXUy5FdmVudExpc3RlbmVycy5Kc29uLkVYVFJBQ1RfREFUQSk7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdleHRyYWN0RGF0YScsIHRoaXMuY2hlY2tDcmMzMik7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdleHRyYWN0RGF0YScsIEFXUy5FdmVudExpc3RlbmVycy5Kc29uLkVYVFJBQ1RfREFUQSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNoZWNrQ3JjMzI6IGZ1bmN0aW9uIGNoZWNrQ3JjMzIocmVzcCkge1xuICAgIGlmICghcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtaW5nICYmICFyZXNwLnJlcXVlc3Quc2VydmljZS5jcmMzMklzVmFsaWQocmVzcCkpIHtcbiAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0NSQzMyQ2hlY2tGYWlsZWQnLFxuICAgICAgICBtZXNzYWdlOiAnQ1JDMzIgaW50ZWdyaXR5IGNoZWNrIGZhaWxlZCcsXG4gICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXNwLnJlcXVlc3QuaGFsdEhhbmRsZXJzT25FcnJvcigpO1xuICAgICAgdGhyb3cgKHJlc3AuZXJyb3IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmMzMklzVmFsaWQ6IGZ1bmN0aW9uIGNyYzMySXNWYWxpZChyZXNwKSB7XG4gICAgdmFyIGNyYyA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWNyYzMyJ107XG4gICAgaWYgKCFjcmMpIHJldHVybiB0cnVlOyAvLyBubyAodmFsaWQpIENSQzMyIGhlYWRlclxuICAgIHJldHVybiBwYXJzZUludChjcmMsIDEwKSA9PT0gQVdTLnV0aWwuY3J5cHRvLmNyYzMyKHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRSZXRyeUNvdW50OiAxMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXRyeURlbGF5czogZnVuY3Rpb24gcmV0cnlEZWxheXMocmV0cnlDb3VudCwgZXJyKSB7XG4gICAgdmFyIHJldHJ5RGVsYXlPcHRpb25zID0gQVdTLnV0aWwuY29weSh0aGlzLmNvbmZpZy5yZXRyeURlbGF5T3B0aW9ucyk7XG5cbiAgICBpZiAodHlwZW9mIHJldHJ5RGVsYXlPcHRpb25zLmJhc2UgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHJ5RGVsYXlPcHRpb25zLmJhc2UgPSA1MDsgLy8gZGVmYXVsdCBmb3IgZHluYW1vZGJcbiAgICB9XG4gICAgdmFyIGRlbGF5ID0gQVdTLnV0aWwuY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCByZXRyeURlbGF5T3B0aW9ucywgZXJyKTtcbiAgICByZXR1cm4gZGVsYXk7XG4gIH1cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnID0gcmVxdWlyZSgnLi4vY29uZmlnX3JlZ2lvbmFsX2VuZHBvaW50Jyk7XG52YXIgRU5WX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQgPSAnQVdTX1NUU19SRUdJT05BTF9FTkRQT0lOVFMnO1xudmFyIENPTkZJR19SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVEID0gJ3N0c19yZWdpb25hbF9lbmRwb2ludHMnO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLlNUUy5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEBvdmVybG9hZCBjcmVkZW50aWFsc0Zyb20oZGF0YSwgY3JlZGVudGlhbHMgPSBudWxsKVxuICAgKiAgIENyZWF0ZXMgYSBjcmVkZW50aWFscyBvYmplY3QgZnJvbSBTVFMgcmVzcG9uc2UgZGF0YSBjb250YWluaW5nXG4gICAqICAgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24uIFVzZWZ1bCBmb3IgcXVpY2tseSBzZXR0aW5nIEFXUyBjcmVkZW50aWFscy5cbiAgICpcbiAgICogICBAbm90ZSBUaGlzIGlzIGEgbG93LWxldmVsIHV0aWxpdHkgZnVuY3Rpb24uIElmIHlvdSB3YW50IHRvIGxvYWQgdGVtcG9yYXJ5XG4gICAqICAgICBjcmVkZW50aWFscyBpbnRvIHlvdXIgcHJvY2VzcyBmb3Igc3Vic2VxdWVudCByZXF1ZXN0cyB0byBBV1MgcmVzb3VyY2VzLFxuICAgKiAgICAgeW91IHNob3VsZCB1c2Uge0FXUy5UZW1wb3JhcnlDcmVkZW50aWFsc30gaW5zdGVhZC5cbiAgICogICBAcGFyYW0gZGF0YSBbbWFwXSBkYXRhIHJldHJpZXZlZCBmcm9tIGEgY2FsbCB0byB7Z2V0RmVkZXJhdGVkVG9rZW59LFxuICAgKiAgICAge2dldFNlc3Npb25Ub2tlbn0sIHthc3N1bWVSb2xlfSwgb3Ige2Fzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LlxuICAgKiAgIEBwYXJhbSBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSBhbiBvcHRpb25hbCBjcmVkZW50aWFscyBvYmplY3QgdG9cbiAgICogICAgIGZpbGwgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvYmplY3QuIFVzZWZ1bCB3aGVuIG1vZGlmeWluZyBhblxuICAgKiAgICAgZXhpc3RpbmcgY3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSByZWZyZXNoIGNhbGwuXG4gICAqICAgQHJldHVybiBbQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzXSB0aGUgc2V0IG9mIHRlbXBvcmFyeSBjcmVkZW50aWFsc1xuICAgKiAgICAgbG9hZGVkIGZyb20gYSByYXcgU1RTIG9wZXJhdGlvbiByZXNwb25zZS5cbiAgICogICBAZXhhbXBsZSBVc2luZyBjcmVkZW50aWFsc0Zyb20gdG8gbG9hZCBnbG9iYWwgQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgc3RzID0gbmV3IEFXUy5TVFMoKTtcbiAgICogICAgIHN0cy5nZXRTZXNzaW9uVG9rZW4oZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgKiAgICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhcIkVycm9yIGdldHRpbmcgY3JlZGVudGlhbHNcIik7XG4gICAqICAgICAgIGVsc2Uge1xuICAgKiAgICAgICAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBzdHMuY3JlZGVudGlhbHNGcm9tKGRhdGEpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9KTtcbiAgICogICBAc2VlIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFsc1xuICAgKi9cbiAgY3JlZGVudGlhbHNGcm9tOiBmdW5jdGlvbiBjcmVkZW50aWFsc0Zyb20oZGF0YSwgY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuICAgIGlmICghY3JlZGVudGlhbHMpIGNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICAgIGNyZWRlbnRpYWxzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCA9IGRhdGEuQ3JlZGVudGlhbHMuQWNjZXNzS2V5SWQ7XG4gICAgY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5ID0gZGF0YS5DcmVkZW50aWFscy5TZWNyZXRBY2Nlc3NLZXk7XG4gICAgY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuID0gZGF0YS5DcmVkZW50aWFscy5TZXNzaW9uVG9rZW47XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlVGltZSA9IGRhdGEuQ3JlZGVudGlhbHMuRXhwaXJhdGlvbjtcbiAgICByZXR1cm4gY3JlZGVudGlhbHM7XG4gIH0sXG5cbiAgYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eTogZnVuY3Rpb24gYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eShwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2Fzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHknLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBhc3N1bWVSb2xlV2l0aFNBTUw6IGZ1bmN0aW9uIGFzc3VtZVJvbGVXaXRoU0FNTChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2Fzc3VtZVJvbGVXaXRoU0FNTCcsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVxdWVzdExpc3RlbmVyczogZnVuY3Rpb24gc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMub3B0SW5SZWdpb25hbEVuZHBvaW50LCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBvcHRJblJlZ2lvbmFsRW5kcG9pbnQ6IGZ1bmN0aW9uIG9wdEluUmVnaW9uYWxFbmRwb2ludChyZXEpIHtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBjb25maWcgPSBzZXJ2aWNlLmNvbmZpZztcbiAgICBjb25maWcuc3RzUmVnaW9uYWxFbmRwb2ludHMgPSByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnKHNlcnZpY2UuX29yaWdpbmFsQ29uZmlnLCB7XG4gICAgICBlbnY6IEVOVl9SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVELFxuICAgICAgc2hhcmVkQ29uZmlnOiBDT05GSUdfUkVHSU9OQUxfRU5EUE9JTlRfRU5BQkxFRCxcbiAgICAgIGNsaWVudENvbmZpZzogJ3N0c1JlZ2lvbmFsRW5kcG9pbnRzJ1xuICAgIH0pO1xuICAgIGlmIChcbiAgICAgIGNvbmZpZy5zdHNSZWdpb25hbEVuZHBvaW50cyA9PT0gJ3JlZ2lvbmFsJyAmJlxuICAgICAgc2VydmljZS5pc0dsb2JhbEVuZHBvaW50XG4gICAgKSB7XG4gICAgICAvL2NsaWVudCB3aWxsIHRocm93IGlmIHJlZ2lvbiBpcyBub3Qgc3VwcGxpZWQ7IHJlcXVlc3Qgd2lsbCBiZSBzaWduZWQgd2l0aCBzcGVjaWZpZWQgcmVnaW9uXG4gICAgICBpZiAoIWNvbmZpZy5yZWdpb24pIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAge2NvZGU6ICdDb25maWdFcnJvcicsIG1lc3NhZ2U6ICdNaXNzaW5nIHJlZ2lvbiBpbiBjb25maWcnfSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5zZXJ0UG9pbnQgPSBjb25maWcuZW5kcG9pbnQuaW5kZXhPZignLmFtYXpvbmF3cy5jb20nKTtcbiAgICAgIHZhciByZWdpb25hbEVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50LnN1YnN0cmluZygwLCBpbnNlcnRQb2ludCkgK1xuICAgICAgICAnLicgKyBjb25maWcucmVnaW9uICsgY29uZmlnLmVuZHBvaW50LnN1YnN0cmluZyhpbnNlcnRQb2ludCk7XG4gICAgICByZXEuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQocmVnaW9uYWxFbmRwb2ludCk7XG4gICAgICByZXEuaHR0cFJlcXVlc3QucmVnaW9uID0gY29uZmlnLnJlZ2lvbjtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgSW5pTG9hZGVyID0gcmVxdWlyZSgnLi9pbmktbG9hZGVyJykuSW5pTG9hZGVyO1xuLyoqXG4gKiBTaW5nbGV0b24gb2JqZWN0IHRvIGxvYWQgc3BlY2lmaWVkIGNvbmZpZy9jcmVkZW50aWFscyBmaWxlcy5cbiAqIEl0IHdpbGwgY2FjaGUgYWxsIHRoZSBmaWxlcyBldmVyIGxvYWRlZDtcbiAqL1xubW9kdWxlLmV4cG9ydHMuaW5pTG9hZGVyID0gbmV3IEluaUxvYWRlcigpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBvcyA9IHJlcXVpcmUoJ29zJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGVuYW1lLCBpc0NvbmZpZykge1xuICAgIHZhciBjb250ZW50ID0gQVdTLnV0aWwuaW5pLnBhcnNlKEFXUy51dGlsLnJlYWRGaWxlU3luYyhmaWxlbmFtZSkpO1xuICAgIHZhciB0bXBDb250ZW50ID0ge307XG4gICAgT2JqZWN0LmtleXMoY29udGVudCkuZm9yRWFjaChmdW5jdGlvbihwcm9maWxlTmFtZSkge1xuICAgICAgdmFyIHByb2ZpbGVDb250ZW50ID0gY29udGVudFtwcm9maWxlTmFtZV07XG4gICAgICBwcm9maWxlTmFtZSA9IGlzQ29uZmlnID8gcHJvZmlsZU5hbWUucmVwbGFjZSgvXnByb2ZpbGVcXHMvLCAnJykgOiBwcm9maWxlTmFtZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bXBDb250ZW50LCBwcm9maWxlTmFtZSwge1xuICAgICAgICB2YWx1ZTogcHJvZmlsZUNvbnRlbnQsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0bXBDb250ZW50O1xufVxuXG4vKipcbiAqIEluaSBmaWxlIGxvYWRlciBjbGFzcyB0aGUgc2FtZSBhcyB0aGF0IHVzZWQgaW4gdGhlIFNESy4gSXQgbG9hZHMgYW5kXG4gKiBwYXJzZXMgY29uZmlnIGFuZCBjcmVkZW50aWFscyBmaWxlcyBpbiAuaW5pIGZvcm1hdCBhbmQgY2FjaGUgdGhlIGNvbnRlbnRcbiAqIHRvIGFzc3VyZSBmaWxlcyBhcmUgb25seSByZWFkIG9uY2UuXG4gKiBOb3RlIHRoYXQgY2FsbGluZyBvcGVyYXRpb25zIG9uIHRoZSBpbnN0YW5jZSBpbnN0YW50aWF0ZWQgZnJvbSB0aGlzIGNsYXNzXG4gKiB3b24ndCBhZmZlY3QgdGhlIGJlaGF2aW9yIG9mIFNESyBzaW5jZSBTREsgdXNlcyBhbiBpbnRlcm5hbCBzaW5nbGV0b24gb2ZcbiAqIHRoaXMgY2xhc3MuXG4gKiBAIW1hY3JvIG5vYnJvd3NlclxuICovXG5BV1MuSW5pTG9hZGVyID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBJbmlMb2FkZXIoKSB7XG4gICAgdGhpcy5yZXNvbHZlZFByb2ZpbGVzID0ge307XG4gIH0sXG5cbiAgLyoqIFJlbW92ZSBhbGwgY2FjaGVkIGZpbGVzLiBVc2VkIGFmdGVyIGNvbmZpZyBmaWxlcyBhcmUgdXBkYXRlZC4gKi9cbiAgY2xlYXJDYWNoZWRGaWxlczogZnVuY3Rpb24gY2xlYXJDYWNoZWRGaWxlcygpIHtcbiAgICB0aGlzLnJlc29sdmVkUHJvZmlsZXMgPSB7fTtcbiAgfSxcblxuLyoqXG4gKiBMb2FkIGNvbmZpZ3VyYXRpb25zIGZyb20gY29uZmlnL2NyZWRlbnRpYWxzIGZpbGVzIGFuZCBjYWNoZSB0aGVtXG4gKiBmb3IgbGF0ZXIgdXNlLiBJZiBubyBmaWxlIGlzIHNwZWNpZmllZCBpdCB3aWxsIHRyeSB0byBsb2FkIGRlZmF1bHRcbiAqIGZpbGVzLlxuICogQHBhcmFtIG9wdGlvbnMgW21hcF0gaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgZmlsZVxuICogQG9wdGlvbiBvcHRpb25zIGZpbGVuYW1lIFtTdHJpbmddICgnfi8uYXdzL2NyZWRlbnRpYWxzJyBvciBkZWZpbmVkIGJ5XG4gKiAgIEFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSBwcm9jZXNzIGVudiB2YXIgb3IgJ34vLmF3cy9jb25maWcnIGlmXG4gKiAgIGlzQ29uZmlnIGlzIHNldCB0byB0cnVlKVxuICogICBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHJlYWQuXG4gKiBAb3B0aW9uIG9wdGlvbnMgaXNDb25maWcgW0Jvb2xlYW5dIChmYWxzZSkgVHJ1ZSB0byByZWFkIGNvbmZpZyBmaWxlLlxuICogQHJldHVybiBbbWFwPFN0cmluZyxTdHJpbmc+XSBvYmplY3QgY29udGFpbmluZyBjb250ZW50cyBmcm9tIGZpbGUgaW4ga2V5LXZhbHVlXG4gKiAgIHBhaXJzLlxuICovXG4gIGxvYWRGcm9tOiBmdW5jdGlvbiBsb2FkRnJvbShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGlzQ29uZmlnID0gb3B0aW9ucy5pc0NvbmZpZyA9PT0gdHJ1ZTtcbiAgICB2YXIgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lIHx8IHRoaXMuZ2V0RGVmYXVsdEZpbGVQYXRoKGlzQ29uZmlnKTtcbiAgICBpZiAoIXRoaXMucmVzb2x2ZWRQcm9maWxlc1tmaWxlbmFtZV0pIHtcbiAgICAgIHZhciBmaWxlQ29udGVudCA9IHRoaXMucGFyc2VGaWxlKGZpbGVuYW1lLCBpc0NvbmZpZyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yZXNvbHZlZFByb2ZpbGVzLCBmaWxlbmFtZSwgeyB2YWx1ZTogZmlsZUNvbnRlbnQgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUHJvZmlsZXNbZmlsZW5hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnNlRmlsZTogcGFyc2VGaWxlLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldERlZmF1bHRGaWxlUGF0aDogZnVuY3Rpb24gZ2V0RGVmYXVsdEZpbGVQYXRoKGlzQ29uZmlnKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbihcbiAgICAgIHRoaXMuZ2V0SG9tZURpcigpLFxuICAgICAgJy5hd3MnLFxuICAgICAgaXNDb25maWcgPyAnY29uZmlnJyA6ICdjcmVkZW50aWFscydcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldEhvbWVEaXI6IGZ1bmN0aW9uIGdldEhvbWVEaXIoKSB7XG4gICAgdmFyIGVudiA9IHByb2Nlc3MuZW52O1xuICAgIHZhciBob21lID0gZW52LkhPTUUgfHxcbiAgICAgIGVudi5VU0VSUFJPRklMRSB8fFxuICAgICAgKGVudi5IT01FUEFUSCA/ICgoZW52LkhPTUVEUklWRSB8fCAnQzovJykgKyBlbnYuSE9NRVBBVEgpIDogbnVsbCk7XG5cbiAgICBpZiAoaG9tZSkge1xuICAgICAgcmV0dXJuIGhvbWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcy5ob21lZGlyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3MuaG9tZWRpcigpO1xuICAgIH1cblxuICAgIHRocm93IEFXUy51dGlsLmVycm9yKFxuICAgICAgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCBjcmVkZW50aWFscywgSE9NRSBwYXRoIG5vdCBzZXQnKVxuICAgICk7XG4gIH1cbn0pO1xuXG52YXIgSW5pTG9hZGVyID0gQVdTLkluaUxvYWRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEluaUxvYWRlcjogSW5pTG9hZGVyLFxuICBwYXJzZUZpbGU6IHBhcnNlRmlsZSxcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgZXhwaXJlc0hlYWRlciA9ICdwcmVzaWduZWQtZXhwaXJlcyc7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZFVybEJ1aWxkZXIocmVxdWVzdCkge1xuICB2YXIgZXhwaXJlcyA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXTtcbiAgdmFyIHNpZ25lckNsYXNzID0gcmVxdWVzdC5zZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcXVlc3QpO1xuXG4gIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1VzZXItQWdlbnQnXTtcbiAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotVXNlci1BZ2VudCddO1xuXG4gIGlmIChzaWduZXJDbGFzcyA9PT0gQVdTLlNpZ25lcnMuVjQpIHtcbiAgICBpZiAoZXhwaXJlcyA+IDYwNDgwMCkgeyAvLyBvbmUgd2VlayBleHBpcnkgaXMgaW52YWxpZFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnUHJlc2lnbmluZyBkb2VzIG5vdCBzdXBwb3J0IGV4cGlyeSB0aW1lIGdyZWF0ZXIgJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGFuIGEgd2VlayB3aXRoIFNpZ1Y0IHNpZ25pbmcuJztcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkRXhwaXJ5VGltZScsIG1lc3NhZ2U6IG1lc3NhZ2UsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPSBleHBpcmVzO1xuICB9IGVsc2UgaWYgKHNpZ25lckNsYXNzID09PSBBV1MuU2lnbmVycy5TMykge1xuICAgIHZhciBub3cgPSByZXF1ZXN0LnNlcnZpY2UgPyByZXF1ZXN0LnNlcnZpY2UuZ2V0U2tld0NvcnJlY3RlZERhdGUoKSA6IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSA9IHBhcnNlSW50KFxuICAgICAgQVdTLnV0aWwuZGF0ZS51bml4VGltZXN0YW1wKG5vdykgKyBleHBpcmVzLCAxMCkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgbWVzc2FnZTogJ1ByZXNpZ25pbmcgb25seSBzdXBwb3J0cyBTMyBvciBTaWdWNCBzaWduaW5nLicsXG4gICAgICBjb2RlOiAnVW5zdXBwb3J0ZWRTaWduZXInLCByZXRyeWFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2lnbmVkVXJsU2lnbmVyKHJlcXVlc3QpIHtcbiAgdmFyIGVuZHBvaW50ID0gcmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludDtcbiAgdmFyIHBhcnNlZFVybCA9IEFXUy51dGlsLnVybFBhcnNlKHJlcXVlc3QuaHR0cFJlcXVlc3QucGF0aCk7XG4gIHZhciBxdWVyeVBhcmFtcyA9IHt9O1xuXG4gIGlmIChwYXJzZWRVcmwuc2VhcmNoKSB7XG4gICAgcXVlcnlQYXJhbXMgPSBBV1MudXRpbC5xdWVyeVN0cmluZ1BhcnNlKHBhcnNlZFVybC5zZWFyY2guc3Vic3RyKDEpKTtcbiAgfVxuXG4gIHZhciBhdXRoID0gcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10uc3BsaXQoJyAnKTtcbiAgaWYgKGF1dGhbMF0gPT09ICdBV1MnKSB7XG4gICAgYXV0aCA9IGF1dGhbMV0uc3BsaXQoJzonKTtcbiAgICBxdWVyeVBhcmFtc1snU2lnbmF0dXJlJ10gPSBhdXRoLnBvcCgpO1xuICAgIHF1ZXJ5UGFyYW1zWydBV1NBY2Nlc3NLZXlJZCddID0gYXV0aC5qb2luKCc6Jyk7XG5cbiAgICBBV1MudXRpbC5lYWNoKHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT09IGV4cGlyZXNIZWFkZXIpIGtleSA9ICdFeHBpcmVzJztcbiAgICAgIGlmIChrZXkuaW5kZXhPZigneC1hbXotbWV0YS0nKSA9PT0gMCkge1xuICAgICAgICAvLyBEZWxldGUgZXhpc3RpbmcsIHBvdGVudGlhbGx5IG5vdCBub3JtYWxpemVkIGtleVxuICAgICAgICBkZWxldGUgcXVlcnlQYXJhbXNba2V5XTtcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXTtcbiAgICBkZWxldGUgcXVlcnlQYXJhbXNbJ0F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgcXVlcnlQYXJhbXNbJ0hvc3QnXTtcbiAgfSBlbHNlIGlmIChhdXRoWzBdID09PSAnQVdTNC1ITUFDLVNIQTI1NicpIHsgLy8gU2lnVjQgc2lnbmluZ1xuICAgIGF1dGguc2hpZnQoKTtcbiAgICB2YXIgcmVzdCA9IGF1dGguam9pbignICcpO1xuICAgIHZhciBzaWduYXR1cmUgPSByZXN0Lm1hdGNoKC9TaWduYXR1cmU9KC4qPykoPzosfFxcc3xcXHI/XFxufCQpLylbMV07XG4gICAgcXVlcnlQYXJhbXNbJ1gtQW16LVNpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuICAgIGRlbGV0ZSBxdWVyeVBhcmFtc1snRXhwaXJlcyddO1xuICB9XG5cbiAgLy8gYnVpbGQgVVJMXG4gIGVuZHBvaW50LnBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICBlbmRwb2ludC5zZWFyY2ggPSBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHF1ZXJ5UGFyYW1zKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuUHJlc2lnbiA9IGluaGVyaXQoe1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaWduOiBmdW5jdGlvbiBzaWduKHJlcXVlc3QsIGV4cGlyZVRpbWUsIGNhbGxiYWNrKSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gZXhwaXJlVGltZSB8fCAzNjAwO1xuICAgIHJlcXVlc3Qub24oJ2J1aWxkJywgc2lnbmVkVXJsQnVpbGRlcik7XG4gICAgcmVxdWVzdC5vbignc2lnbicsIHNpZ25lZFVybFNpZ25lcik7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsXG4gICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TRVRfQ09OVEVOVF9MRU5HVEgpO1xuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLFxuICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuQ09NUFVURV9TSEEyNTYpO1xuXG4gICAgcmVxdWVzdC5lbWl0KCdiZWZvcmVQcmVzaWduJywgW3JlcXVlc3RdKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgcmVxdWVzdC5idWlsZChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UuZXJyb3IpIGNhbGxiYWNrKHRoaXMucmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBBV1MudXRpbC51cmxGb3JtYXQocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5idWlsZCgpO1xuICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2UuZXJyb3IpIHRocm93IHJlcXVlc3QucmVzcG9uc2UuZXJyb3I7XG4gICAgICByZXR1cm4gQVdTLnV0aWwudXJsRm9ybWF0KHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuUHJlc2lnbjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciA9IGluaGVyaXQoe1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUmVxdWVzdFNpZ25lcihyZXF1ZXN0KSB7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgfSxcblxuICBzZXRTZXJ2aWNlQ2xpZW50SWQ6IGZ1bmN0aW9uIHNldFNlcnZpY2VDbGllbnRJZChpZCkge1xuICAgIHRoaXMuc2VydmljZUNsaWVudElkID0gaWQ7XG4gIH0sXG5cbiAgZ2V0U2VydmljZUNsaWVudElkOiBmdW5jdGlvbiBnZXRTZXJ2aWNlQ2xpZW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZUNsaWVudElkO1xuICB9XG59KTtcblxuQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5nZXRWZXJzaW9uID0gZnVuY3Rpb24gZ2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgJ3YyJzogcmV0dXJuIEFXUy5TaWduZXJzLlYyO1xuICAgIGNhc2UgJ3YzJzogcmV0dXJuIEFXUy5TaWduZXJzLlYzO1xuICAgIGNhc2UgJ3MzdjQnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjQ7XG4gICAgY2FzZSAndjQnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjQ7XG4gICAgY2FzZSAnczMnOiByZXR1cm4gQVdTLlNpZ25lcnMuUzM7XG4gICAgY2FzZSAndjNodHRwcyc6IHJldHVybiBBV1MuU2lnbmVycy5WM0h0dHBzO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduaW5nIHZlcnNpb24gJyArIHZlcnNpb24pO1xufTtcblxucmVxdWlyZSgnLi92MicpO1xucmVxdWlyZSgnLi92MycpO1xucmVxdWlyZSgnLi92M2h0dHBzJyk7XG5yZXF1aXJlKCcuL3Y0Jyk7XG5yZXF1aXJlKCcuL3MzJyk7XG5yZXF1aXJlKCcuL3ByZXNpZ24nKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlMzID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIC8qKlxuICAgKiBXaGVuIGJ1aWxkaW5nIHRoZSBzdHJpbmdUb1NpZ24sIHRoZXNlIHN1YiByZXNvdXJjZSBwYXJhbXMgc2hvdWxkIGJlXG4gICAqIHBhcnQgb2YgdGhlIGNhbm9uaWNhbCByZXNvdXJjZSBzdHJpbmcgd2l0aCB0aGVpciBOT04tZGVjb2RlZCB2YWx1ZXNcbiAgICovXG4gIHN1YlJlc291cmNlczoge1xuICAgICdhY2wnOiAxLFxuICAgICdhY2NlbGVyYXRlJzogMSxcbiAgICAnYW5hbHl0aWNzJzogMSxcbiAgICAnY29ycyc6IDEsXG4gICAgJ2xpZmVjeWNsZSc6IDEsXG4gICAgJ2RlbGV0ZSc6IDEsXG4gICAgJ2ludmVudG9yeSc6IDEsXG4gICAgJ2xvY2F0aW9uJzogMSxcbiAgICAnbG9nZ2luZyc6IDEsXG4gICAgJ21ldHJpY3MnOiAxLFxuICAgICdub3RpZmljYXRpb24nOiAxLFxuICAgICdwYXJ0TnVtYmVyJzogMSxcbiAgICAncG9saWN5JzogMSxcbiAgICAncmVxdWVzdFBheW1lbnQnOiAxLFxuICAgICdyZXBsaWNhdGlvbic6IDEsXG4gICAgJ3Jlc3RvcmUnOiAxLFxuICAgICd0YWdnaW5nJzogMSxcbiAgICAndG9ycmVudCc6IDEsXG4gICAgJ3VwbG9hZElkJzogMSxcbiAgICAndXBsb2Fkcyc6IDEsXG4gICAgJ3ZlcnNpb25JZCc6IDEsXG4gICAgJ3ZlcnNpb25pbmcnOiAxLFxuICAgICd2ZXJzaW9ucyc6IDEsXG4gICAgJ3dlYnNpdGUnOiAxXG4gIH0sXG5cbiAgLy8gd2hlbiBidWlsZGluZyB0aGUgc3RyaW5nVG9TaWduLCB0aGVzZSBxdWVyeXN0cmluZyBwYXJhbXMgc2hvdWxkIGJlXG4gIC8vIHBhcnQgb2YgdGhlIGNhbm9uaWNhbCByZXNvdXJjZSBzdHJpbmcgd2l0aCB0aGVpciBOT04tZW5jb2RlZCB2YWx1ZXNcbiAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtdHlwZSc6IDEsXG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtbGFuZ3VhZ2UnOiAxLFxuICAgICdyZXNwb25zZS1leHBpcmVzJzogMSxcbiAgICAncmVzcG9uc2UtY2FjaGUtY29udHJvbCc6IDEsXG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtZGlzcG9zaXRpb24nOiAxLFxuICAgICdyZXNwb25zZS1jb250ZW50LWVuY29kaW5nJzogMVxuICB9LFxuXG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcbiAgICBpZiAoIXRoaXMucmVxdWVzdC5oZWFkZXJzWydwcmVzaWduZWQtZXhwaXJlcyddKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddID0gQVdTLnV0aWwuZGF0ZS5yZmM4MjIoZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgLy8gcHJlc2lnbmVkIFVSTHMgcmVxdWlyZSB0aGlzIGhlYWRlciB0byBiZSBsb3dlcmNhc2VkXG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5zaWduKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSk7XG4gICAgdmFyIGF1dGggPSAnQVdTICcgKyBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICc6JyArIHNpZ25hdHVyZTtcblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBhdXRoO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciByID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgcGFydHMucHVzaChyLm1ldGhvZCk7XG4gICAgcGFydHMucHVzaChyLmhlYWRlcnNbJ0NvbnRlbnQtTUQ1J10gfHwgJycpO1xuICAgIHBhcnRzLnB1c2goci5oZWFkZXJzWydDb250ZW50LVR5cGUnXSB8fCAnJyk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBcIkRhdGVcIiBoZWFkZXIsIGJ1dCB3ZSB1c2UgWC1BbXotRGF0ZS5cbiAgICAvLyBUaGUgUzMgc2lnbmluZyBtZWNoYW5pc20gcmVxdWlyZXMgdXMgdG8gcGFzcyBhbiBlbXB0eVxuICAgIC8vIHN0cmluZyBmb3IgdGhpcyBEYXRlIGhlYWRlciByZWdhcmRsZXNzLlxuICAgIHBhcnRzLnB1c2goci5oZWFkZXJzWydwcmVzaWduZWQtZXhwaXJlcyddIHx8ICcnKTtcblxuICAgIHZhciBoZWFkZXJzID0gdGhpcy5jYW5vbmljYWxpemVkQW16SGVhZGVycygpO1xuICAgIGlmIChoZWFkZXJzKSBwYXJ0cy5wdXNoKGhlYWRlcnMpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxpemVkUmVzb3VyY2UoKSk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG5cbiAgfSxcblxuICBjYW5vbmljYWxpemVkQW16SGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsaXplZEFtekhlYWRlcnMoKSB7XG5cbiAgICB2YXIgYW16SGVhZGVycyA9IFtdO1xuXG4gICAgQVdTLnV0aWwuZWFjaCh0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLm1hdGNoKC9eeC1hbXotL2kpKVxuICAgICAgICBhbXpIZWFkZXJzLnB1c2gobmFtZSk7XG4gICAgfSk7XG5cbiAgICBhbXpIZWFkZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkgPyAtMSA6IDE7XG4gICAgfSk7XG5cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBhbXpIZWFkZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcGFydHMucHVzaChuYW1lLnRvTG93ZXJDYXNlKCkgKyAnOicgKyBTdHJpbmcodGhpcy5yZXF1ZXN0LmhlYWRlcnNbbmFtZV0pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcblxuICB9LFxuXG4gIGNhbm9uaWNhbGl6ZWRSZXNvdXJjZTogZnVuY3Rpb24gY2Fub25pY2FsaXplZFJlc291cmNlKCkge1xuXG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICB2YXIgcGFydHMgPSByLnBhdGguc3BsaXQoJz8nKTtcbiAgICB2YXIgcGF0aCA9IHBhcnRzWzBdO1xuICAgIHZhciBxdWVyeXN0cmluZyA9IHBhcnRzWzFdO1xuXG4gICAgdmFyIHJlc291cmNlID0gJyc7XG5cbiAgICBpZiAoci52aXJ0dWFsSG9zdGVkQnVja2V0KVxuICAgICAgcmVzb3VyY2UgKz0gJy8nICsgci52aXJ0dWFsSG9zdGVkQnVja2V0O1xuXG4gICAgcmVzb3VyY2UgKz0gcGF0aDtcblxuICAgIGlmIChxdWVyeXN0cmluZykge1xuXG4gICAgICAvLyBjb2xsZWN0IGEgbGlzdCBvZiBzdWIgcmVzb3VyY2VzIGFuZCBxdWVyeSBwYXJhbXMgdGhhdCBuZWVkIHRvIGJlIHNpZ25lZFxuICAgICAgdmFyIHJlc291cmNlcyA9IFtdO1xuXG4gICAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBxdWVyeXN0cmluZy5zcGxpdCgnJicpLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJhbS5zcGxpdCgnPScpWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbS5zcGxpdCgnPScpWzFdO1xuICAgICAgICBpZiAodGhpcy5zdWJSZXNvdXJjZXNbbmFtZV0gfHwgdGhpcy5yZXNwb25zZUhlYWRlcnNbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgc3VicmVzb3VyY2UgPSB7IG5hbWU6IG5hbWUgfTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViUmVzb3VyY2VzW25hbWVdKSB7XG4gICAgICAgICAgICAgIHN1YnJlc291cmNlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJyZXNvdXJjZS52YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc291cmNlcy5wdXNoKHN1YnJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlc291cmNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDE7IH0pO1xuXG4gICAgICBpZiAocmVzb3VyY2VzLmxlbmd0aCkge1xuXG4gICAgICAgIHF1ZXJ5c3RyaW5nID0gW107XG4gICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICBpZiAocmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnB1c2gocmVzLm5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeXN0cmluZy5wdXNoKHJlcy5uYW1lICsgJz0nICsgcmVzLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc291cmNlICs9ICc/JyArIHF1ZXJ5c3RyaW5nLmpvaW4oJyYnKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiByZXNvdXJjZTtcblxuICB9LFxuXG4gIHNpZ246IGZ1bmN0aW9uIHNpZ24oc2VjcmV0LCBzdHJpbmcpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoc2VjcmV0LCBzdHJpbmcsICdiYXNlNjQnLCAnc2hhMScpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5TMztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYyID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcblxuICAgIGlmICghZGF0ZSkgZGF0ZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICByLnBhcmFtcy5UaW1lc3RhbXAgPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEoZGF0ZSk7XG4gICAgci5wYXJhbXMuU2lnbmF0dXJlVmVyc2lvbiA9ICcyJztcbiAgICByLnBhcmFtcy5TaWduYXR1cmVNZXRob2QgPSAnSG1hY1NIQTI1Nic7XG4gICAgci5wYXJhbXMuQVdTQWNjZXNzS2V5SWQgPSBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHIucGFyYW1zLlNlY3VyaXR5VG9rZW4gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgZGVsZXRlIHIucGFyYW1zLlNpZ25hdHVyZTsgLy8gZGVsZXRlIG9sZCBTaWduYXR1cmUgZm9yIHJlLXNpZ25pbmdcbiAgICByLnBhcmFtcy5TaWduYXR1cmUgPSB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscyk7XG5cbiAgICByLmJvZHkgPSBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHIucGFyYW1zKTtcbiAgICByLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSByLmJvZHkubGVuZ3RoO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSwgJ2Jhc2U2NCcpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QuZW5kcG9pbnQuaG9zdC50b0xvd2VyQ2FzZSgpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5wYXRobmFtZSgpKTtcbiAgICBwYXJ0cy5wdXNoKEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcodGhpcy5yZXF1ZXN0LnBhcmFtcykpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WMjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYzID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcblxuICAgIHZhciBkYXRldGltZSA9IEFXUy51dGlsLmRhdGUucmZjODIyKGRhdGUpO1xuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXSA9IGRhdGV0aW1lO1xuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16bi1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgdGhpcy5hdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG5cbiAgfSxcblxuICBhdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuICdBV1MzICcgK1xuICAgICAgJ0FXU0FjY2Vzc0tleUlkPScgKyBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcsJyArXG4gICAgICAnQWxnb3JpdGhtPUhtYWNTSEEyNTYsJyArXG4gICAgICAnU2lnbmVkSGVhZGVycz0nICsgdGhpcy5zaWduZWRIZWFkZXJzKCkgKyAnLCcgK1xuICAgICAgJ1NpZ25hdHVyZT0nICsgdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuICB9LFxuXG4gIHNpZ25lZEhlYWRlcnM6IGZ1bmN0aW9uIHNpZ25lZEhlYWRlcnMoKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2godGhpcy5oZWFkZXJzVG9TaWduKCksIGZ1bmN0aW9uIGl0ZXJhdG9yKGgpIHtcbiAgICAgIGhlYWRlcnMucHVzaChoLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzLnNvcnQoKS5qb2luKCc7Jyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsSGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVycygpIHtcbiAgICB2YXIgaGVhZGVycyA9IHRoaXMucmVxdWVzdC5oZWFkZXJzO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaCh0aGlzLmhlYWRlcnNUb1NpZ24oKSwgZnVuY3Rpb24gaXRlcmF0b3IoaCkge1xuICAgICAgcGFydHMucHVzaChoLnRvTG93ZXJDYXNlKCkudHJpbSgpICsgJzonICsgU3RyaW5nKGhlYWRlcnNbaF0pLnRyaW0oKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzLnNvcnQoKS5qb2luKCdcXG4nKSArICdcXG4nO1xuICB9LFxuXG4gIGhlYWRlcnNUb1NpZ246IGZ1bmN0aW9uIGhlYWRlcnNUb1NpZ24oKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcbiAgICBBV1MudXRpbC5lYWNoKHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiBpdGVyYXRvcihrKSB7XG4gICAgICBpZiAoayA9PT0gJ0hvc3QnIHx8IGsgPT09ICdDb250ZW50LUVuY29kaW5nJyB8fCBrLm1hdGNoKC9eWC1BbXovaSkpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGspO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSwgJ2Jhc2U2NCcpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaCgnLycpO1xuICAgIHBhcnRzLnB1c2goJycpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxIZWFkZXJzKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0LmJvZHkpO1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uc2hhMjU2KHBhcnRzLmpvaW4oJ1xcbicpKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WMztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbnJlcXVpcmUoJy4vdjMnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjNIdHRwcyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuVjMsIHtcbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscykge1xuICAgIHJldHVybiAnQVdTMy1IVFRQUyAnICtcbiAgICAgICdBV1NBY2Nlc3NLZXlJZD0nICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLCcgK1xuICAgICAgJ0FsZ29yaXRobT1IbWFjU0hBMjU2LCcgK1xuICAgICAgJ1NpZ25hdHVyZT0nICsgdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WM0h0dHBzO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB2NENyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi92NF9jcmVkZW50aWFscycpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgZXhwaXJlc0hlYWRlciA9ICdwcmVzaWduZWQtZXhwaXJlcyc7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlY0ID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBWNChyZXF1ZXN0LCBzZXJ2aWNlTmFtZSwgb3B0aW9ucykge1xuICAgIEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuY2FsbCh0aGlzLCByZXF1ZXN0KTtcbiAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zaWduYXR1cmVDYWNoZSA9IHR5cGVvZiBvcHRpb25zLnNpZ25hdHVyZUNhY2hlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNpZ25hdHVyZUNhY2hlIDogdHJ1ZTtcbiAgICB0aGlzLm9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uO1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyc2lvbiA9IG9wdGlvbnMuc2lnbmF0dXJlVmVyc2lvbjtcbiAgfSxcblxuICBhbGdvcml0aG06ICdBV1M0LUhNQUMtU0hBMjU2JyxcblxuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG4gICAgdmFyIGRhdGV0aW1lID0gQVdTLnV0aWwuZGF0ZS5pc284NjAxKGRhdGUpLnJlcGxhY2UoL1s6XFwtXXxcXC5cXGR7M30vZywgJycpO1xuXG4gICAgaWYgKHRoaXMuaXNQcmVzaWduZWQoKSkge1xuICAgICAgdGhpcy51cGRhdGVGb3JQcmVzaWduZWQoY3JlZGVudGlhbHMsIGRhdGV0aW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRIZWFkZXJzKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9XG4gICAgICB0aGlzLmF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGV0aW1lKTtcbiAgfSxcblxuICBhZGRIZWFkZXJzOiBmdW5jdGlvbiBhZGRIZWFkZXJzKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBkYXRldGltZTtcbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlRm9yUHJlc2lnbmVkOiBmdW5jdGlvbiB1cGRhdGVGb3JQcmVzaWduZWQoY3JlZGVudGlhbHMsIGRhdGV0aW1lKSB7XG4gICAgdmFyIGNyZWRTdHJpbmcgPSB0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpO1xuICAgIHZhciBxcyA9IHtcbiAgICAgICdYLUFtei1EYXRlJzogZGF0ZXRpbWUsXG4gICAgICAnWC1BbXotQWxnb3JpdGhtJzogdGhpcy5hbGdvcml0aG0sXG4gICAgICAnWC1BbXotQ3JlZGVudGlhbCc6IGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJy8nICsgY3JlZFN0cmluZyxcbiAgICAgICdYLUFtei1FeHBpcmVzJzogdGhpcy5yZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0sXG4gICAgICAnWC1BbXotU2lnbmVkSGVhZGVycyc6IHRoaXMuc2lnbmVkSGVhZGVycygpXG4gICAgfTtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHFzWydYLUFtei1TZWN1cml0eS1Ub2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pIHtcbiAgICAgIHFzWydDb250ZW50LVR5cGUnXSA9IHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LU1ENSddKSB7XG4gICAgICBxc1snQ29udGVudC1NRDUnXSA9IHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LU1ENSddO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXSkge1xuICAgICAgcXNbJ0NhY2hlLUNvbnRyb2wnXSA9IHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWNoZS1Db250cm9sJ107XG4gICAgfVxuXG4gICAgLy8gbmVlZCB0byBwdWxsIGluIGFueSBvdGhlciBYLUFtei0qIGhlYWRlcnNcbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT09IGV4cGlyZXNIZWFkZXIpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzU2lnbmFibGVIZWFkZXIoa2V5KSkge1xuICAgICAgICB2YXIgbG93ZXJLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gTWV0YWRhdGEgc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgICAgICAgaWYgKGxvd2VyS2V5LmluZGV4T2YoJ3gtYW16LW1ldGEtJykgPT09IDApIHtcbiAgICAgICAgICBxc1tsb3dlcktleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChsb3dlcktleS5pbmRleE9mKCd4LWFtei0nKSA9PT0gMCkge1xuICAgICAgICAgIHFzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHNlcCA9IHRoaXMucmVxdWVzdC5wYXRoLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nO1xuICAgIHRoaXMucmVxdWVzdC5wYXRoICs9IHNlcCArIEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXMpO1xuICB9LFxuXG4gIGF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGV0aW1lKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIGNyZWRTdHJpbmcgPSB0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpO1xuICAgIHBhcnRzLnB1c2godGhpcy5hbGdvcml0aG0gKyAnIENyZWRlbnRpYWw9JyArXG4gICAgICBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIGNyZWRTdHJpbmcpO1xuICAgIHBhcnRzLnB1c2goJ1NpZ25lZEhlYWRlcnM9JyArIHRoaXMuc2lnbmVkSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKCdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzLCBkYXRldGltZSkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcsICcpO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBzaWduaW5nS2V5ID0gdjRDcmVkZW50aWFscy5nZXRTaWduaW5nS2V5KFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBkYXRldGltZS5zdWJzdHIoMCwgOCksXG4gICAgICB0aGlzLnJlcXVlc3QucmVnaW9uLFxuICAgICAgdGhpcy5zZXJ2aWNlTmFtZSxcbiAgICAgIHRoaXMuc2lnbmF0dXJlQ2FjaGVcbiAgICApO1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhzaWduaW5nS2V5LCB0aGlzLnN0cmluZ1RvU2lnbihkYXRldGltZSksICdoZXgnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbihkYXRldGltZSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2goJ0FXUzQtSE1BQy1TSEEyNTYnKTtcbiAgICBwYXJ0cy5wdXNoKGRhdGV0aW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5oZXhFbmNvZGVkSGFzaCh0aGlzLmNhbm9uaWNhbFN0cmluZygpKSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGNhbm9uaWNhbFN0cmluZzogZnVuY3Rpb24gY2Fub25pY2FsU3RyaW5nKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdLCBwYXRobmFtZSA9IHRoaXMucmVxdWVzdC5wYXRobmFtZSgpO1xuICAgIGlmICh0aGlzLnNlcnZpY2VOYW1lICE9PSAnczMnICYmIHRoaXMuc2lnbmF0dXJlVmVyc2lvbiAhPT0gJ3MzdjQnKSBwYXRobmFtZSA9IEFXUy51dGlsLnVyaUVzY2FwZVBhdGgocGF0aG5hbWUpO1xuXG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QubWV0aG9kKTtcbiAgICBwYXJ0cy5wdXNoKHBhdGhuYW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5zZWFyY2goKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNhbm9uaWNhbEhlYWRlcnMoKSArICdcXG4nKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuc2lnbmVkSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuaGV4RW5jb2RlZEJvZHlIYXNoKCkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxIZWFkZXJzOiBmdW5jdGlvbiBjYW5vbmljYWxIZWFkZXJzKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5LCBpdGVtKSB7XG4gICAgICBoZWFkZXJzLnB1c2goW2tleSwgaXRlbV0pO1xuICAgIH0pO1xuICAgIGhlYWRlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0udG9Mb3dlckNhc2UoKSA8IGJbMF0udG9Mb3dlckNhc2UoKSA/IC0xIDogMTtcbiAgICB9KTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBoZWFkZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGtleSA9IGl0ZW1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLmlzU2lnbmFibGVIZWFkZXIoa2V5KSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtWzFdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ0hlYWRlciAnICsga2V5ICsgJyBjb250YWlucyBpbnZhbGlkIHZhbHVlJyksIHtcbiAgICAgICAgICAgIGNvZGU6ICdJbnZhbGlkSGVhZGVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goa2V5ICsgJzonICtcbiAgICAgICAgICB0aGlzLmNhbm9uaWNhbEhlYWRlclZhbHVlcyh2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGNhbm9uaWNhbEhlYWRlclZhbHVlczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVyVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgfSxcblxuICBzaWduZWRIZWFkZXJzOiBmdW5jdGlvbiBzaWduZWRIZWFkZXJzKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLmlzU2lnbmFibGVIZWFkZXIoa2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGtleXMuc29ydCgpLmpvaW4oJzsnKTtcbiAgfSxcblxuICBjcmVkZW50aWFsU3RyaW5nOiBmdW5jdGlvbiBjcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKSB7XG4gICAgcmV0dXJuIHY0Q3JlZGVudGlhbHMuY3JlYXRlU2NvcGUoXG4gICAgICBkYXRldGltZS5zdWJzdHIoMCwgOCksXG4gICAgICB0aGlzLnJlcXVlc3QucmVnaW9uLFxuICAgICAgdGhpcy5zZXJ2aWNlTmFtZVxuICAgICk7XG4gIH0sXG5cbiAgaGV4RW5jb2RlZEhhc2g6IGZ1bmN0aW9uIGhhc2goc3RyaW5nKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5zaGEyNTYoc3RyaW5nLCAnaGV4Jyk7XG4gIH0sXG5cbiAgaGV4RW5jb2RlZEJvZHlIYXNoOiBmdW5jdGlvbiBoZXhFbmNvZGVkQm9keUhhc2goKSB7XG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3Q7XG4gICAgaWYgKHRoaXMuaXNQcmVzaWduZWQoKSAmJiAoWydzMycsICdzMy1vYmplY3QtbGFtYmRhJ10uaW5kZXhPZih0aGlzLnNlcnZpY2VOYW1lKSA+IC0xKSAmJiAhcmVxdWVzdC5ib2R5KSB7XG4gICAgICByZXR1cm4gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oZXhFbmNvZGVkSGFzaCh0aGlzLnJlcXVlc3QuYm9keSB8fCAnJyk7XG4gICAgfVxuICB9LFxuXG4gIHVuc2lnbmFibGVIZWFkZXJzOiBbXG4gICAgJ2F1dGhvcml6YXRpb24nLFxuICAgICdjb250ZW50LXR5cGUnLFxuICAgICdjb250ZW50LWxlbmd0aCcsXG4gICAgJ3VzZXItYWdlbnQnLFxuICAgIGV4cGlyZXNIZWFkZXIsXG4gICAgJ2V4cGVjdCcsXG4gICAgJ3gtYW16bi10cmFjZS1pZCdcbiAgXSxcblxuICBpc1NpZ25hYmxlSGVhZGVyOiBmdW5jdGlvbiBpc1NpZ25hYmxlSGVhZGVyKGtleSkge1xuICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd4LWFtei0nKSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduYWJsZUhlYWRlcnMuaW5kZXhPZihrZXkpIDwgMDtcbiAgfSxcblxuICBpc1ByZXNpZ25lZDogZnVuY3Rpb24gaXNQcmVzaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlY0O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGNhY2hlZFNlY3JldCA9IHt9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgY2FjaGVRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgbWF4Q2FjaGVFbnRyaWVzID0gNTA7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciB2NElkZW50aWZpZXIgPSAnYXdzNF9yZXF1ZXN0JztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIGRhdGUgW1N0cmluZ11cbiAgICogQHBhcmFtIHJlZ2lvbiBbU3RyaW5nXVxuICAgKiBAcGFyYW0gc2VydmljZU5hbWUgW1N0cmluZ11cbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgY3JlYXRlU2NvcGU6IGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKGRhdGUsIHJlZ2lvbiwgc2VydmljZU5hbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZGF0ZS5zdWJzdHIoMCwgOCksXG4gICAgICByZWdpb24sXG4gICAgICBzZXJ2aWNlTmFtZSxcbiAgICAgIHY0SWRlbnRpZmllclxuICAgIF0uam9pbignLycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFtDcmVkZW50aWFsc11cbiAgICogQHBhcmFtIGRhdGUgW1N0cmluZ11cbiAgICogQHBhcmFtIHJlZ2lvbiBbU3RyaW5nXVxuICAgKiBAcGFyYW0gc2VydmljZSBbU3RyaW5nXVxuICAgKiBAcGFyYW0gc2hvdWxkQ2FjaGUgW0Jvb2xlYW5dXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIGdldFNpZ25pbmdLZXk6IGZ1bmN0aW9uIGdldFNpZ25pbmdLZXkoXG4gICAgY3JlZGVudGlhbHMsXG4gICAgZGF0ZSxcbiAgICByZWdpb24sXG4gICAgc2VydmljZSxcbiAgICBzaG91bGRDYWNoZVxuICApIHtcbiAgICB2YXIgY3JlZHNJZGVudGlmaWVyID0gQVdTLnV0aWwuY3J5cHRvXG4gICAgICAuaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkLCAnYmFzZTY0Jyk7XG4gICAgdmFyIGNhY2hlS2V5ID0gW2NyZWRzSWRlbnRpZmllciwgZGF0ZSwgcmVnaW9uLCBzZXJ2aWNlXS5qb2luKCdfJyk7XG4gICAgc2hvdWxkQ2FjaGUgPSBzaG91bGRDYWNoZSAhPT0gZmFsc2U7XG4gICAgaWYgKHNob3VsZENhY2hlICYmIChjYWNoZUtleSBpbiBjYWNoZWRTZWNyZXQpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkU2VjcmV0W2NhY2hlS2V5XTtcbiAgICB9XG5cbiAgICB2YXIga0RhdGUgPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhcbiAgICAgICdBV1M0JyArIGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSxcbiAgICAgIGRhdGUsXG4gICAgICAnYnVmZmVyJ1xuICAgICk7XG4gICAgdmFyIGtSZWdpb24gPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhrRGF0ZSwgcmVnaW9uLCAnYnVmZmVyJyk7XG4gICAgdmFyIGtTZXJ2aWNlID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoa1JlZ2lvbiwgc2VydmljZSwgJ2J1ZmZlcicpO1xuXG4gICAgdmFyIHNpZ25pbmdLZXkgPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhrU2VydmljZSwgdjRJZGVudGlmaWVyLCAnYnVmZmVyJyk7XG4gICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICBjYWNoZWRTZWNyZXRbY2FjaGVLZXldID0gc2lnbmluZ0tleTtcbiAgICAgIGNhY2hlUXVldWUucHVzaChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVRdWV1ZS5sZW5ndGggPiBtYXhDYWNoZUVudHJpZXMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGRlc3QgZW50cnkgKG5vdCB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZClcbiAgICAgICAgZGVsZXRlIGNhY2hlZFNlY3JldFtjYWNoZVF1ZXVlLnNoaWZ0KCldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaWduaW5nS2V5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICpcbiAgICogRW1wdGllcyB0aGUgZGVyaXZlZCBzaWduaW5nIGtleSBjYWNoZS4gTWFkZSBhdmFpbGFibGUgZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgICogb25seS5cbiAgICovXG4gIGVtcHR5Q2FjaGU6IGZ1bmN0aW9uIGVtcHR5Q2FjaGUoKSB7XG4gICAgY2FjaGVkU2VjcmV0ID0ge307XG4gICAgY2FjaGVRdWV1ZSA9IFtdO1xuICB9XG59O1xuIiwiZnVuY3Rpb24gQWNjZXB0b3JTdGF0ZU1hY2hpbmUoc3RhdGVzLCBzdGF0ZSkge1xuICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHN0YXRlIHx8IG51bGw7XG4gIHRoaXMuc3RhdGVzID0gc3RhdGVzIHx8IHt9O1xufVxuXG5BY2NlcHRvclN0YXRlTWFjaGluZS5wcm90b3R5cGUucnVuVG8gPSBmdW5jdGlvbiBydW5UbyhmaW5hbFN0YXRlLCBkb25lLCBiaW5kT2JqZWN0LCBpbnB1dEVycm9yKSB7XG4gIGlmICh0eXBlb2YgZmluYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlucHV0RXJyb3IgPSBiaW5kT2JqZWN0OyBiaW5kT2JqZWN0ID0gZG9uZTtcbiAgICBkb25lID0gZmluYWxTdGF0ZTsgZmluYWxTdGF0ZSA9IG51bGw7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHNlbGYuc3RhdGVzW3NlbGYuY3VycmVudFN0YXRlXTtcbiAgc3RhdGUuZm4uY2FsbChiaW5kT2JqZWN0IHx8IHNlbGYsIGlucHV0RXJyb3IsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChzdGF0ZS5mYWlsKSBzZWxmLmN1cnJlbnRTdGF0ZSA9IHN0YXRlLmZhaWw7XG4gICAgICBlbHNlIHJldHVybiBkb25lID8gZG9uZS5jYWxsKGJpbmRPYmplY3QsIGVycikgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuYWNjZXB0KSBzZWxmLmN1cnJlbnRTdGF0ZSA9IHN0YXRlLmFjY2VwdDtcbiAgICAgIGVsc2UgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoc2VsZi5jdXJyZW50U3RhdGUgPT09IGZpbmFsU3RhdGUpIHtcbiAgICAgIHJldHVybiBkb25lID8gZG9uZS5jYWxsKGJpbmRPYmplY3QsIGVycikgOiBudWxsO1xuICAgIH1cblxuICAgIHNlbGYucnVuVG8oZmluYWxTdGF0ZSwgZG9uZSwgYmluZE9iamVjdCwgZXJyKTtcbiAgfSk7XG59O1xuXG5BY2NlcHRvclN0YXRlTWFjaGluZS5wcm90b3R5cGUuYWRkU3RhdGUgPSBmdW5jdGlvbiBhZGRTdGF0ZShuYW1lLCBhY2NlcHRTdGF0ZSwgZmFpbFN0YXRlLCBmbikge1xuICBpZiAodHlwZW9mIGFjY2VwdFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBhY2NlcHRTdGF0ZTsgYWNjZXB0U3RhdGUgPSBudWxsOyBmYWlsU3RhdGUgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmYWlsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGZhaWxTdGF0ZTsgZmFpbFN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5jdXJyZW50U3RhdGUpIHRoaXMuY3VycmVudFN0YXRlID0gbmFtZTtcbiAgdGhpcy5zdGF0ZXNbbmFtZV0gPSB7IGFjY2VwdDogYWNjZXB0U3RhdGUsIGZhaWw6IGZhaWxTdGF0ZSwgZm46IGZuIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBY2NlcHRvclN0YXRlTWFjaGluZTtcbiIsIi8qIGVzbGludCBndWFyZC1mb3ItaW46MCAqL1xudmFyIEFXUztcblxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgZm9yIHVzZSB3aXRoIHRoZSBBV1MgU0RLLlxuICpcbiAqIEAhYXR0cmlidXRlIGFib3J0XG4gKiAgIFJldHVybiB0aGlzIHZhbHVlIGZyb20gYW4gaXRlcmF0b3IgZnVuY3Rpb24ge2VhY2h9IG9yIHthcnJheUVhY2h9XG4gKiAgIHRvIGJyZWFrIG91dCBvZiB0aGUgaXRlcmF0aW9uLlxuICogICBAZXhhbXBsZSBCcmVha2luZyBvdXQgb2YgYW4gaXRlcmF0b3IgZnVuY3Rpb25cbiAqICAgICBBV1MudXRpbC5lYWNoKHthOiAxLCBiOiAyLCBjOiAzfSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICogICAgICAgaWYgKGtleSA9PSAnYicpIHJldHVybiBBV1MudXRpbC5hYm9ydDtcbiAqICAgICB9KTtcbiAqICAgQHNlZSBlYWNoXG4gKiAgIEBzZWUgYXJyYXlFYWNoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIHV0aWwgPSB7XG4gIGVudmlyb25tZW50OiAnbm9kZWpzJyxcbiAgZW5naW5lOiBmdW5jdGlvbiBlbmdpbmUoKSB7XG4gICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5naW5lID0gcHJvY2Vzcy5wbGF0Zm9ybSArICcvJyArIHByb2Nlc3MudmVyc2lvbjtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5BV1NfRVhFQ1VUSU9OX0VOVikge1xuICAgICAgICBlbmdpbmUgKz0gJyBleGVjLWVudi8nICsgcHJvY2Vzcy5lbnYuQVdTX0VYRUNVVElPTl9FTlY7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5naW5lO1xuICAgIH1cbiAgfSxcblxuICB1c2VyQWdlbnQ6IGZ1bmN0aW9uIHVzZXJBZ2VudCgpIHtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZW52aXJvbm1lbnQ7XG4gICAgdmFyIGFnZW50ID0gJ2F3cy1zZGstJyArIG5hbWUgKyAnLycgKyByZXF1aXJlKCcuL2NvcmUnKS5WRVJTSU9OO1xuICAgIGlmIChuYW1lID09PSAnbm9kZWpzJykgYWdlbnQgKz0gJyAnICsgdXRpbC5lbmdpbmUoKTtcbiAgICByZXR1cm4gYWdlbnQ7XG4gIH0sXG5cbiAgdXJpRXNjYXBlOiBmdW5jdGlvbiB1cmlFc2NhcGUoc3RyaW5nKSB7XG4gICAgdmFyIG91dHB1dCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpO1xuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOV8uflxcLSVdKy9nLCBlc2NhcGUpO1xuXG4gICAgLy8gQVdTIHBlcmNlbnQtZW5jb2RlcyBzb21lIGV4dHJhIG5vbi1zdGFuZGFyZCBjaGFyYWN0ZXJzIGluIGEgVVJJXG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1sqXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuICclJyArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIHVyaUVzY2FwZVBhdGg6IGZ1bmN0aW9uIHVyaUVzY2FwZVBhdGgoc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdXRpbC5hcnJheUVhY2goc3RyaW5nLnNwbGl0KCcvJyksIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICBwYXJ0cy5wdXNoKHV0aWwudXJpRXNjYXBlKHBhcnQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xuICB9LFxuXG4gIHVybFBhcnNlOiBmdW5jdGlvbiB1cmxQYXJzZSh1cmwpIHtcbiAgICByZXR1cm4gdXRpbC51cmwucGFyc2UodXJsKTtcbiAgfSxcblxuICB1cmxGb3JtYXQ6IGZ1bmN0aW9uIHVybEZvcm1hdCh1cmwpIHtcbiAgICByZXR1cm4gdXRpbC51cmwuZm9ybWF0KHVybCk7XG4gIH0sXG5cbiAgcXVlcnlTdHJpbmdQYXJzZTogZnVuY3Rpb24gcXVlcnlTdHJpbmdQYXJzZShxcykge1xuICAgIHJldHVybiB1dGlsLnF1ZXJ5c3RyaW5nLnBhcnNlKHFzKTtcbiAgfSxcblxuICBxdWVyeVBhcmFtc1RvU3RyaW5nOiBmdW5jdGlvbiBxdWVyeVBhcmFtc1RvU3RyaW5nKHBhcmFtcykge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBlc2NhcGUgPSB1dGlsLnVyaUVzY2FwZTtcbiAgICB2YXIgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcykuc29ydCgpO1xuXG4gICAgdXRpbC5hcnJheUVhY2goc29ydGVkS2V5cywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW25hbWVdO1xuICAgICAgdmFyIGVuYW1lID0gZXNjYXBlKG5hbWUpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVuYW1lICsgJz0nO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIHV0aWwuYXJyYXlFYWNoKHZhbHVlLCBmdW5jdGlvbihpdGVtKSB7IHZhbHMucHVzaChlc2NhcGUoaXRlbSkpOyB9KTtcbiAgICAgICAgcmVzdWx0ID0gZW5hbWUgKyAnPScgKyB2YWxzLnNvcnQoKS5qb2luKCcmJyArIGVuYW1lICsgJz0nKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSBlbmFtZSArICc9JyArIGVzY2FwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXRlbXMuam9pbignJicpO1xuICB9LFxuXG4gIHJlYWRGaWxlU3luYzogZnVuY3Rpb24gcmVhZEZpbGVTeW5jKHBhdGgpIHtcbiAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHBhdGgsICd1dGYtOCcpO1xuICB9LFxuXG4gIGJhc2U2NDoge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlNjQoc3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBiYXNlNjQgZW5jb2RlIG51bWJlciAnICsgc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgYnVmID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcbiAgICAgIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0sXG5cbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZTY0KHN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgYmFzZTY0IGRlY29kZSBudW1iZXIgJyArIHN0cmluZykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHV0aWwuYnVmZmVyLnRvQnVmZmVyKHN0cmluZywgJ2Jhc2U2NCcpO1xuICAgIH1cblxuICB9LFxuXG4gIGJ1ZmZlcjoge1xuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBjb25zdHJ1Y3RvciBmb3IgTm9kZSBidWZmZXIgYW5kIGJ1ZmZlciBwb2xseWZpbGxcbiAgICAgKi9cbiAgICB0b0J1ZmZlcjogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHV0aWwuQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgdXRpbC5CdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKSA/XG4gICAgICAgIHV0aWwuQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpIDogbmV3IHV0aWwuQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2l6ZSBwYXNzZWQgdG8gYWxsb2MgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdXRpbC5CdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgdXRpbC5CdWZmZXIoc2l6ZSk7XG4gICAgICAgIGlmIChmaWxsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGJ1Zi5maWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYnVmLmZpbGwoZmlsbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b1N0cmVhbTogZnVuY3Rpb24gdG9TdHJlYW0oYnVmZmVyKSB7XG4gICAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIGJ1ZmZlciA9ICB1dGlsLmJ1ZmZlci50b0J1ZmZlcihidWZmZXIpO1xuXG4gICAgICB2YXIgcmVhZGFibGUgPSBuZXcgKHV0aWwuc3RyZWFtLlJlYWRhYmxlKSgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICByZWFkYWJsZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgaWYgKHBvcyA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gcmVhZGFibGUucHVzaChudWxsKTtcblxuICAgICAgICB2YXIgZW5kID0gcG9zICsgc2l6ZTtcbiAgICAgICAgaWYgKGVuZCA+IGJ1ZmZlci5sZW5ndGgpIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHJlYWRhYmxlLnB1c2goYnVmZmVyLnNsaWNlKHBvcywgZW5kKSk7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZWFkYWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIGEgbGlzdCBvZiBCdWZmZXIgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBjb25jYXQ6IGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSAwLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgYnVmZmVyID0gbnVsbCwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoICs9IGJ1ZmZlcnNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIgPSB1dGlsLmJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXJzW2ldLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICB9LFxuXG4gIHN0cmluZzoge1xuICAgIGJ5dGVMZW5ndGg6IGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykgc3RyaW5nID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nLmxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zaXplO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdmcycpLmxzdGF0U3luYyhzdHJpbmcucGF0aCkuc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgZGV0ZXJtaW5lIGxlbmd0aCBvZiAnICsgc3RyaW5nKSxcbiAgICAgICAgICB7IG9iamVjdDogc3RyaW5nIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cHBlckZpcnN0OiBmdW5jdGlvbiB1cHBlckZpcnN0KHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZ1swXS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbiAgICB9LFxuXG4gICAgbG93ZXJGaXJzdDogZnVuY3Rpb24gbG93ZXJGaXJzdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmdbMF0udG9Mb3dlckNhc2UoKSArIHN0cmluZy5zdWJzdHIoMSk7XG4gICAgfVxuICB9LFxuXG4gIGluaToge1xuICAgIHBhcnNlOiBmdW5jdGlvbiBzdHJpbmcoaW5pKSB7XG4gICAgICB2YXIgY3VycmVudFNlY3Rpb24sIG1hcCA9IHt9O1xuICAgICAgdXRpbC5hcnJheUVhY2goaW5pLnNwbGl0KC9cXHI/XFxuLyksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc3BsaXQoLyhefFxccylbOyNdLylbMF07IC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGxpbmUubWF0Y2goL15cXHMqXFxbKFteXFxbXFxdXSspXFxdXFxzKiQvKTtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9IHNlY3Rpb25bMV07XG4gICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uID09PSAnX19wcm90b19fJyB8fCBjdXJyZW50U2VjdGlvbi5zcGxpdCgvXFxzLylbMV0gPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICB0aHJvdyB1dGlsLmVycm9yKFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHByb2ZpbGUgbmFtZSBcXCcnICsgY3VycmVudFNlY3Rpb24gKyAnXFwnIGZyb20gc2hhcmVkIGluaSBmaWxlLicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2VjdGlvbikge1xuICAgICAgICAgIHZhciBpdGVtID0gbGluZS5tYXRjaCgvXlxccyooLis/KVxccyo9XFxzKiguKz8pXFxzKiQvKTtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbWFwW2N1cnJlbnRTZWN0aW9uXSA9IG1hcFtjdXJyZW50U2VjdGlvbl0gfHwge307XG4gICAgICAgICAgICBtYXBbY3VycmVudFNlY3Rpb25dW2l0ZW1bMV1dID0gaXRlbVsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSxcblxuICBmbjoge1xuICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybiBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gYXMgXCJhc3luY1wiIGZ1bmN0aW9uIGJ5IG1ha2luZyBpdCBjYWxsXG4gICAgICogYSBjYWxsYmFjay4gVGhlIHVuZGVybHlpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYWxsIGJ1dCB0aGUgbGFzdCBhcmd1bWVudCxcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIHBhc3NlZCBwYXNzZWQgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIG9mIG51bGwgb24gc3VjY2VzcyB0byBtaW1pY2sgc3RhbmRhcmQgbm9kZSBjYWxsYmFja3MuXG4gICAgICovXG4gICAgbWFrZUFzeW5jOiBmdW5jdGlvbiBtYWtlQXN5bmMoZm4sIGV4cGVjdGVkQXJncykge1xuICAgICAgaWYgKGV4cGVjdGVkQXJncyAmJiBleHBlY3RlZEFyZ3MgPD0gZm4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEYXRlIGFuZCB0aW1lIHV0aWxpdHkgZnVuY3Rpb25zLlxuICAgKi9cbiAgZGF0ZToge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbRGF0ZV0gdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBkYXRlIG9iamVjdC4gU2luY2UgYWxsXG4gICAgICogICBBV1Mgc2VydmljZXMgcmVseSBvbiB0aGlzIGRhdGUgb2JqZWN0LCB5b3UgY2FuIG92ZXJyaWRlXG4gICAgICogICB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBzcGVjaWFsIHRpbWUgdmFsdWUgdG8gQVdTIHNlcnZpY2VcbiAgICAgKiAgIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICBpZiAoIUFXUykgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4gICAgICBpZiAoQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCkgeyAvLyB1c2Ugb2Zmc2V0IHdoZW4gbm9uLXplcm9cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgZGF0ZSBpbiBJU08tODYwMSBmb3JtYXRcbiAgICAgKi9cbiAgICBpc284NjAxOiBmdW5jdGlvbiBpc284NjAxKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHsgZGF0ZSA9IHV0aWwuZGF0ZS5nZXREYXRlKCk7IH1cbiAgICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvXFwuXFxkezN9WiQvLCAnWicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBkYXRlIGluIFJGQyA4MjIgZm9ybWF0XG4gICAgICovXG4gICAgcmZjODIyOiBmdW5jdGlvbiByZmM4MjIoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkgeyBkYXRlID0gdXRpbC5kYXRlLmdldERhdGUoKTsgfVxuICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbSW50ZWdlcl0gdGhlIFVOSVggdGltZXN0YW1wIHZhbHVlIGZvciB0aGUgY3VycmVudCB0aW1lXG4gICAgICovXG4gICAgdW5peFRpbWVzdGFtcDogZnVuY3Rpb24gdW5peFRpbWVzdGFtcChkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IGRhdGUgPSB1dGlsLmRhdGUuZ2V0RGF0ZSgpOyB9XG4gICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gW1N0cmluZyxudW1iZXIsRGF0ZV0gZGF0ZVxuICAgICAqIEByZXR1cm4gW0RhdGVdXG4gICAgICovXG4gICAgZnJvbTogZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUgKiAxMDAwKTsgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBEYXRlIG9yIGRhdGUtbGlrZSB2YWx1ZSwgdGhpcyBmdW5jdGlvbiBmb3JtYXRzIHRoZVxuICAgICAqIGRhdGUgaW50byBhIHN0cmluZyBvZiB0aGUgcmVxdWVzdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBbU3RyaW5nLG51bWJlcixEYXRlXSBkYXRlXG4gICAgICogQHBhcmFtIFtTdHJpbmddIGZvcm1hdHRlciBWYWxpZCBmb3JtYXRzIGFyZTpcbiAgICAgIyAgICogJ2lzbzg2MDEnXG4gICAgICMgICAqICdyZmM4MjInXG4gICAgICMgICAqICd1bml4VGltZXN0YW1wJ1xuICAgICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICAgKi9cbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChkYXRlLCBmb3JtYXR0ZXIpIHtcbiAgICAgIGlmICghZm9ybWF0dGVyKSBmb3JtYXR0ZXIgPSAnaXNvODYwMSc7XG4gICAgICByZXR1cm4gdXRpbC5kYXRlW2Zvcm1hdHRlcl0odXRpbC5kYXRlLmZyb20oZGF0ZSkpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpbWVzdGFtcDogZnVuY3Rpb24gcGFyc2VUaW1lc3RhbXAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7IC8vIHVuaXggdGltZXN0YW1wIChudW1iZXIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSAqIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcZCskLykpIHsgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFxkezR9LykpIHsgLy8gaXNvODYwMVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcd3szfSwvKSkgeyAvLyByZmM4MjJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCd1bmhhbmRsZWQgdGltZXN0YW1wIGZvcm1hdDogJyArIHZhbHVlKSxcbiAgICAgICAgICB7Y29kZTogJ1RpbWVzdGFtcFBhcnNlckVycm9yJ30pO1xuICAgICAgfVxuICAgIH1cblxuICB9LFxuXG4gIGNyeXB0bzoge1xuICAgIGNyYzMyVGFibGU6IFtcbiAgICAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSwgMHgwNzZEQzQxOSxcbiAgICAgMHg3MDZBRjQ4RiwgMHhFOTYzQTUzNSwgMHg5RTY0OTVBMywgMHgwRURCODgzMiwgMHg3OURDQjhBNCxcbiAgICAgMHhFMEQ1RTkxRSwgMHg5N0QyRDk4OCwgMHgwOUI2NEMyQiwgMHg3RUIxN0NCRCwgMHhFN0I4MkQwNyxcbiAgICAgMHg5MEJGMUQ5MSwgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSxcbiAgICAgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNywgMHgxMzZDOTg1NixcbiAgICAgMHg2NDZCQThDMCwgMHhGRDYyRjk3QSwgMHg4QTY1QzlFQywgMHgxNDAxNUM0RiwgMHg2MzA2NkNEOSxcbiAgICAgMHhGQTBGM0Q2MywgMHg4RDA4MERGNSwgMHgzQjZFMjBDOCwgMHg0QzY5MTA1RSwgMHhENTYwNDFFNCxcbiAgICAgMHhBMjY3NzE3MiwgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QixcbiAgICAgMHgzNUI1QThGQSwgMHg0MkIyOTg2QywgMHhEQkJCQzlENiwgMHhBQ0JDRjk0MCwgMHgzMkQ4NkNFMyxcbiAgICAgMHg0NURGNUM3NSwgMHhEQ0Q2MERDRiwgMHhBQkQxM0Q1OSwgMHgyNkQ5MzBBQywgMHg1MURFMDAzQSxcbiAgICAgMHhDOEQ3NTE4MCwgMHhCRkQwNjExNiwgMHgyMUI0RjRCNSwgMHg1NkIzQzQyMywgMHhDRkJBOTU5OSxcbiAgICAgMHhCOEJEQTUwRiwgMHgyODAyQjg5RSwgMHg1RjA1ODgwOCwgMHhDNjBDRDlCMiwgMHhCMTBCRTkyNCxcbiAgICAgMHgyRjZGN0M4NywgMHg1ODY4NEMxMSwgMHhDMTYxMURBQiwgMHhCNjY2MkQzRCwgMHg3NkRDNDE5MCxcbiAgICAgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRixcbiAgICAgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMywgMHg3ODA3QzlBMiwgMHgwRjAwRjkzNCwgMHg5NjA5QTg4RSxcbiAgICAgMHhFMTBFOTgxOCwgMHg3RjZBMERCQiwgMHgwODZEM0QyRCwgMHg5MTY0NkM5NywgMHhFNjYzNUMwMSxcbiAgICAgMHg2QjZCNTFGNCwgMHgxQzZDNjE2MiwgMHg4NTY1MzBEOCwgMHhGMjYyMDA0RSwgMHg2QzA2OTVFRCxcbiAgICAgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NywgMHg2NUIwRDlDNiwgMHgxMkI3RTk1MCxcbiAgICAgMHg4QkJFQjhFQSwgMHhGQ0I5ODg3QywgMHg2MkREMURERiwgMHgxNURBMkQ0OSwgMHg4Q0QzN0NGMyxcbiAgICAgMHhGQkQ0NEM2NSwgMHg0REIyNjE1OCwgMHgzQUI1NTFDRSwgMHhBM0JDMDA3NCwgMHhENEJCMzBFMixcbiAgICAgMHg0QURGQTU0MSwgMHgzREQ4OTVENywgMHhBNEQxQzQ2RCwgMHhEM0Q2RjRGQiwgMHg0MzY5RTk2QSxcbiAgICAgMHgzNDZFRDlGQywgMHhBRDY3ODg0NiwgMHhEQTYwQjhEMCwgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSxcbiAgICAgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSwgMHg1MDA1NzEzQywgMHgyNzAyNDFBQSwgMHhCRTBCMTAxMCxcbiAgICAgMHhDOTBDMjA4NiwgMHg1NzY4QjUyNSwgMHgyMDZGODVCMywgMHhCOTY2RDQwOSwgMHhDRTYxRTQ5RixcbiAgICAgMHg1RURFRjkwRSwgMHgyOUQ5Qzk5OCwgMHhCMEQwOTgyMiwgMHhDN0Q3QThCNCwgMHg1OUIzM0QxNyxcbiAgICAgMHgyRUI0MEQ4MSwgMHhCN0JENUMzQiwgMHhDMEJBNkNBRCwgMHhFREI4ODMyMCwgMHg5QUJGQjNCNixcbiAgICAgMHgwM0I2RTIwQywgMHg3NEIxRDI5QSwgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSxcbiAgICAgMHg3M0RDMTY4MywgMHhFMzYzMEIxMiwgMHg5NDY0M0I4NCwgMHgwRDZENkEzRSwgMHg3QTZBNUFBOCxcbiAgICAgMHhFNDBFQ0YwQiwgMHg5MzA5RkY5RCwgMHgwQTAwQUUyNywgMHg3RDA3OUVCMSwgMHhGMDBGOTM0NCxcbiAgICAgMHg4NzA4QTNEMiwgMHgxRTAxRjI2OCwgMHg2OTA2QzJGRSwgMHhGNzYyNTc1RCwgMHg4MDY1NjdDQixcbiAgICAgMHgxOTZDMzY3MSwgMHg2RTZCMDZFNywgMHhGRUQ0MUI3NiwgMHg4OUQzMkJFMCwgMHgxMERBN0E1QSxcbiAgICAgMHg2N0RENEFDQywgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSxcbiAgICAgMHhENkQ2QTNFOCwgMHhBMUQxOTM3RSwgMHgzOEQ4QzJDNCwgMHg0RkRGRjI1MiwgMHhEMUJCNjdGMSxcbiAgICAgMHhBNkJDNTc2NywgMHgzRkI1MDZERCwgMHg0OEIyMzY0QiwgMHhEODBEMkJEQSwgMHhBRjBBMUI0QyxcbiAgICAgMHgzNjAzNEFGNiwgMHg0MTA0N0E2MCwgMHhERjYwRUZDMywgMHhBODY3REY1NSwgMHgzMTZFOEVFRixcbiAgICAgMHg0NjY5QkU3OSwgMHhDQjYxQjM4QywgMHhCQzY2ODMxQSwgMHgyNTZGRDJBMCwgMHg1MjY4RTIzNixcbiAgICAgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRiwgMHhDNUJBM0JCRSxcbiAgICAgMHhCMkJEMEIyOCwgMHgyQkI0NUE5MiwgMHg1Q0IzNkEwNCwgMHhDMkQ3RkZBNywgMHhCNUQwQ0YzMSxcbiAgICAgMHgyQ0Q5OUU4QiwgMHg1QkRFQUUxRCwgMHg5QjY0QzJCMCwgMHhFQzYzRjIyNiwgMHg3NTZBQTM5QyxcbiAgICAgMHgwMjZEOTMwQSwgMHg5QzA5MDZBOSwgMHhFQjBFMzYzRiwgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMyxcbiAgICAgMHg5NUJGNEE4MiwgMHhFMkI4N0ExNCwgMHg3QkIxMkJBRSwgMHgwQ0I2MUIzOCwgMHg5MkQyOEU5QixcbiAgICAgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSwgMHg4NkQzRDJENCwgMHhGMUQ0RTI0MixcbiAgICAgMHg2OEREQjNGOCwgMHgxRkRBODM2RSwgMHg4MUJFMTZDRCwgMHhGNkI5MjY1QiwgMHg2RkIwNzdFMSxcbiAgICAgMHgxOEI3NDc3NywgMHg4ODA4NUFFNiwgMHhGRjBGNkE3MCwgMHg2NjA2M0JDQSwgMHgxMTAxMEI1QyxcbiAgICAgMHg4RjY1OUVGRiwgMHhGODYyQUU2OSwgMHg2MTZCRkZEMywgMHgxNjZDQ0Y0NSwgMHhBMDBBRTI3OCxcbiAgICAgMHhENzBERDJFRSwgMHg0RTA0ODM1NCwgMHgzOTAzQjNDMiwgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNyxcbiAgICAgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQiwgMHhBRUQxNkE0QSwgMHhEOUQ2NUFEQywgMHg0MERGMEI2NixcbiAgICAgMHgzN0Q4M0JGMCwgMHhBOUJDQUU1MywgMHhERUJCOUVDNSwgMHg0N0IyQ0Y3RiwgMHgzMEI1RkZFOSxcbiAgICAgMHhCREJERjIxQywgMHhDQUJBQzI4QSwgMHg1M0IzOTMzMCwgMHgyNEI0QTNBNiwgMHhCQUQwMzYwNSxcbiAgICAgMHhDREQ3MDY5MywgMHg1NERFNTcyOSwgMHgyM0Q5NjdCRiwgMHhCMzY2N0EyRSwgMHhDNDYxNEFCOCxcbiAgICAgMHg1RDY4MUIwMiwgMHgyQTZGMkI5NCwgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQixcbiAgICAgMHgyRDAyRUY4RF0sXG5cbiAgICBjcmMzMjogZnVuY3Rpb24gY3JjMzIoZGF0YSkge1xuICAgICAgdmFyIHRibCA9IHV0aWwuY3J5cHRvLmNyYzMyVGFibGU7XG4gICAgICB2YXIgY3JjID0gMCBeIC0xO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihkYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gZGF0YS5yZWFkVUludDgoaSk7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGJsWyhjcmMgXiBjb2RlKSAmIDB4RkZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjcmMgXiAtMSkgPj4+IDA7XG4gICAgfSxcblxuICAgIGhtYWM6IGZ1bmN0aW9uIGhtYWMoa2V5LCBzdHJpbmcsIGRpZ2VzdCwgZm4pIHtcbiAgICAgIGlmICghZGlnZXN0KSBkaWdlc3QgPSAnYmluYXJ5JztcbiAgICAgIGlmIChkaWdlc3QgPT09ICdidWZmZXInKSB7IGRpZ2VzdCA9IHVuZGVmaW5lZDsgfVxuICAgICAgaWYgKCFmbikgZm4gPSAnc2hhMjU2JztcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykgc3RyaW5nID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5saWIuY3JlYXRlSG1hYyhmbiwga2V5KS51cGRhdGUoc3RyaW5nKS5kaWdlc3QoZGlnZXN0KTtcbiAgICB9LFxuXG4gICAgbWQ1OiBmdW5jdGlvbiBtZDUoZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmhhc2goJ21kNScsIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBzaGEyNTY6IGZ1bmN0aW9uIHNoYTI1NihkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8uaGFzaCgnc2hhMjU2JywgZGF0YSwgZGlnZXN0LCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIGhhc2g6IGZ1bmN0aW9uKGFsZ29yaXRobSwgZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGhhc2ggPSB1dGlsLmNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgICBpZiAoIWRpZ2VzdCkgeyBkaWdlc3QgPSAnYmluYXJ5JzsgfVxuICAgICAgaWYgKGRpZ2VzdCA9PT0gJ2J1ZmZlcicpIHsgZGlnZXN0ID0gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gdXRpbC5idWZmZXIudG9CdWZmZXIoZGF0YSk7XG4gICAgICB2YXIgc2xpY2VGbiA9IHV0aWwuYXJyYXlTbGljZUZuKGRhdGEpO1xuICAgICAgdmFyIGlzQnVmZmVyID0gdXRpbC5CdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG4gICAgICAvL0lkZW50aWZ5aW5nIG9iamVjdHMgd2l0aCBhbiBBcnJheUJ1ZmZlciBhcyBidWZmZXJzXG4gICAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSAmJiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgJiYgZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgaXNCdWZmZXIgPSB0cnVlO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIGRhdGEub24gPT09ICdmdW5jdGlvbicgJiYgIWlzQnVmZmVyKSB7XG4gICAgICAgIGRhdGEub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykgeyBoYXNoLnVwZGF0ZShjaHVuayk7IH0pO1xuICAgICAgICBkYXRhLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICAgICAgZGF0YS5vbignZW5kJywgZnVuY3Rpb24oKSB7IGNhbGxiYWNrKG51bGwsIGhhc2guZGlnZXN0KGRpZ2VzdCkpOyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgc2xpY2VGbiAmJiAhaXNCdWZmZXIgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHRoaXMgbWlnaHQgYmUgYSBGaWxlL0Jsb2JcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgc2l6ZSA9IDEwMjQgKiA1MTI7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZGF0YS4nKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWwuQnVmZmVyKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpKTtcbiAgICAgICAgICBoYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICAgIGluZGV4ICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gZGF0YS5zaXplKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYXNoLmRpZ2VzdChkaWdlc3QpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFjayA9IGluZGV4ICsgc2l6ZTtcbiAgICAgICAgICBpZiAoYmFjayA+IGRhdGEuc2l6ZSkgYmFjayA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoc2xpY2VGbi5jYWxsKGRhdGEsIGluZGV4LCBiYWNrKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1dGlsLmlzQnJvd3NlcigpICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhaXNCdWZmZXIpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IHV0aWwuQnVmZmVyKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gaGFzaC51cGRhdGUoZGF0YSkuZGlnZXN0KGRpZ2VzdCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9IZXg6IGZ1bmN0aW9uIHRvSGV4KGRhdGEpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCgoJzAnICsgZGF0YS5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yLCAyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIYXNoOiBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZ29yaXRobSkge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmxpYi5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgfVxuXG4gIH0sXG5cbiAgLyoqIEAhaWdub3JlICovXG5cbiAgLyogQWJvcnQgY29uc3RhbnQgKi9cbiAgYWJvcnQ6IHt9LFxuXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBpdGVyRnVuY3Rpb24pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICB2YXIgcmV0ID0gaXRlckZ1bmN0aW9uLmNhbGwodGhpcywga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICAgIGlmIChyZXQgPT09IHV0aWwuYWJvcnQpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhcnJheUVhY2g6IGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlckZ1bmN0aW9uKSB7XG4gICAgZm9yICh2YXIgaWR4IGluIGFycmF5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpZHgpKSB7XG4gICAgICAgIHZhciByZXQgPSBpdGVyRnVuY3Rpb24uY2FsbCh0aGlzLCBhcnJheVtpZHhdLCBwYXJzZUludChpZHgsIDEwKSk7XG4gICAgICAgIGlmIChyZXQgPT09IHV0aWwuYWJvcnQpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmoxLCBvYmoyKSB7XG4gICAgdXRpbC5lYWNoKG9iajIsIGZ1bmN0aW9uIGl0ZXJhdG9yKGtleSwgaXRlbSkge1xuICAgICAgb2JqMVtrZXldID0gaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqMTtcbiAgfSxcblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2Uob2JqMSwgb2JqMikge1xuICAgIHJldHVybiB1dGlsLnVwZGF0ZSh1dGlsLmNvcHkob2JqMSksIG9iajIpO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uIGNvcHkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9iamVjdDtcbiAgICB2YXIgZHVwZSA9IHt9O1xuICAgIC8vIGpzaGludCBmb3JpbjpmYWxzZVxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGR1cGVba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gZHVwZTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBhcnJheVNsaWNlRm46IGZ1bmN0aW9uIGFycmF5U2xpY2VGbihvYmopIHtcbiAgICB2YXIgZm4gPSBvYmouc2xpY2UgfHwgb2JqLndlYmtpdFNsaWNlIHx8IG9iai5tb3pTbGljZTtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBudWxsO1xuICB9LFxuXG4gIGlzVHlwZTogZnVuY3Rpb24gaXNUeXBlKG9iaiwgdHlwZSkge1xuICAgIC8vIGhhbmRsZSBjcm9zcy1cImZyYW1lXCIgb2JqZWN0c1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgdHlwZSA9IHV0aWwudHlwZU5hbWUodHlwZSk7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbiAgfSxcblxuICB0eXBlTmFtZTogZnVuY3Rpb24gdHlwZU5hbWUodHlwZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwZSwgJ25hbWUnKSkgcmV0dXJuIHR5cGUubmFtZTtcbiAgICB2YXIgc3RyID0gdHlwZS50b1N0cmluZygpO1xuICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXlxccypmdW5jdGlvbiAoLispXFwoLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBzdHI7XG4gIH0sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGVyciwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbEVycm9yID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXNzYWdlKSkge1xuICAgICAgICBvcmlnaW5hbEVycm9yID0gdXRpbC5jb3B5KGVycik7XG4gICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgdXRpbC51cGRhdGUoZXJyLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UpXG4gICAgICAgIGVyci5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgaWYgKG9wdGlvbnMuY29kZSB8fCBvcHRpb25zLm5hbWUpXG4gICAgICAgIGVyci5jb2RlID0gb3B0aW9ucy5jb2RlIHx8IG9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChvcHRpb25zLnN0YWNrKVxuICAgICAgICBlcnIuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHt3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2V9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdtZXNzYWdlJywge2VudW1lcmFibGU6IHRydWV9KTtcbiAgICB9XG5cbiAgICBlcnIubmFtZSA9IFN0cmluZyhvcHRpb25zICYmIG9wdGlvbnMubmFtZSB8fCBlcnIubmFtZSB8fCBlcnIuY29kZSB8fCAnRXJyb3InKTtcbiAgICBlcnIudGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAob3JpZ2luYWxFcnJvcikgZXJyLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuXG4gICAgcmV0dXJuIGVycjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbmhlcml0OiBmdW5jdGlvbiBpbmhlcml0KGtsYXNzLCBmZWF0dXJlcykge1xuICAgIHZhciBuZXdPYmplY3QgPSBudWxsO1xuICAgIGlmIChmZWF0dXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmZWF0dXJlcyA9IGtsYXNzO1xuICAgICAga2xhc3MgPSBPYmplY3Q7XG4gICAgICBuZXdPYmplY3QgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN0b3IgPSBmdW5jdGlvbiBDb25zdHJ1Y3RvcldyYXBwZXIoKSB7fTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgbmV3T2JqZWN0ID0gbmV3IGN0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBub3Qgc3VwcGxpZWQsIGNyZWF0ZSBwYXNzLXRocm91Z2ggY3RvclxuICAgIGlmIChmZWF0dXJlcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBmZWF0dXJlcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoa2xhc3MgIT09IE9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBrbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ld09iamVjdDtcbiAgICB1dGlsLnVwZGF0ZShmZWF0dXJlcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGZlYXR1cmVzKTtcbiAgICBmZWF0dXJlcy5jb25zdHJ1Y3Rvci5fX3N1cGVyX18gPSBrbGFzcztcbiAgICByZXR1cm4gZmVhdHVyZXMuY29uc3RydWN0b3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbWl4aW46IGZ1bmN0aW9uIG1peGluKCkge1xuICAgIHZhciBrbGFzcyA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8ganNoaW50IGZvcmluOmZhbHNlXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGFyZ3VtZW50c1tpXS5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2ldLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcF0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2xhc3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGlkZVByb3BlcnRpZXM6IGZ1bmN0aW9uIGhpZGVQcm9wZXJ0aWVzKG9iaiwgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgdXRpbC5hcnJheUVhY2gocHJvcHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcm9wZXJ0eTogZnVuY3Rpb24gcHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSwgZW51bWVyYWJsZSwgaXNWYWx1ZSkge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkID8gZW51bWVyYWJsZSA6IHRydWVcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWlzVmFsdWUpIHtcbiAgICAgIG9wdHMuZ2V0ID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0cy52YWx1ZSA9IHZhbHVlOyBvcHRzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBvcHRzKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBtZW1vaXplZFByb3BlcnR5OiBmdW5jdGlvbiBtZW1vaXplZFByb3BlcnR5KG9iaiwgbmFtZSwgZ2V0LCBlbnVtZXJhYmxlKSB7XG4gICAgdmFyIGNhY2hlZFZhbHVlID0gbnVsbDtcblxuICAgIC8vIGJ1aWxkIGVudW1lcmFibGUgYXR0cmlidXRlIGZvciBlYWNoIHZhbHVlIHdpdGggbGF6eSBhY2Nlc3Nvci5cbiAgICB1dGlsLnByb3BlcnR5KG9iaiwgbmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY2FjaGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVkVmFsdWUgPSBnZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICB9LCBlbnVtZXJhYmxlKTtcbiAgfSxcblxuICAvKipcbiAgICogVE9ETyBSZW1vdmUgaW4gbWFqb3IgdmVyc2lvbiByZXZpc2lvblxuICAgKiBUaGlzIGJhY2tmaWxsIHBvcHVsYXRlcyByZXNwb25zZSBkYXRhIHdpdGhvdXQgdGhlXG4gICAqIHRvcC1sZXZlbCBwYXlsb2FkIG5hbWUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaG9pc3RQYXlsb2FkTWVtYmVyOiBmdW5jdGlvbiBob2lzdFBheWxvYWRNZW1iZXIocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIG9wZXJhdGlvbk5hbWUgPSByZXEub3BlcmF0aW9uO1xuICAgIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25OYW1lXTtcbiAgICB2YXIgb3V0cHV0ID0gb3BlcmF0aW9uLm91dHB1dDtcbiAgICBpZiAob3V0cHV0LnBheWxvYWQgJiYgIW9wZXJhdGlvbi5oYXNFdmVudE91dHB1dCkge1xuICAgICAgdmFyIHBheWxvYWRNZW1iZXIgPSBvdXRwdXQubWVtYmVyc1tvdXRwdXQucGF5bG9hZF07XG4gICAgICB2YXIgcmVzcG9uc2VQYXlsb2FkID0gcmVzcC5kYXRhW291dHB1dC5wYXlsb2FkXTtcbiAgICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICAgIHV0aWwuZWFjaChyZXNwb25zZVBheWxvYWQsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB1dGlsLnByb3BlcnR5KHJlc3AuZGF0YSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGUgU0hBLTI1NiBjaGVja3N1bXMgb2Ygc3RyZWFtc1xuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVTaGEyNTY6IGZ1bmN0aW9uIGNvbXB1dGVTaGEyNTYoYm9keSwgZG9uZSkge1xuICAgIGlmICh1dGlsLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgU3RyZWFtID0gdXRpbC5zdHJlYW0uU3RyZWFtO1xuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIGlmICh0eXBlb2YgU3RyZWFtID09PSAnZnVuY3Rpb24nICYmIGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5LnBhdGggPT09ICdzdHJpbmcnKSB7IC8vIGFzc3VtZSBmaWxlIG9iamVjdFxuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5zdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnN0YXJ0ID0gYm9keS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBib2R5LmVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmVuZCA9IGJvZHkuZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib2R5ID0gZnMuY3JlYXRlUmVhZFN0cmVhbShib2R5LnBhdGgsIHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVE9ETyBzdXBwb3J0IG90aGVyIHN0cmVhbSB0eXBlc1xuICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignTm9uLWZpbGUgc3RyZWFtIG9iamVjdHMgYXJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm90IHN1cHBvcnRlZCB3aXRoIFNpZ1Y0JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbC5jcnlwdG8uc2hhMjU2KGJvZHksICdoZXgnLCBmdW5jdGlvbihlcnIsIHNoYSkge1xuICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgZWxzZSBkb25lKG51bGwsIHNoYSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9ja1NrZXdlZDogZnVuY3Rpb24gaXNDbG9ja1NrZXdlZChzZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKHNlcnZlclRpbWUpIHtcbiAgICAgIHV0aWwucHJvcGVydHkoQVdTLmNvbmZpZywgJ2lzQ2xvY2tTa2V3ZWQnLFxuICAgICAgICBNYXRoLmFicyhuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHNlcnZlclRpbWUpID49IDMwMDAwMCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIEFXUy5jb25maWcuaXNDbG9ja1NrZXdlZDtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHlDbG9ja09mZnNldDogZnVuY3Rpb24gYXBwbHlDbG9ja09mZnNldChzZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKHNlcnZlclRpbWUpXG4gICAgICBBV1MuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0ID0gc2VydmVyVGltZSAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RSZXF1ZXN0SWQ6IGZ1bmN0aW9uIGV4dHJhY3RSZXF1ZXN0SWQocmVzcCkge1xuICAgIHZhciByZXF1ZXN0SWQgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1yZXF1ZXN0LWlkJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16bi1yZXF1ZXN0aWQnXTtcblxuICAgIGlmICghcmVxdWVzdElkICYmIHJlc3AuZGF0YSAmJiByZXNwLmRhdGEuUmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgcmVxdWVzdElkID0gcmVzcC5kYXRhLlJlc3BvbnNlTWV0YWRhdGEuUmVxdWVzdElkO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0SWQpIHtcbiAgICAgIHJlc3AucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cblxuICAgIGlmIChyZXNwLmVycm9yKSB7XG4gICAgICByZXNwLmVycm9yLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkUHJvbWlzZXM6IGZ1bmN0aW9uIGFkZFByb21pc2VzKGNvbnN0cnVjdG9ycywgUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgICB2YXIgZGVsZXRlUHJvbWlzZXMgPSBmYWxzZTtcbiAgICBpZiAoUHJvbWlzZURlcGVuZGVuY3kgPT09IHVuZGVmaW5lZCAmJiBBV1MgJiYgQVdTLmNvbmZpZykge1xuICAgICAgUHJvbWlzZURlcGVuZGVuY3kgPSBBV1MuY29uZmlnLmdldFByb21pc2VzRGVwZW5kZW5jeSgpO1xuICAgIH1cbiAgICBpZiAoUHJvbWlzZURlcGVuZGVuY3kgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFByb21pc2VEZXBlbmRlbmN5ID0gUHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlRGVwZW5kZW5jeSAhPT0gJ2Z1bmN0aW9uJykgZGVsZXRlUHJvbWlzZXMgPSB0cnVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25zdHJ1Y3RvcnMpKSBjb25zdHJ1Y3RvcnMgPSBbY29uc3RydWN0b3JzXTtcblxuICAgIGZvciAodmFyIGluZCA9IDA7IGluZCA8IGNvbnN0cnVjdG9ycy5sZW5ndGg7IGluZCsrKSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcnNbaW5kXTtcbiAgICAgIGlmIChkZWxldGVQcm9taXNlcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3IuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MpIHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvci5kZWxldGVQcm9taXNlc0Zyb21DbGFzcygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yLmFkZFByb21pc2VzVG9DbGFzcykge1xuICAgICAgICBjb25zdHJ1Y3Rvci5hZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gYSBwcm9taXNlIHdob3NlIGZhdGUgaXMgZGVjaWRlZCBieSB0aGVcbiAgICogY2FsbGJhY2sgYmVoYXZpb3Igb2YgdGhlIGdpdmVuIG1ldGhvZCB3aXRoIGBtZXRob2ROYW1lYC4gVGhlIG1ldGhvZCB0byBiZVxuICAgKiBwcm9taXNpZmllZCBzaG91bGQgY29uZm9ybSB0byBub2RlLmpzIGNvbnZlbnRpb24gb2YgYWNjZXB0aW5nIGEgY2FsbGJhY2sgYXNcbiAgICogbGFzdCBhcmd1bWVudCBhbmQgY2FsbGluZyB0aGF0IGNhbGxiYWNrIHdpdGggZXJyb3IgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqIGFuZCBzdWNjZXNzIHZhbHVlIG9uIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAqL1xuICBwcm9taXNpZnlNZXRob2Q6IGZ1bmN0aW9uIHByb21pc2lmeU1ldGhvZChtZXRob2ROYW1lLCBQcm9taXNlRGVwZW5kZW5jeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwcm9taXNlKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlRGVwZW5kZW5jeShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGZbbWV0aG9kTmFtZV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzRHVhbHN0YWNrQXZhaWxhYmxlOiBmdW5jdGlvbiBpc0R1YWxzdGFja0F2YWlsYWJsZShzZXJ2aWNlKSB7XG4gICAgaWYgKCFzZXJ2aWNlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi4vYXBpcy9tZXRhZGF0YS5qc29uJyk7XG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlICE9PSAnc3RyaW5nJykgc2VydmljZSA9IHNlcnZpY2Uuc2VydmljZUlkZW50aWZpZXI7XG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlICE9PSAnc3RyaW5nJyB8fCAhbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoc2VydmljZSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gISFtZXRhZGF0YVtzZXJ2aWNlXS5kdWFsc3RhY2tBdmFpbGFibGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlUmV0cnlEZWxheTogZnVuY3Rpb24gY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCByZXRyeURlbGF5T3B0aW9ucywgZXJyKSB7XG4gICAgaWYgKCFyZXRyeURlbGF5T3B0aW9ucykgcmV0cnlEZWxheU9wdGlvbnMgPSB7fTtcbiAgICB2YXIgY3VzdG9tQmFja29mZiA9IHJldHJ5RGVsYXlPcHRpb25zLmN1c3RvbUJhY2tvZmYgfHwgbnVsbDtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUJhY2tvZmYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjdXN0b21CYWNrb2ZmKHJldHJ5Q291bnQsIGVycik7XG4gICAgfVxuICAgIHZhciBiYXNlID0gdHlwZW9mIHJldHJ5RGVsYXlPcHRpb25zLmJhc2UgPT09ICdudW1iZXInID8gcmV0cnlEZWxheU9wdGlvbnMuYmFzZSA6IDEwMDtcbiAgICB2YXIgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogKE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogYmFzZSk7XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVJlcXVlc3RXaXRoUmV0cmllczogZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzKGh0dHBSZXF1ZXN0LCBvcHRpb25zLCBjYikge1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBodHRwID0gQVdTLkh0dHBDbGllbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICB2YXIgaHR0cE9wdGlvbnMgPSBvcHRpb25zLmh0dHBPcHRpb25zIHx8IHt9O1xuICAgIHZhciByZXRyeUNvdW50ID0gMDtcblxuICAgIHZhciBlcnJDYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgdmFyIG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgfHwgMDtcbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InKSBlcnIucmV0cnlhYmxlID0gdHJ1ZTtcblxuICAgICAgLy8gQ2FsbCBgY2FsY3VsYXRlUmV0cnlEZWxheSgpYCBvbmx5IHdoZW4gcmVsZXZhbnQsIHNlZSAjMzQwMVxuICAgICAgaWYgKGVyciAmJiBlcnIucmV0cnlhYmxlICYmIHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIHZhciBkZWxheSA9IHV0aWwuY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCBvcHRpb25zLnJldHJ5RGVsYXlPcHRpb25zLCBlcnIpO1xuICAgICAgICBpZiAoZGVsYXkgPj0gMCkge1xuICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICBzZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCBkZWxheSArIChlcnIucmV0cnlBZnRlciB8fCAwKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYihlcnIpO1xuICAgIH07XG5cbiAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0gJyc7XG4gICAgICBodHRwLmhhbmRsZVJlcXVlc3QoaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLCBmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAgICAgICAgaHR0cFJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHsgZGF0YSArPSBjaHVuay50b1N0cmluZygpOyB9KTtcbiAgICAgICAgaHR0cFJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICBjYihudWxsLCBkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJldHJ5QWZ0ZXIgPSBwYXJzZUludChodHRwUmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSwgMTApICogMTAwMCB8fCAwO1xuICAgICAgICAgICAgdmFyIGVyciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgIHJldHJ5YWJsZTogc3RhdHVzQ29kZSA+PSA1MDAgfHwgc3RhdHVzQ29kZSA9PT0gNDI5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmV0cnlBZnRlciAmJiBlcnIucmV0cnlhYmxlKSBlcnIucmV0cnlBZnRlciA9IHJldHJ5QWZ0ZXI7XG4gICAgICAgICAgICBlcnJDYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBlcnJDYWxsYmFjayk7XG4gICAgfTtcblxuICAgIEFXUy51dGlsLmRlZmVyKHNlbmRSZXF1ZXN0KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB1dWlkOiB7XG4gICAgdjQ6IGZ1bmN0aW9uIHV1aWRWNCgpIHtcbiAgICAgIHJldHVybiByZXF1aXJlKCd1dWlkJykudjQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29udmVydFBheWxvYWRUb1N0cmluZzogZnVuY3Rpb24gY29udmVydFBheWxvYWRUb1N0cmluZyhyZXNwKSB7XG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVxLm9wZXJhdGlvbjtcbiAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dLm91dHB1dCB8fCB7fTtcbiAgICBpZiAocnVsZXMucGF5bG9hZCAmJiByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0pIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXS50b1N0cmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZlcjogZnVuY3Rpb24gZGVmZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRSZXF1ZXN0UGF5bG9hZFNoYXBlOiBmdW5jdGlvbiBnZXRSZXF1ZXN0UGF5bG9hZFNoYXBlKHJlcSkge1xuICAgIHZhciBvcGVyYXRpb25zID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnM7XG4gICAgaWYgKCFvcGVyYXRpb25zKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBvcGVyYXRpb24gPSAob3BlcmF0aW9ucyB8fCB7fSlbcmVxLm9wZXJhdGlvbl07XG4gICAgaWYgKCFvcGVyYXRpb24gfHwgIW9wZXJhdGlvbi5pbnB1dCB8fCAhb3BlcmF0aW9uLmlucHV0LnBheWxvYWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG9wZXJhdGlvbi5pbnB1dC5tZW1iZXJzW29wZXJhdGlvbi5pbnB1dC5wYXlsb2FkXTtcbiAgfSxcblxuICBnZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWc6IGZ1bmN0aW9uIGdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhpbmlMb2FkZXIsIGZpbGVuYW1lKSB7XG4gICAgdmFyIHByb2ZpbGVzID0ge307XG4gICAgdmFyIHByb2ZpbGVzRnJvbUNvbmZpZyA9IHt9O1xuICAgIGlmIChwcm9jZXNzLmVudlt1dGlsLmNvbmZpZ09wdEluRW52XSkge1xuICAgICAgdmFyIHByb2ZpbGVzRnJvbUNvbmZpZyA9IGluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICAgIGlzQ29uZmlnOiB0cnVlLFxuICAgICAgICBmaWxlbmFtZTogcHJvY2Vzcy5lbnZbdXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBwcm9maWxlc0Zyb21DcmVkcz0ge307XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm9maWxlc0Zyb21DcmVkcyA9IGluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSB8fFxuICAgICAgICAgIChwcm9jZXNzLmVudlt1dGlsLmNvbmZpZ09wdEluRW52XSAmJiBwcm9jZXNzLmVudlt1dGlsLnNoYXJlZENyZWRlbnRpYWxzRmlsZUVudl0pXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gaWYgdXNpbmcgY29uZmlnLCBhc3N1bWUgaXQgaXMgZnVsbHkgZGVzY3JpcHRpdmUgd2l0aG91dCBhIGNyZWRlbnRpYWxzIGZpbGU6XG4gICAgICBpZiAoIXByb2Nlc3MuZW52W3V0aWwuY29uZmlnT3B0SW5FbnZdKSB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIHByb2ZpbGVOYW1lcyA9IE9iamVjdC5rZXlzKHByb2ZpbGVzRnJvbUNvbmZpZyk7IGkgPCBwcm9maWxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gPSBvYmplY3RBc3NpZ24ocHJvZmlsZXNbcHJvZmlsZU5hbWVzW2ldXSB8fCB7fSwgcHJvZmlsZXNGcm9tQ29uZmlnW3Byb2ZpbGVOYW1lc1tpXV0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgcHJvZmlsZU5hbWVzID0gT2JqZWN0LmtleXMocHJvZmlsZXNGcm9tQ3JlZHMpOyBpIDwgcHJvZmlsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9maWxlc1twcm9maWxlTmFtZXNbaV1dID0gb2JqZWN0QXNzaWduKHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gfHwge30sIHByb2ZpbGVzRnJvbUNyZWRzW3Byb2ZpbGVOYW1lc1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZmlsZXM7XG5cbiAgICAvKipcbiAgICAgKiBSb3VnaGx5IHRoZSBzZW1hbnRpY3Mgb2YgYE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdEFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRba2V5c1tpXV0gPSBzb3VyY2Vba2V5c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBBUk46IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGVBUk4oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyICYmIHN0ci5pbmRleE9mKCdhcm46JykgPT09IDAgJiYgc3RyLnNwbGl0KCc6JykubGVuZ3RoID49IDY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2VBUk4oYXJuKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFybi5zcGxpdCgnOicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFydGl0aW9uOiBtYXRjaGVkWzFdLFxuICAgICAgICBzZXJ2aWNlOiBtYXRjaGVkWzJdLFxuICAgICAgICByZWdpb246IG1hdGNoZWRbM10sXG4gICAgICAgIGFjY291bnRJZDogbWF0Y2hlZFs0XSxcbiAgICAgICAgcmVzb3VyY2U6IG1hdGNoZWQuc2xpY2UoNSkuam9pbignOicpXG4gICAgICB9O1xuICAgIH0sXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkQVJOKGFybk9iamVjdCkge1xuICAgICAgaWYgKFxuICAgICAgICBhcm5PYmplY3Quc2VydmljZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFybk9iamVjdC5yZWdpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhcm5PYmplY3QuYWNjb3VudElkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJuT2JqZWN0LnJlc291cmNlID09PSB1bmRlZmluZWRcbiAgICAgICkgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0lucHV0IEFSTiBvYmplY3QgaXMgaW52YWxpZCcpKTtcbiAgICAgIHJldHVybiAnYXJuOicrIChhcm5PYmplY3QucGFydGl0aW9uIHx8ICdhd3MnKSArICc6JyArIGFybk9iamVjdC5zZXJ2aWNlICtcbiAgICAgICAgJzonICsgYXJuT2JqZWN0LnJlZ2lvbiArICc6JyArIGFybk9iamVjdC5hY2NvdW50SWQgKyAnOicgKyBhcm5PYmplY3QucmVzb3VyY2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRQcm9maWxlOiAnZGVmYXVsdCcsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlnT3B0SW5FbnY6ICdBV1NfU0RLX0xPQURfQ09ORklHJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaGFyZWRDcmVkZW50aWFsc0ZpbGVFbnY6ICdBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNoYXJlZENvbmZpZ0ZpbGVFbnY6ICdBV1NfQ09ORklHX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGltZHNEaXNhYmxlZEVudjogJ0FXU19FQzJfTUVUQURBVEFfRElTQUJMRUQnXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBYbWxOb2RlID0gcmVxdWlyZSgnLi94bWwtbm9kZScpLlhtbE5vZGU7XG52YXIgWG1sVGV4dCA9IHJlcXVpcmUoJy4veG1sLXRleHQnKS5YbWxUZXh0O1xuXG5mdW5jdGlvbiBYbWxCdWlsZGVyKCkgeyB9XG5cblhtbEJ1aWxkZXIucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24ocGFyYW1zLCBzaGFwZSwgcm9vdEVsZW1lbnQsIG5vRW1wdHkpIHtcbiAgdmFyIHhtbCA9IG5ldyBYbWxOb2RlKHJvb3RFbGVtZW50KTtcbiAgYXBwbHlOYW1lc3BhY2VzKHhtbCwgc2hhcGUsIHRydWUpO1xuICBzZXJpYWxpemUoeG1sLCBwYXJhbXMsIHNoYXBlKTtcbiAgcmV0dXJuIHhtbC5jaGlsZHJlbi5sZW5ndGggPiAwIHx8IG5vRW1wdHkgPyB4bWwudG9TdHJpbmcoKSA6ICcnO1xufTtcblxuZnVuY3Rpb24gc2VyaWFsaXplKHhtbCwgdmFsdWUsIHNoYXBlKSB7XG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiBzZXJpYWxpemVTdHJ1Y3R1cmUoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiBzZXJpYWxpemVNYXAoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gc2VyaWFsaXplTGlzdCh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHNlcmlhbGl6ZVNjYWxhcih4bWwsIHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0dXJlKHhtbCwgcGFyYW1zLCBzaGFwZSkge1xuICB1dGlsLmFycmF5RWFjaChzaGFwZS5tZW1iZXJOYW1lcywgZnVuY3Rpb24obWVtYmVyTmFtZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbWVtYmVyTmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlLmxvY2F0aW9uICE9PSAnYm9keScpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1ttZW1iZXJOYW1lXTtcbiAgICB2YXIgbmFtZSA9IG1lbWJlclNoYXBlLm5hbWU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChtZW1iZXJTaGFwZS5pc1htbEF0dHJpYnV0ZSkge1xuICAgICAgICB4bWwuYWRkQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyU2hhcGUuZmxhdHRlbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZSh4bWwsIHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgICBhcHBseU5hbWVzcGFjZXMoZWxlbWVudCwgbWVtYmVyU2hhcGUpO1xuICAgICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAoeG1sLCBtYXAsIHNoYXBlKSB7XG4gIHZhciB4bWxLZXkgPSBzaGFwZS5rZXkubmFtZSB8fCAna2V5JztcbiAgdmFyIHhtbFZhbHVlID0gc2hhcGUudmFsdWUubmFtZSB8fCAndmFsdWUnO1xuXG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBuZXcgWG1sTm9kZShzaGFwZS5mbGF0dGVuZWQgPyBzaGFwZS5uYW1lIDogJ2VudHJ5Jyk7XG4gICAgeG1sLmFkZENoaWxkTm9kZShlbnRyeSk7XG5cbiAgICB2YXIgZW50cnlLZXkgPSBuZXcgWG1sTm9kZSh4bWxLZXkpO1xuICAgIHZhciBlbnRyeVZhbHVlID0gbmV3IFhtbE5vZGUoeG1sVmFsdWUpO1xuICAgIGVudHJ5LmFkZENoaWxkTm9kZShlbnRyeUtleSk7XG4gICAgZW50cnkuYWRkQ2hpbGROb2RlKGVudHJ5VmFsdWUpO1xuXG4gICAgc2VyaWFsaXplKGVudHJ5S2V5LCBrZXksIHNoYXBlLmtleSk7XG4gICAgc2VyaWFsaXplKGVudHJ5VmFsdWUsIHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KHhtbCwgbGlzdCwgc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNoYXBlLm1lbWJlci5uYW1lIHx8IHNoYXBlLm5hbWU7XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgeG1sLmFkZENoaWxkTm9kZShlbGVtZW50KTtcbiAgICAgIHNlcmlhbGl6ZShlbGVtZW50LCB2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG5hbWUgPSBzaGFwZS5tZW1iZXIubmFtZSB8fCAnbWVtYmVyJztcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IFhtbE5vZGUobmFtZSk7XG4gICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgc2VyaWFsaXplKGVsZW1lbnQsIHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNjYWxhcih4bWwsIHZhbHVlLCBzaGFwZSkge1xuICB4bWwuYWRkQ2hpbGROb2RlKFxuICAgIG5ldyBYbWxUZXh0KHNoYXBlLnRvV2lyZUZvcm1hdCh2YWx1ZSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TmFtZXNwYWNlcyh4bWwsIHNoYXBlLCBpc1Jvb3QpIHtcbiAgdmFyIHVyaSwgcHJlZml4ID0gJ3htbG5zJztcbiAgaWYgKHNoYXBlLnhtbE5hbWVzcGFjZVVyaSkge1xuICAgIHVyaSA9IHNoYXBlLnhtbE5hbWVzcGFjZVVyaTtcbiAgICBpZiAoc2hhcGUueG1sTmFtZXNwYWNlUHJlZml4KSBwcmVmaXggKz0gJzonICsgc2hhcGUueG1sTmFtZXNwYWNlUHJlZml4O1xuICB9IGVsc2UgaWYgKGlzUm9vdCAmJiBzaGFwZS5hcGkueG1sTmFtZXNwYWNlVXJpKSB7XG4gICAgdXJpID0gc2hhcGUuYXBpLnhtbE5hbWVzcGFjZVVyaTtcbiAgfVxuXG4gIGlmICh1cmkpIHhtbC5hZGRBdHRyaWJ1dGUocHJlZml4LCB1cmkpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEJ1aWxkZXI7XG4iLCIvKipcbiAqIEVzY2FwZXMgY2hhcmFjdGVycyB0aGF0IGNhbiBub3QgYmUgaW4gYW4gWE1MIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvJy9nLCAnJmFwb3M7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVzY2FwZUF0dHJpYnV0ZTogZXNjYXBlQXR0cmlidXRlXG59O1xuIiwiLyoqXG4gKiBFc2NhcGVzIGNoYXJhY3RlcnMgdGhhdCBjYW4gbm90IGJlIGluIGFuIFhNTCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBlc2NhcGVFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJyYjeDBEOycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnJiN4MEE7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MDA4NS9nLCAnJiN4ODU7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC8sICcmI3gyMDI4OycpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlc2NhcGVFbGVtZW50OiBlc2NhcGVFbGVtZW50XG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB1dGlsID0gQVdTLnV0aWw7XG52YXIgU2hhcGUgPSBBV1MuTW9kZWwuU2hhcGU7XG5cbnZhciB4bWwyanMgPSByZXF1aXJlKCd4bWwyanMnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIG9wdGlvbnMgPSB7ICAvLyBvcHRpb25zIHBhc3NlZCB0byB4bWwyanMgcGFyc2VyXG4gIGV4cGxpY2l0Q2hhcmtleTogZmFsc2UsIC8vIHVuZG9jdW1lbnRlZFxuICB0cmltOiBmYWxzZSwgICAgICAgICAgICAvLyB0cmltIHRoZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSB0ZXh0IG5vZGVzXG4gIG5vcm1hbGl6ZTogZmFsc2UsICAgICAgIC8vIHRyaW0gaW50ZXJpb3Igd2hpdGVzcGFjZSBpbnNpZGUgdGV4dCBub2Rlc1xuICBleHBsaWNpdFJvb3Q6IGZhbHNlLCAgICAvLyByZXR1cm4gdGhlIHJvb3Qgbm9kZSBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdD9cbiAgZW1wdHlUYWc6IG51bGwsICAgICAgICAgLy8gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGVtcHR5IG5vZGVzXG4gIGV4cGxpY2l0QXJyYXk6IHRydWUsICAgIC8vIGFsd2F5cyBwdXQgY2hpbGQgbm9kZXMgaW4gYW4gYXJyYXlcbiAgaWdub3JlQXR0cnM6IGZhbHNlLCAgICAgLy8gaWdub3JlIGF0dHJpYnV0ZXMsIG9ubHkgY3JlYXRlIHRleHQgbm9kZXNcbiAgbWVyZ2VBdHRyczogZmFsc2UsICAgICAgLy8gbWVyZ2UgYXR0cmlidXRlcyBhbmQgY2hpbGQgZWxlbWVudHNcbiAgdmFsaWRhdG9yOiBudWxsICAgICAgICAgLy8gYSBjYWxsYWJsZSB2YWxpZGF0b3Jcbn07XG5cbmZ1bmN0aW9uIE5vZGVYbWxQYXJzZXIoKSB7IH1cblxuTm9kZVhtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih4bWwsIHNoYXBlKSB7XG4gIHNoYXBlID0gc2hhcGUgfHwge307XG5cbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBlcnJvciA9IG51bGw7XG5cbiAgdmFyIHBhcnNlciA9IG5ldyB4bWwyanMuUGFyc2VyKG9wdGlvbnMpO1xuICBwYXJzZXIucGFyc2VTdHJpbmcoeG1sLCBmdW5jdGlvbiAoZSwgcikge1xuICAgIGVycm9yID0gZTtcbiAgICByZXN1bHQgPSByO1xuICB9KTtcblxuICBpZiAocmVzdWx0KSB7XG4gICAgdmFyIGRhdGEgPSBwYXJzZVhtbChyZXN1bHQsIHNoYXBlKTtcbiAgICBpZiAocmVzdWx0LlJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgIGRhdGEuUmVzcG9uc2VNZXRhZGF0YSA9IHBhcnNlWG1sKHJlc3VsdC5SZXNwb25zZU1ldGFkYXRhWzBdLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgdXRpbC5lcnJvcihlcnJvciwge2NvZGU6ICdYTUxQYXJzZXJFcnJvcicsIHJldHJ5YWJsZTogdHJ1ZX0pO1xuICB9IGVsc2UgeyAvLyBlbXB0eSB4bWwgZG9jdW1lbnRcbiAgICByZXR1cm4gcGFyc2VYbWwoe30sIHNoYXBlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VYbWwoeG1sLCBzaGFwZSkge1xuICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICBjYXNlICdzdHJ1Y3R1cmUnOiByZXR1cm4gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHBhcnNlTWFwKHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gcGFyc2VMaXN0KHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgdW5kZWZpbmVkOiBjYXNlIG51bGw6IHJldHVybiBwYXJzZVVua25vd24oeG1sKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gcGFyc2VTY2FsYXIoeG1sLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSkge1xuICB2YXIgZGF0YSA9IHt9O1xuICBpZiAoeG1sID09PSBudWxsKSByZXR1cm4gZGF0YTtcblxuICB1dGlsLmVhY2goc2hhcGUubWVtYmVycywgZnVuY3Rpb24obWVtYmVyTmFtZSwgbWVtYmVyU2hhcGUpIHtcbiAgICB2YXIgeG1sTmFtZSA9IG1lbWJlclNoYXBlLm5hbWU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4bWwsIHhtbE5hbWUpICYmIEFycmF5LmlzQXJyYXkoeG1sW3htbE5hbWVdKSkge1xuICAgICAgdmFyIHhtbENoaWxkID0geG1sW3htbE5hbWVdO1xuICAgICAgaWYgKCFtZW1iZXJTaGFwZS5mbGF0dGVuZWQpIHhtbENoaWxkID0geG1sQ2hpbGRbMF07XG5cbiAgICAgIGRhdGFbbWVtYmVyTmFtZV0gPSBwYXJzZVhtbCh4bWxDaGlsZCwgbWVtYmVyU2hhcGUpO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyU2hhcGUuaXNYbWxBdHRyaWJ1dGUgJiZcbiAgICAgICAgICAgICAgIHhtbC4kICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4bWwuJCwgeG1sTmFtZSkpIHtcbiAgICAgIGRhdGFbbWVtYmVyTmFtZV0gPSBwYXJzZVNjYWxhcih4bWwuJFt4bWxOYW1lXSwgbWVtYmVyU2hhcGUpO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyU2hhcGUudHlwZSA9PT0gJ2xpc3QnICYmICFzaGFwZS5hcGkueG1sTm9EZWZhdWx0TGlzdHMpIHtcbiAgICAgIGRhdGFbbWVtYmVyTmFtZV0gPSBtZW1iZXJTaGFwZS5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNYXAoeG1sLCBzaGFwZSkge1xuICB2YXIgZGF0YSA9IHt9O1xuICBpZiAoeG1sID09PSBudWxsKSByZXR1cm4gZGF0YTtcblxuICB2YXIgeG1sS2V5ID0gc2hhcGUua2V5Lm5hbWUgfHwgJ2tleSc7XG4gIHZhciB4bWxWYWx1ZSA9IHNoYXBlLnZhbHVlLm5hbWUgfHwgJ3ZhbHVlJztcbiAgdmFyIGl0ZXJhYmxlID0gc2hhcGUuZmxhdHRlbmVkID8geG1sIDogeG1sLmVudHJ5O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZXJhYmxlKSkge1xuICAgIHV0aWwuYXJyYXlFYWNoKGl0ZXJhYmxlLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgZGF0YVtjaGlsZFt4bWxLZXldWzBdXSA9IHBhcnNlWG1sKGNoaWxkW3htbFZhbHVlXVswXSwgc2hhcGUudmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGlzdCh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHZhciBuYW1lID0gc2hhcGUubWVtYmVyLm5hbWUgfHwgJ21lbWJlcic7XG4gIGlmIChzaGFwZS5mbGF0dGVuZWQpIHtcbiAgICB1dGlsLmFycmF5RWFjaCh4bWwsIGZ1bmN0aW9uKHhtbENoaWxkKSB7XG4gICAgICBkYXRhLnB1c2gocGFyc2VYbWwoeG1sQ2hpbGQsIHNoYXBlLm1lbWJlcikpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHhtbCAmJiBBcnJheS5pc0FycmF5KHhtbFtuYW1lXSkpIHtcbiAgICB1dGlsLmFycmF5RWFjaCh4bWxbbmFtZV0sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBkYXRhLnB1c2gocGFyc2VYbWwoY2hpbGQsIHNoYXBlLm1lbWJlcikpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2NhbGFyKHRleHQsIHNoYXBlKSB7XG4gIGlmICh0ZXh0ICYmIHRleHQuJCAmJiB0ZXh0LiQuZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgc2hhcGUgPSBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiB0ZXh0LiQuZW5jb2Rpbmd9KTtcbiAgfVxuICBpZiAodGV4dCAmJiB0ZXh0Ll8pIHRleHQgPSB0ZXh0Ll87XG5cbiAgaWYgKHR5cGVvZiBzaGFwZS50b1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hhcGUudG9UeXBlKHRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5rbm93bih4bWwpIHtcbiAgaWYgKHhtbCA9PT0gdW5kZWZpbmVkIHx8IHhtbCA9PT0gbnVsbCkgcmV0dXJuICcnO1xuICBpZiAodHlwZW9mIHhtbCA9PT0gJ3N0cmluZycpIHJldHVybiB4bWw7XG5cbiAgLy8gcGFyc2UgYSBsaXN0XG4gIGlmIChBcnJheS5pc0FycmF5KHhtbCkpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHhtbC5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyLnB1c2gocGFyc2VYbWwoeG1sW2ldLCB7fSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLy8gZW1wdHkgb2JqZWN0XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoeG1sKSwgaTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnJCcpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gb2JqZWN0LCBwYXJzZSBhcyBzdHJ1Y3R1cmVcbiAgdmFyIGRhdGEgPSB7fTtcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXSwgdmFsdWUgPSB4bWxba2V5XTtcbiAgICBpZiAoa2V5ID09PSAnJCcpIGNvbnRpbnVlO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7IC8vIHRoaXMgbWVtYmVyIGlzIGEgbGlzdFxuICAgICAgZGF0YVtrZXldID0gcGFyc2VMaXN0KHZhbHVlLCB7bWVtYmVyOiB7fX0pO1xuICAgIH0gZWxzZSB7IC8vIHRoaXMgbWVtYmVyIGlzIGEgc2luZ2xlIGl0ZW1cbiAgICAgIGRhdGFba2V5XSA9IHBhcnNlWG1sKHZhbHVlWzBdLCB7fSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVYbWxQYXJzZXI7XG4iLCJ2YXIgZXNjYXBlQXR0cmlidXRlID0gcmVxdWlyZSgnLi9lc2NhcGUtYXR0cmlidXRlJykuZXNjYXBlQXR0cmlidXRlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gWE1MIG5vZGUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gWG1sTm9kZShuYW1lLCBjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbn1cblhtbE5vZGUucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblhtbE5vZGUucHJvdG90eXBlLmFkZENoaWxkTm9kZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuWG1sTm9kZS5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgIHJldHVybiB0aGlzO1xufTtcblhtbE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNDaGlsZHJlbiA9IEJvb2xlYW4odGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIHZhciB4bWxUZXh0ID0gJzwnICsgdGhpcy5uYW1lO1xuICAgIC8vIGFkZCBhdHRyaWJ1dGVzXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7IGkgPCBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgIT09ICd1bmRlZmluZWQnICYmIGF0dHJpYnV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgeG1sVGV4dCArPSAnICcgKyBhdHRyaWJ1dGVOYW1lICsgJz1cXFwiJyArIGVzY2FwZUF0dHJpYnV0ZSgnJyArIGF0dHJpYnV0ZSkgKyAnXFxcIic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhtbFRleHQgKz0gIWhhc0NoaWxkcmVuID8gJy8+JyA6ICc+JyArIHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvU3RyaW5nKCk7IH0pLmpvaW4oJycpICsgJzwvJyArIHRoaXMubmFtZSArICc+Jztcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFhtbE5vZGU6IFhtbE5vZGVcbn07XG4iLCJ2YXIgZXNjYXBlRWxlbWVudCA9IHJlcXVpcmUoJy4vZXNjYXBlLWVsZW1lbnQnKS5lc2NhcGVFbGVtZW50O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gWE1MIHRleHQgdmFsdWUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gWG1sVGV4dCh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuWG1sVGV4dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVzY2FwZUVsZW1lbnQoJycgKyB0aGlzLnZhbHVlKTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFhtbFRleHQ6IFhtbFRleHRcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMUlVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0xSVVwiKTtcbnZhciBDQUNIRV9TSVpFID0gMTAwMDtcbi8qKlxuICogSW5zcGlyZWQgbm9kZS1scnUtY2FjaGVbaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWxydS1jYWNoZV1cbiAqL1xudmFyIEVuZHBvaW50Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5kcG9pbnRDYWNoZShtYXhTaXplKSB7XG4gICAgICAgIGlmIChtYXhTaXplID09PSB2b2lkIDApIHsgbWF4U2l6ZSA9IENBQ0hFX1NJWkU7IH1cbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBMUlVfMS5MUlVDYWNoZShtYXhTaXplKTtcbiAgICB9XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmRwb2ludENhY2hlLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIga2V5U3RyaW5nID0gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgPyBFbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhrZXkpIDoga2V5O1xuICAgICAgICB2YXIgZW5kcG9pbnRSZWNvcmQgPSB0aGlzLnBvcHVsYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLmNhY2hlLnB1dChrZXlTdHJpbmcsIGVuZHBvaW50UmVjb3JkKTtcbiAgICB9O1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBrZXlTdHJpbmcgPSB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyA/IEVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nKGtleSkgOiBrZXk7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuY2FjaGUuZ2V0KGtleVN0cmluZyk7XG4gICAgICAgIGlmIChyZWNvcmRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcmVjb3Jkcy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLkV4cGlyZSA8IG5vdykge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnJlbW92ZShrZXlTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLmdldEtleVN0cmluZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICAgIHZhciBpZGVudGlmaWVyTmFtZXMgPSBPYmplY3Qua2V5cyhrZXkpLnNvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZGVudGlmaWVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyTmFtZSA9IGlkZW50aWZpZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIGlmIChrZXlbaWRlbnRpZmllck5hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGtleVtpZGVudGlmaWVyTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVycy5qb2luKCcgJyk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5wb3B1bGF0ZVZhbHVlID0gZnVuY3Rpb24gKGVuZHBvaW50cykge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50cy5tYXAoZnVuY3Rpb24gKGVuZHBvaW50KSB7IHJldHVybiAoe1xuICAgICAgICAgICAgQWRkcmVzczogZW5kcG9pbnQuQWRkcmVzcyB8fCAnJyxcbiAgICAgICAgICAgIEV4cGlyZTogbm93ICsgKGVuZHBvaW50LkNhY2hlUGVyaW9kSW5NaW51dGVzIHx8IDEpICogNjAgKiAxMDAwXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhY2hlLmVtcHR5KCk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIga2V5U3RyaW5nID0gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgPyBFbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhrZXkpIDoga2V5O1xuICAgICAgICB0aGlzLmNhY2hlLnJlbW92ZShrZXlTdHJpbmcpO1xuICAgIH07XG4gICAgcmV0dXJuIEVuZHBvaW50Q2FjaGU7XG59KCkpO1xuZXhwb3J0cy5FbmRwb2ludENhY2hlID0gRW5kcG9pbnRDYWNoZTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaW5rZWRMaXN0Tm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rZWRMaXN0Tm9kZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBMaW5rZWRMaXN0Tm9kZTtcbn0oKSk7XG52YXIgTFJVQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTFJVQ2FjaGUoc2l6ZSkge1xuICAgICAgICB0aGlzLm5vZGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJyB8fCBzaXplIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSBzaXplIGNhbiBvbmx5IGJlIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZUxpbWl0ID0gc2l6ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5wcmVwZW5kVG9MaXN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWRlck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbE5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJOb2RlLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy5oZWFkZXJOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyTm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLnJlbW92ZUZyb21UYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFpbE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnRhaWxOb2RlO1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBub2RlLnByZXY7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgcHJldk5vZGUubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGFpbE5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmRldGFjaEZyb21MaXN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJOb2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRhaWxOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWxOb2RlID0gbm9kZS5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnByZXYpIHtcbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbm9kZS5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVNYXBba2V5XSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRnJvbUxpc3Qobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnByZXBlbmRUb0xpc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZU1hcFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hGcm9tTGlzdChub2RlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVNYXBba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNpemUgPT09IHRoaXMuc2l6ZUxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgdGFpbE5vZGUgPSB0aGlzLnJlbW92ZUZyb21UYWlsKCk7XG4gICAgICAgICAgICB2YXIga2V5XzEgPSB0YWlsTm9kZS5rZXk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2RlTWFwW2tleV8xXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ldyBMaW5rZWRMaXN0Tm9kZShrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwW2tleV0gPSBuZXdOb2RlO1xuICAgICAgICB0aGlzLnByZXBlbmRUb0xpc3QobmV3Tm9kZSk7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5ub2RlTWFwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgICAgICB0aGlzLmRldGFjaEZyb21MaXN0KG5vZGUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTFJVQ2FjaGU7XG59KCkpO1xuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlOyIsIihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIC8vIENoZWNrIHRoZSBzY2FsYXIgY2FzZSBmaXJzdC5cbiAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUgdHlwZS5cbiAgICB2YXIgZmlyc3RUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0KTtcbiAgICBpZiAoZmlyc3RUeXBlICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBrbm93IHRoYXQgZmlyc3QgYW5kIHNlY29uZCBoYXZlIHRoZSBzYW1lIHR5cGUgc28gd2UgY2FuIGp1c3QgY2hlY2sgdGhlXG4gICAgLy8gZmlyc3QgdHlwZSBmcm9tIG5vdyBvbi5cbiAgICBpZiAoaXNBcnJheShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgbGVuZ3RoO1xuICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gQW4gb2JqZWN0IGlzIGVxdWFsIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICB2YXIga2V5c1NlZW4gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmaXJzdCwga2V5KSkge1xuICAgICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzU2VlbltrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93IGNoZWNrIHRoYXQgdGhlcmUgYXJlbid0IGFueSBrZXlzIGluIHNlY29uZCB0aGF0IHdlcmVuJ3RcbiAgICAgIC8vIGluIGZpcnN0LlxuICAgICAgZm9yICh2YXIga2V5MiBpbiBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc2Vjb25kLCBrZXkyKSkge1xuICAgICAgICAgIGlmIChrZXlzU2VlbltrZXkyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2Uob2JqKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyBBIGZhbHNlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgIC8vIEVtcHR5IGxpc3RcbiAgICAvLyBFbXB0eSBvYmplY3RcbiAgICAvLyBFbXB0eSBzdHJpbmdcbiAgICAvLyBGYWxzZSBib29sZWFuXG4gICAgLy8gbnVsbCB2YWx1ZVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIHNjYWxhciB2YWx1ZXMuXG4gICAgaWYgKG9iaiA9PT0gXCJcIiB8fCBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkga2V5cywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBpcyBub3QgZW1wdHkgc28gdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IGZhbHNlLlxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqVmFsdWVzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleTIgaW4gYikge1xuICAgICAgICAgIG1lcmdlZFtrZXkyXSA9IGJba2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgdmFyIHRyaW1MZWZ0O1xuICBpZiAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1MZWZ0KCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvXlxccyooLiopLylbMV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFR5cGUgY29uc3RhbnRzIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgdmFyIFRZUEVfTlVNQkVSID0gMDtcbiAgdmFyIFRZUEVfQU5ZID0gMTtcbiAgdmFyIFRZUEVfU1RSSU5HID0gMjtcbiAgdmFyIFRZUEVfQVJSQVkgPSAzO1xuICB2YXIgVFlQRV9PQkpFQ1QgPSA0O1xuICB2YXIgVFlQRV9CT09MRUFOID0gNTtcbiAgdmFyIFRZUEVfRVhQUkVGID0gNjtcbiAgdmFyIFRZUEVfTlVMTCA9IDc7XG4gIHZhciBUWVBFX0FSUkFZX05VTUJFUiA9IDg7XG4gIHZhciBUWVBFX0FSUkFZX1NUUklORyA9IDk7XG5cbiAgdmFyIFRPS19FT0YgPSBcIkVPRlwiO1xuICB2YXIgVE9LX1VOUVVPVEVESURFTlRJRklFUiA9IFwiVW5xdW90ZWRJZGVudGlmaWVyXCI7XG4gIHZhciBUT0tfUVVPVEVESURFTlRJRklFUiA9IFwiUXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1JCUkFDS0VUID0gXCJSYnJhY2tldFwiO1xuICB2YXIgVE9LX1JQQVJFTiA9IFwiUnBhcmVuXCI7XG4gIHZhciBUT0tfQ09NTUEgPSBcIkNvbW1hXCI7XG4gIHZhciBUT0tfQ09MT04gPSBcIkNvbG9uXCI7XG4gIHZhciBUT0tfUkJSQUNFID0gXCJSYnJhY2VcIjtcbiAgdmFyIFRPS19OVU1CRVIgPSBcIk51bWJlclwiO1xuICB2YXIgVE9LX0NVUlJFTlQgPSBcIkN1cnJlbnRcIjtcbiAgdmFyIFRPS19FWFBSRUYgPSBcIkV4cHJlZlwiO1xuICB2YXIgVE9LX1BJUEUgPSBcIlBpcGVcIjtcbiAgdmFyIFRPS19PUiA9IFwiT3JcIjtcbiAgdmFyIFRPS19BTkQgPSBcIkFuZFwiO1xuICB2YXIgVE9LX0VRID0gXCJFUVwiO1xuICB2YXIgVE9LX0dUID0gXCJHVFwiO1xuICB2YXIgVE9LX0xUID0gXCJMVFwiO1xuICB2YXIgVE9LX0dURSA9IFwiR1RFXCI7XG4gIHZhciBUT0tfTFRFID0gXCJMVEVcIjtcbiAgdmFyIFRPS19ORSA9IFwiTkVcIjtcbiAgdmFyIFRPS19GTEFUVEVOID0gXCJGbGF0dGVuXCI7XG4gIHZhciBUT0tfU1RBUiA9IFwiU3RhclwiO1xuICB2YXIgVE9LX0ZJTFRFUiA9IFwiRmlsdGVyXCI7XG4gIHZhciBUT0tfRE9UID0gXCJEb3RcIjtcbiAgdmFyIFRPS19OT1QgPSBcIk5vdFwiO1xuICB2YXIgVE9LX0xCUkFDRSA9IFwiTGJyYWNlXCI7XG4gIHZhciBUT0tfTEJSQUNLRVQgPSBcIkxicmFja2V0XCI7XG4gIHZhciBUT0tfTFBBUkVOPSBcIkxwYXJlblwiO1xuICB2YXIgVE9LX0xJVEVSQUw9IFwiTGl0ZXJhbFwiO1xuXG4gIC8vIFRoZSBcIiZcIiwgXCJbXCIsIFwiPFwiLCBcIj5cIiB0b2tlbnNcbiAgLy8gYXJlIG5vdCBpbiBiYXNpY1Rva2VuIGJlY2F1c2VcbiAgLy8gdGhlcmUgYXJlIHR3byB0b2tlbiB2YXJpYW50c1xuICAvLyAoXCImJlwiLCBcIls/XCIsIFwiPD1cIiwgXCI+PVwiKS4gIFRoaXMgaXMgc3BlY2lhbGx5IGhhbmRsZWRcbiAgLy8gYmVsb3cuXG5cbiAgdmFyIGJhc2ljVG9rZW5zID0ge1xuICAgIFwiLlwiOiBUT0tfRE9ULFxuICAgIFwiKlwiOiBUT0tfU1RBUixcbiAgICBcIixcIjogVE9LX0NPTU1BLFxuICAgIFwiOlwiOiBUT0tfQ09MT04sXG4gICAgXCJ7XCI6IFRPS19MQlJBQ0UsXG4gICAgXCJ9XCI6IFRPS19SQlJBQ0UsXG4gICAgXCJdXCI6IFRPS19SQlJBQ0tFVCxcbiAgICBcIihcIjogVE9LX0xQQVJFTixcbiAgICBcIilcIjogVE9LX1JQQVJFTixcbiAgICBcIkBcIjogVE9LX0NVUlJFTlRcbiAgfTtcblxuICB2YXIgb3BlcmF0b3JTdGFydFRva2VuID0ge1xuICAgICAgXCI8XCI6IHRydWUsXG4gICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgIFwiPVwiOiB0cnVlLFxuICAgICAgXCIhXCI6IHRydWVcbiAgfTtcblxuICB2YXIgc2tpcENoYXJzID0ge1xuICAgICAgXCIgXCI6IHRydWUsXG4gICAgICBcIlxcdFwiOiB0cnVlLFxuICAgICAgXCJcXG5cIjogdHJ1ZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSBcImFcIiAmJiBjaCA8PSBcInpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiLVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjlcIikgfHxcbiAgICAgICAgICAgICBjaCA9PT0gXCJfXCI7XG4gIH1cblxuICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgfVxuICBMZXhlci5wcm90b3R5cGUgPSB7XG4gICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FscGhhKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLl9jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbVt0aGlzLl9jdXJyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50fSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTnVtYmVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBpbmNyZW1lbnQgdGhpcy5fY3VycmVudC4gIFRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gX2NvbnN1bWVMQnJhY2tldFxuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTEJyYWNrZXQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVF1b3RlZElkZW50aWZpZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVJhd1N0cmluZ0xpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiYFwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRoaXMuX2NvbnN1bWVMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JTdGFydFRva2VuW3N0cmVhbVt0aGlzLl9jdXJyZW50XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fY29uc3VtZU9wZXJhdG9yKHN0cmVhbSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfQU5ELCB2YWx1ZTogXCImJlwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FWFBSRUYsIHZhbHVlOiBcIiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19PUiwgdmFsdWU6IFwifHxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUElQRSwgdmFsdWU6IFwifFwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVua25vd24gY2hhcmFjdGVyOlwiICsgc3RyZWFtW3RoaXMuX2N1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkxleGVyRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoICYmIGlzQWxwaGFOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIlxcXCJcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgZG91YmxlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVJhd1N0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiJ1wiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBzaW5nbGUgcXVvdGUgYW5kIHlvdSBjYW4gZXNjYXBlIGFuIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHN0cmVhbS5zbGljZShzdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5yZXBsYWNlKFwiXFxcXCdcIiwgXCInXCIpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVOdW1iZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19OVU1CRVIsIHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTEJyYWNrZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfRklMVEVSLCB2YWx1ZTogXCJbP1wiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIl1cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZMQVRURU4sIHZhbHVlOiBcIltdXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTEJSQUNLRVQsIHZhbHVlOiBcIltcIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZU9wZXJhdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHZhciBzdGFydGluZ0NoYXIgPSBzdHJlYW1bc3RhcnRdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSBcIiFcIikge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTkUsIHZhbHVlOiBcIiE9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTk9ULCB2YWx1ZTogXCIhXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xURSwgdmFsdWU6IFwiPD1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xULCB2YWx1ZTogXCI8XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dURSwgdmFsdWU6IFwiPj1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dULCB2YWx1ZTogXCI+XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0VRLCB2YWx1ZTogXCI9PVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGl0ZXJhbDtcbiAgICAgICAgICB3aGlsZShzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiYFwiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBsaXRlcmFsIGNoYXIgb3IgeW91IGNhbiBlc2NhcGUgdGhlIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsU3RyaW5nID0gdHJpbUxlZnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgbGl0ZXJhbFN0cmluZyA9IGxpdGVyYWxTdHJpbmcucmVwbGFjZShcIlxcXFxgXCIsIFwiYFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va3NMaWtlSlNPTihsaXRlcmFsU3RyaW5nKSkge1xuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gSlNPTiBwYXJzZSBpdCBhcyBcIjxsaXRlcmFsPlwiXG4gICAgICAgICAgICAgIGxpdGVyYWwgPSBKU09OLnBhcnNlKFwiXFxcIlwiICsgbGl0ZXJhbFN0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKzEgZ2V0cyB1cyB0byB0aGUgZW5kaW5nIFwiYFwiLCArMSB0byBtb3ZlIG9uIHRvIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgfSxcblxuICAgICAgX2xvb2tzTGlrZUpTT046IGZ1bmN0aW9uKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFycyA9IFwiW3tcXFwiXCI7XG4gICAgICAgICAgdmFyIGpzb25MaXRlcmFscyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIl07XG4gICAgICAgICAgdmFyIG51bWJlckxvb2tpbmcgPSBcIi0wMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICBpZiAobGl0ZXJhbFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXJzLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb25MaXRlcmFscy5pbmRleE9mKGxpdGVyYWxTdHJpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJMb29raW5nLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IHt9O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FT0ZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfVU5RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1FVT1RFRElERU5USUZJRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUkJSQUNLRVRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUlBBUkVOXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NPTU1BXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDRV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OVU1CRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQ1VSUkVOVF0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FWFBSRUZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUElQRV0gPSAxO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19PUl0gPSAyO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19BTkRdID0gMztcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVFdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTFRdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RFXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19ORV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GTEFUVEVOXSA9IDk7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1NUQVJdID0gMjA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0ZJTFRFUl0gPSAyMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRE9UXSA9IDQwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OT1RdID0gNDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDRV0gPSA1MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTEJSQUNLRVRdID0gNTU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xQQVJFTl0gPSA2MDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkVG9rZW5zKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX0VPRikge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0LnR5cGUgKyBcIiwgdmFsdWU6IFwiICsgdC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfSxcblxuICAgICAgX2xvYWRUb2tlbnM6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FT0YsIHZhbHVlOiBcIlwiLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGh9KTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIH0sXG5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciBsZWZ0VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm51ZChsZWZ0VG9rZW4pO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgd2hpbGUgKHJicCA8IGJpbmRpbmdQb3dlcltjdXJyZW50VG9rZW5dKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlbiwgbGVmdCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleCArIG51bWJlcl0udHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rYWhlYWRUb2tlbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdO1xuICAgICAgfSxcblxuICAgICAgX2FkdmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0sXG5cbiAgICAgIG51ZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0xJVEVSQUw6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1VOUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJGaWVsZFwiLCBuYW1lOiB0b2tlbi52YWx1ZX07XG4gICAgICAgICAgY2FzZSBUT0tfUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHZhciBub2RlID0ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xQQVJFTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlZCBpZGVudGlmaWVyIG5vdCBhbGxvd2VkIGZvciBmdW5jdGlvbiBuYW1lcy5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUT0tfTk9UOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk5vdCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTm90RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW3JpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfU1RBUjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhIG11bHRpc2VsZWN0LFxuICAgICAgICAgICAgICAgIC8vIFthLCBiLCAqXVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0ge3R5cGU6IFwiSWRlbnRpdHlcIn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJWYWx1ZVByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZCh0b2tlbi50eXBlLCB7dHlwZTogXCJJZGVudGl0eVwifSk7XG4gICAgICAgICAgY2FzZSBUT0tfTEJSQUNFOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogVE9LX0ZMQVRURU4sIGNoaWxkcmVuOiBbe3R5cGU6IFwiSWRlbnRpdHlcIn1dfTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GbGF0dGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19OVU1CRVIgfHwgdGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlSW5kZXhFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RJZlNsaWNlKHt0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1NUQVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkKDEpID09PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifSwgcmlnaHRdfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgY2FzZSBUT0tfRVhQUkVGOlxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuRXhwcmVmKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJFeHByZXNzaW9uUmVmZXJlbmNlXCIsIGNoaWxkcmVuOiBbZXhwcmVzc2lvbl19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUlBBUkVOKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DVVJSRU5UKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxlZDogZnVuY3Rpb24odG9rZW5OYW1lLCBsZWZ0KSB7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgc3dpdGNoKHRva2VuTmFtZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0RPVDpcbiAgICAgICAgICAgIHZhciByYnAgPSBiaW5kaW5nUG93ZXIuRG90O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1NUQVIpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlRG90UkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlN1YmV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyBhIHByb2plY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfUElQRSwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX09SOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJPckV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0FORDpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5BbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkFuZEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGVmdC5uYW1lO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uLCBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICBub2RlID0ge3R5cGU6IFwiRnVuY3Rpb25cIiwgbmFtZTogbmFtZSwgY2hpbGRyZW46IGFyZ3N9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRkxBVFRFTikge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmlsdGVyUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0LCBjb25kaXRpb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0ge3R5cGU6IFRPS19GTEFUVEVOLCBjaGlsZHJlbjogW2xlZnRdfTtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0Tm9kZSwgcmlnaHROb2RlXX07XG4gICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgY2FzZSBUT0tfTkU6XG4gICAgICAgICAgY2FzZSBUT0tfR1Q6XG4gICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgIGNhc2UgVE9LX0xUOlxuICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS19OVU1CRVIgfHwgdG9rZW4udHlwZSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19TVEFSKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0aGlzLl9sb29rYWhlYWRUb2tlbigwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9tYXRjaDogZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gdG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIiArIHRva2VuVHlwZSArIFwiLCBnb3Q6IFwiICsgdC50eXBlKTtcbiAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2Vycm9yVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50eXBlICsgXCIpOiBcXFwiXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcblxuXG4gICAgICBfcGFyc2VJbmRleEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTiB8fCB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VTbGljZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9sb29rYWhlYWRUb2tlbigwKS52YWx1ZX07XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3Byb2plY3RJZlNsaWNlOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBpbmRleEV4cHIgPSB7dHlwZTogXCJJbmRleEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBcIlNsaWNlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtpbmRleEV4cHIsIHRoaXMuX3BhcnNlUHJvamVjdGlvblJIUyhiaW5kaW5nUG93ZXIuU3RhcildXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4RXhwcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VTbGljZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gd2hlcmUgZWFjaCBwYXJ0IGlzIG9wdGlvbmFsLCBhcyB3ZWxsIGFzIHRoZSBsYXN0XG4gICAgICAgICAgLy8gY29sb24uXG4gICAgICAgICAgdmFyIHBhcnRzID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudFRva2VuICE9PSBUT0tfUkJSQUNLRVQgJiYgaW5kZXggPCAzKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVuZXhwZWN0ZWQgdG9rZW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnRzXG4gICAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZUNvbXBhcmF0b3I6IGZ1bmN0aW9uKGxlZnQsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlcltjb21wYXJhdG9yXSk7XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJDb21wYXJhdG9yXCIsIG5hbWU6IGNvbXBhcmF0b3IsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZURvdFJIUzogZnVuY3Rpb24ocmJwKSB7XG4gICAgICAgICAgdmFyIGxvb2thaGVhZCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB2YXIgZXhwclRva2VucyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUiwgVE9LX1NUQVJdO1xuICAgICAgICAgIGlmIChleHByVG9rZW5zLmluZGV4T2YobG9va2FoZWFkKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZCA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0TGlzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNFKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0UpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VQcm9qZWN0aW9uUkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgICAgaWYgKGJpbmRpbmdQb3dlclt0aGlzLl9sb29rYWhlYWQoMCldIDwgMTApIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19GSUxURVIpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0RPVCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfRE9UKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5dGFueCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52YWx1ZSArIFwiKFwiICsgdC50eXBlICsgXCIpXCIpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFJicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0TGlzdFwiLCBjaGlsZHJlbjogZXhwcmVzc2lvbnN9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIHZhciBpZGVudGlmaWVyVHlwZXMgPSBbVE9LX1VOUVVPVEVESURFTlRJRklFUiwgVE9LX1FVT1RFRElERU5USUZJRVJdO1xuICAgICAgICB2YXIga2V5VG9rZW4sIGtleU5hbWUsIHZhbHVlLCBub2RlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAga2V5VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllclR5cGVzLmluZGV4T2Yoa2V5VG9rZW4udHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW4gaWRlbnRpZmllciB0b2tlbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VG9rZW4udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU5hbWUgPSBrZXlUb2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTE9OKTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICBub2RlID0ge3R5cGU6IFwiS2V5VmFsdWVQYWlyXCIsIG5hbWU6IGtleU5hbWUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgICAgcGFpcnMucHVzaChub2RlKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09NTUEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJNdWx0aVNlbGVjdEhhc2hcIiwgY2hpbGRyZW46IHBhaXJzfTtcbiAgICAgIH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIFRyZWVJbnRlcnByZXRlcihydW50aW1lKSB7XG4gICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgfVxuXG4gIFRyZWVJbnRlcnByZXRlci5wcm90b3R5cGUgPSB7XG4gICAgICBzZWFyY2g6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZSwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZWQsIGN1cnJlbnQsIHJlc3VsdCwgZmlyc3QsIHNlY29uZCwgZmllbGQsIGxlZnQsIHJpZ2h0LCBjb2xsZWN0ZWQsIGk7XG4gICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGaWVsZFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gdmFsdWVbbm9kZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTdWJleHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhcIjpcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHZhbHVlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2xpY2VQYXJhbXMgPSBub2RlLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVTbGljZVBhcmFtcyh2YWx1ZS5sZW5ndGgsIHNsaWNlUGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tcHV0ZWRbMF07XG4gICAgICAgICAgICAgIHZhciBzdG9wID0gY29tcHV0ZWRbMV07XG4gICAgICAgICAgICAgIHZhciBzdGVwID0gY29tcHV0ZWRbMl07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZVByb2plY3Rpb25cIjpcbiAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbGVmdCBjaGlsZC5cbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBvYmpWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJGaWx0ZXJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgIHZhciBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc2UobWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBmaWx0ZXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICAgICAgICAgICAgY2FzZSBcIkNvbXBhcmF0b3JcIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19FUTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIXN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVEU6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tcGFyYXRvcjogXCIgKyBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaC5hcHBseShtZXJnZWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGl0eVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RMaXN0XCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RIYXNoXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFtjaGlsZC5uYW1lXSA9IHRoaXMudmlzaXQoY2hpbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk9yRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICBjYXNlIFwiQW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiTm90RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNGYWxzZShmaXJzdCk7XG4gICAgICAgICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVE9LX1BJUEU6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY2FsbEZ1bmN0aW9uKG5vZGUubmFtZSwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgIHZhciByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyBhdHRyaWJ1dGUgc28gdGhlIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2tlciB2ZXJpZnkgdGhlIHR5cGUuXG4gICAgICAgICAgICAgIHJlZk5vZGUuam1lc3BhdGhUeXBlID0gVE9LX0VYUFJFRjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVTbGljZVBhcmFtczogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIHNsaWNlUGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWNlUGFyYW1zWzBdO1xuICAgICAgICB2YXIgc3RvcCA9IHNsaWNlUGFyYW1zWzFdO1xuICAgICAgICB2YXIgc3RlcCA9IHNsaWNlUGFyYW1zWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgc2xpY2UsIHN0ZXAgY2Fubm90IGJlIDBcIik7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBWYWx1ZU5lZ2F0aXZlID0gc3RlcCA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdGFydCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gLTEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0b3AsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkWzBdID0gc3RhcnQ7XG4gICAgICAgIGNvbXB1dGVkWzFdID0gc3RvcDtcbiAgICAgICAgY29tcHV0ZWRbMl0gPSBzdGVwO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgICB9LFxuXG4gICAgICBjYXBTbGljZVJhbmdlOiBmdW5jdGlvbihhcnJheUxlbmd0aCwgYWN0dWFsVmFsdWUsIHN0ZXApIHtcbiAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlICs9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gYXJyYXlMZW5ndGggLSAxIDogYXJyYXlMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3R1YWxWYWx1ZTtcbiAgICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJ1bnRpbWUoaW50ZXJwcmV0ZXIpIHtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuZnVuY3Rpb25UYWJsZSA9IHtcbiAgICAgICAgLy8gbmFtZTogW2Z1bmN0aW9uLCA8c2lnbmF0dXJlPl1cbiAgICAgICAgLy8gVGhlIDxzaWduYXR1cmU+IGNhbiBiZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGFyZ3M6IFtbdHlwZTEsIHR5cGUyXSwgW3R5cGUxLCB0eXBlMl1dLFxuICAgICAgICAvLyAgIHZhcmlhZGljOiB0cnVlfGZhbHNlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRWFjaCBhcmcgaW4gdGhlIGFyZyBsaXN0IGlzIGEgbGlzdCBvZiB2YWxpZCB0eXBlc1xuICAgICAgICAvLyAoaWYgdGhlIGZ1bmN0aW9uIGlzIG92ZXJsb2FkZWQgYW5kIHN1cHBvcnRzIG11bHRpcGxlXG4gICAgICAgIC8vIHR5cGVzLiAgSWYgdGhlIHR5cGUgaXMgXCJhbnlcIiB0aGVuIG5vIHR5cGUgY2hlY2tpbmdcbiAgICAgICAgLy8gb2NjdXJzIG9uIHRoZSBhcmd1bWVudC4gIFZhcmlhZGljIGlzIG9wdGlvbmFsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgcHJvdmlkZWQgaXMgYXNzdW1lZCB0byBiZSBmYWxzZS5cbiAgICAgICAgYWJzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQWJzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBhdmc6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25BdmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIGNlaWw6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25DZWlsLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBjb250YWluczoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ29udGFpbnMsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJlbmRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkddfSwge3R5cGVzOiBbVFlQRV9TVFJJTkddfV19LFxuICAgICAgICBmbG9vcjoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkZsb29yLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklORywgVFlQRV9BUlJBWSwgVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1hcCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0VYUFJFRl19LCB7dHlwZXM6IFtUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtZXJnZVwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1heEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHN1bToge19mdW5jOiB0aGlzLl9mdW5jdGlvblN1bSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSXX1dfSxcbiAgICAgICAgXCJzdGFydHNfd2l0aFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtaW5fYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1pbkJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25UeXBlLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBrZXlzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uS2V5cywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgdmFsdWVzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVmFsdWVzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBzb3J0OiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic29ydF9ieVwiOiB7XG4gICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9TVFJJTkddfSxcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklOR119XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfV19LFxuICAgICAgICBcInRvX2FycmF5XCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub0FycmF5LCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX3N0cmluZ1wiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9TdHJpbmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwidG9fbnVtYmVyXCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub051bWJlciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJub3RfbnVsbFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Ob3ROdWxsLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXSwgdmFyaWFkaWM6IHRydWV9XVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJ1bnRpbWUucHJvdG90eXBlID0ge1xuICAgIGNhbGxGdW5jdGlvbjogZnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZnVuY3Rpb25FbnRyeSA9IHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXTtcbiAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uOiBcIiArIG5hbWUgKyBcIigpXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsaWRhdGVBcmdzKG5hbWUsIHJlc29sdmVkQXJncywgZnVuY3Rpb25FbnRyeS5fc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbkVudHJ5Ll9mdW5jLmNhbGwodGhpcywgcmVzb2x2ZWRBcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlQXJnczogZnVuY3Rpb24obmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRpbmcgdGhlIGFyZ3MgcmVxdWlyZXMgdmFsaWRhdGluZ1xuICAgICAgICAvLyB0aGUgY29ycmVjdCBhcml0eSBhbmQgdGhlIGNvcnJlY3QgdHlwZSBvZiBlYWNoIGFyZy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgZGVjbGFyZWQgYXMgdmFyaWFkaWMsIHRoZW4gd2UgbmVlZFxuICAgICAgICAvLyBhIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3MgdG8gYmUgcmVxdWlyZWQuICBPdGhlcndpc2UgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIGFuIGV4YWN0IGFtb3VudC5cbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQ7XG4gICAgICAgIGlmIChzaWduYXR1cmVbc2lnbmF0dXJlLmxlbmd0aCAtIDFdLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgYXQgbGVhc3RcIiArIHNpZ25hdHVyZS5sZW5ndGggKyBwbHVyYWxpemVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbHVyYWxpemVkID0gc2lnbmF0dXJlLmxlbmd0aCA9PT0gMSA/IFwiIGFyZ3VtZW50XCIgOiBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgXCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3BlYztcbiAgICAgICAgdmFyIGFjdHVhbFR5cGU7XG4gICAgICAgIHZhciB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgYXJndW1lbnQgXCIgKyAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gYmUgdHlwZSBcIiArIGN1cnJlbnRTcGVjICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIHR5cGUgXCIgKyBhY3R1YWxUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3R5cGVNYXRjaGVzOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBhcmdWYWx1ZSkge1xuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQU5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HIHx8XG4gICAgICAgICAgICBleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9OVU1CRVIgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgdHlwZSBjYW4gZWl0aGVyIGp1c3QgYmUgYXJyYXksXG4gICAgICAgICAgICAvLyBvciBpdCBjYW4gcmVxdWlyZSBhIHNwZWNpZmljIHN1YnR5cGUgKGFycmF5IG9mIG51bWJlcnMpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGVzdCBjYXNlIGlzIGlmIFwiYXJyYXlcIiB3aXRoIG5vIHN1YnR5cGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gVFlQRV9BUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2hlY2sgc3VidHlwZXMuXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIGhhcyBwb3RlbnRpYWwgdG8gYmUgaW1wcm92ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgc3VidHlwZSA9IFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90eXBlTWF0Y2hlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRUeXBlTmFtZShhcmdWYWx1ZVtpXSksIHN1YnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0VHlwZU5hbWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX1NUUklORztcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQk9PTEVBTjtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bGxdXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX05VTEw7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwcmVmLiAgSWYgaXQgaGFzLCBpdCdzIGJlZW5cbiAgICAgICAgICAgICAgLy8gdGFnZ2VkIHdpdGggYSBqbWVzcGF0aFR5cGUgYXR0ciBvZiAnRXhwcmVmJztcbiAgICAgICAgICAgICAgaWYgKG9iai5qbWVzcGF0aFR5cGUgPT09IFRPS19FWFBSRUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9FWFBSRUY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfT0JKRUNUO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU3RhcnRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGFzdEluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uRW5kc1dpdGg6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgc3VmZml4ID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gc2VhcmNoU3RyLmluZGV4T2Yoc3VmZml4LCBzZWFyY2hTdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25SZXZlcnNlOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgIHZhciBvcmlnaW5hbFN0ciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgcmV2ZXJzZWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBvcmlnaW5hbFN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICByZXZlcnNlZFN0ciArPSBvcmlnaW5hbFN0cltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkU3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXZlcnNlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdLnNsaWNlKDApO1xuICAgICAgICAgIHJldmVyc2VkQXJyYXkucmV2ZXJzZSgpO1xuICAgICAgICAgIHJldHVybiByZXZlcnNlZEFycmF5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkFiczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ2VpbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQXZnOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBpbnB1dEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBpbnB1dEFycmF5Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ29udGFpbnM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA+PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25GbG9vcjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkxlbmd0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgaWYgKCFpc09iamVjdChyZXNvbHZlZEFyZ3NbMF0pKSB7XG4gICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQXMgZmFyIGFzIEkgY2FuIHRlbGwsIHRoZXJlJ3Mgbm8gd2F5IHRvIGdldCB0aGUgbGVuZ3RoXG4gICAgICAgICAvLyBvZiBhbiBvYmplY3Qgd2l0aG91dCBPKG4pIGl0ZXJhdGlvbiB0aHJvdWdoIHRoZSBvYmplY3QuXG4gICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKS5sZW5ndGg7XG4gICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXA6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIGludGVycHJldGVyID0gdGhpcy5faW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXBwZWQucHVzaChpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBlbGVtZW50c1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWVyZ2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWF4RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1heEVsZW1lbnQubG9jYWxlQ29tcGFyZShlbGVtZW50c1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXhFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1heEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWluRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmxvY2FsZUNvbXBhcmUobWluRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtaW5FbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pbkVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdW06IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgbGlzdFRvU3VtID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0VG9TdW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGxpc3RUb1N1bVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIGNhc2UgVFlQRV9BUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX09CSkVDVDpcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9FWFBSRUY6XG4gICAgICAgICAgICByZXR1cm4gXCJleHByZWZcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTDpcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25LZXlzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblZhbHVlczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uSm9pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBqb2luQ2hhciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RKb2luID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gbGlzdEpvaW4uam9pbihqb2luQ2hhcik7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvQXJyYXk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSA9PT0gVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzb2x2ZWRBcmdzWzBdXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvTnVtYmVyOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSArcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjb252ZXJ0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk5vdE51bGw6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1tpXSkgIT09IFRZUEVfTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnQ6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIHNvcnRlZEFycmF5LnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Tb3J0Qnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIGlmIChzb3J0ZWRBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHZhciByZXF1aXJlZFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShcbiAgICAgICAgICAgIGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHNvcnRlZEFycmF5WzBdKSk7XG4gICAgICAgIGlmIChbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXS5pbmRleE9mKHJlcXVpcmVkVHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYSBzdGFibGUgc29ydCBvdXQgb2YgYW4gdW5zdGFibGVcbiAgICAgICAgLy8gc29ydCBhbGdvcml0aG0sIHdlIGRlY29yYXRlL3NvcnQvdW5kZWNvcmF0ZSAoRFNVKVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG5ldyBsaXN0IG9mIFtpbmRleCwgZWxlbWVudF0gcGFpcnMuXG4gICAgICAgIC8vIEluIHRoZSBjbXAgZnVuY3Rpb24sIGlmIHRoZSBldmFsdWF0ZWQgZWxlbWVudHMgYXJlXG4gICAgICAgIC8vIGVxdWFsLCB0aGVuIHRoZSBpbmRleCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRpZWJyZWFrZXIuXG4gICAgICAgIC8vIEFmdGVyIHRoZSBkZWNvcmF0ZWQgbGlzdCBoYXMgYmVlbiBzb3J0ZWQsIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdG8gZXh0cmFjdCB0aGUgb3JpZ2luYWwgZWxlbWVudHMuXG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY29yYXRlZC5wdXNoKFtpLCBzb3J0ZWRBcnJheVtpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICB2YXIgZXhwckEgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBhWzFdKTtcbiAgICAgICAgICB2YXIgZXhwckIgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBiWzFdKTtcbiAgICAgICAgICBpZiAodGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpICE9PSByZXF1aXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUeXBlRXJyb3I6IGV4cGVjdGVkIFwiICsgcmVxdWlyZWRUeXBlICsgXCIsIHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFR5cGVOYW1lKGV4cHJBKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQikgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cHJBID4gZXhwckIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwckEgPCBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGVxdWFsIGNvbXBhcmUgdGhlIGl0ZW1zIGJ5IHRoZWlyXG4gICAgICAgICAgICAvLyBvcmRlciB0byBtYWludGFpbiByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBrZXlzXG4gICAgICAgICAgICAvLyAoaS5lLiB0byBnZXQgYSBzdGFibGUgc29ydCkuXG4gICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5kZWNvcmF0ZTogZXh0cmFjdCBvdXQgdGhlIG9yaWdpbmFsIGxpc3QgZWxlbWVudHMuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVjb3JhdGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc29ydGVkQXJyYXlbal0gPSBkZWNvcmF0ZWRbal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXhCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIHZhciByZXNvbHZlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXSk7XG4gICAgICB2YXIgbWF4TnVtYmVyID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heFJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiBtYXhOdW1iZXIpIHtcbiAgICAgICAgICBtYXhOdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1heFJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhSZWNvcmQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbkJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtaW5OdW1iZXIgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5SZWNvcmQ7XG4gICAgICB2YXIgY3VycmVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0ga2V5RnVuY3Rpb24ocmVzb2x2ZWRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgbWluTnVtYmVyKSB7XG4gICAgICAgICAgbWluTnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICBtaW5SZWNvcmQgPSByZXNvbHZlZEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUmVjb3JkO1xuICAgIH0sXG5cbiAgICBjcmVhdGVLZXlGdW5jdGlvbjogZnVuY3Rpb24oZXhwcmVmTm9kZSwgYWxsb3dlZFR5cGVzKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBrZXlGdW5jID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHgpO1xuICAgICAgICBpZiAoYWxsb3dlZFR5cGVzLmluZGV4T2YodGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCkpIDwgMCkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgb25lIG9mIFwiICsgYWxsb3dlZFR5cGVzICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHJlY2VpdmVkIFwiICsgdGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGtleUZ1bmM7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZShzdHJlYW0pIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2Uoc3RyZWFtKTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyZWFtKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgIHJldHVybiBsZXhlci50b2tlbml6ZShzdHJlYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKGRhdGEsIGV4cHJlc3Npb24pIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGltcHJvdmVkLiAgQm90aCB0aGUgaW50ZXJwcmV0ZXIgYW5kIHJ1bnRpbWUgZGVwZW5kIG9uXG4gICAgICAvLyBlYWNoIG90aGVyLiAgVGhlIHJ1bnRpbWUgbmVlZHMgdGhlIGludGVycHJldGVyIHRvIHN1cHBvcnQgZXhwcmVmcy5cbiAgICAgIC8vIFRoZXJlJ3MgbGlrZWx5IGEgY2xlYW4gd2F5IHRvIGF2b2lkIHRoZSBjeWNsaWMgZGVwZW5kZW5jeS5cbiAgICAgIHZhciBydW50aW1lID0gbmV3IFJ1bnRpbWUoKTtcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IG5ldyBUcmVlSW50ZXJwcmV0ZXIocnVudGltZSk7XG4gICAgICBydW50aW1lLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgICAgdmFyIG5vZGUgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXIuc2VhcmNoKG5vZGUsIGRhdGEpO1xuICB9XG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xuICBleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuICBleHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcbiAgZXhwb3J0cy5zdHJpY3REZWVwRXF1YWwgPSBzdHJpY3REZWVwRXF1YWw7XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuam1lc3BhdGggPSB7fSA6IGV4cG9ydHMpO1xuIiwiOyhmdW5jdGlvbiAoc2F4KSB7IC8vIHdyYXBwZXIgZm9yIG5vbi1ub2RlIGVudnNcbiAgc2F4LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpY3QsIG9wdCkgeyByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCkgfVxuICBzYXguU0FYUGFyc2VyID0gU0FYUGFyc2VyXG4gIHNheC5TQVhTdHJlYW0gPSBTQVhTdHJlYW1cbiAgc2F4LmNyZWF0ZVN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuXG4gIC8vIFdoZW4gd2UgcGFzcyB0aGUgTUFYX0JVRkZFUl9MRU5HVEggcG9zaXRpb24sIHN0YXJ0IGNoZWNraW5nIGZvciBidWZmZXIgb3ZlcnJ1bnMuXG4gIC8vIFdoZW4gd2UgY2hlY2ssIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciBNQVhfQlVGRkVSX0xFTkdUSCAtIChtYXgoYnVmZmVyIGxlbmd0aHMpKSxcbiAgLy8gc2luY2UgdGhhdCdzIHRoZSBlYXJsaWVzdCB0aGF0IGEgYnVmZmVyIG92ZXJydW4gY291bGQgb2NjdXIuICBUaGlzIHdheSwgY2hlY2tzIGFyZVxuICAvLyBhcyByYXJlIGFzIHJlcXVpcmVkLCBidXQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBuZXZlciBjcm9zc2luZyB0aGlzIGJvdW5kLlxuICAvLyBGdXJ0aGVybW9yZSwgYnVmZmVycyBhcmUgb25seSB0ZXN0ZWQgYXQgbW9zdCBvbmNlIHBlciB3cml0ZSgpLCBzbyBwYXNzaW5nIGEgdmVyeVxuICAvLyBsYXJnZSBzdHJpbmcgaW50byB3cml0ZSgpIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cywgYnV0IHRoaXMgaXMgbWFuYWdlYWJsZSBieVxuICAvLyB0aGUgY2FsbGVyLCBzbyBpdCBpcyBhc3N1bWVkIHRvIGJlIHNhZmUuICBUaHVzLCBhIGNhbGwgdG8gd3JpdGUoKSBtYXksIGluIHRoZSBleHRyZW1lXG4gIC8vIGVkZ2UgY2FzZSwgcmVzdWx0IGluIGNyZWF0aW5nIGF0IG1vc3Qgb25lIGNvbXBsZXRlIGNvcHkgb2YgdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gIC8vIFNldCB0byBJbmZpbml0eSB0byBoYXZlIHVubGltaXRlZCBidWZmZXJzLlxuICBzYXguTUFYX0JVRkZFUl9MRU5HVEggPSA2NCAqIDEwMjRcblxuICB2YXIgYnVmZmVycyA9IFtcbiAgICAnY29tbWVudCcsICdzZ21sRGVjbCcsICd0ZXh0Tm9kZScsICd0YWdOYW1lJywgJ2RvY3R5cGUnLFxuICAgICdwcm9jSW5zdE5hbWUnLCAncHJvY0luc3RCb2R5JywgJ2VudGl0eScsICdhdHRyaWJOYW1lJyxcbiAgICAnYXR0cmliVmFsdWUnLCAnY2RhdGEnLCAnc2NyaXB0J1xuICBdXG5cbiAgc2F4LkVWRU5UUyA9IFtcbiAgICAndGV4dCcsXG4gICAgJ3Byb2Nlc3NpbmdpbnN0cnVjdGlvbicsXG4gICAgJ3NnbWxkZWNsYXJhdGlvbicsXG4gICAgJ2RvY3R5cGUnLFxuICAgICdjb21tZW50JyxcbiAgICAnb3BlbnRhZ3N0YXJ0JyxcbiAgICAnYXR0cmlidXRlJyxcbiAgICAnb3BlbnRhZycsXG4gICAgJ2Nsb3NldGFnJyxcbiAgICAnb3BlbmNkYXRhJyxcbiAgICAnY2RhdGEnLFxuICAgICdjbG9zZWNkYXRhJyxcbiAgICAnZXJyb3InLFxuICAgICdlbmQnLFxuICAgICdyZWFkeScsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ29wZW5uYW1lc3BhY2UnLFxuICAgICdjbG9zZW5hbWVzcGFjZSdcbiAgXVxuXG4gIGZ1bmN0aW9uIFNBWFBhcnNlciAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBjbGVhckJ1ZmZlcnMocGFyc2VyKVxuICAgIHBhcnNlci5xID0gcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIXG4gICAgcGFyc2VyLm9wdCA9IG9wdCB8fCB7fVxuICAgIHBhcnNlci5vcHQubG93ZXJjYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgfHwgcGFyc2VyLm9wdC5sb3dlcmNhc2V0YWdzXG4gICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gJ3RvTG93ZXJDYXNlJyA6ICd0b1VwcGVyQ2FzZSdcbiAgICBwYXJzZXIudGFncyA9IFtdXG4gICAgcGFyc2VyLmNsb3NlZCA9IHBhcnNlci5jbG9zZWRSb290ID0gcGFyc2VyLnNhd1Jvb3QgPSBmYWxzZVxuICAgIHBhcnNlci50YWcgPSBwYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0XG4gICAgcGFyc2VyLm5vc2NyaXB0ID0gISEoc3RyaWN0IHx8IHBhcnNlci5vcHQubm9zY3JpcHQpXG4gICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTlxuICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXNcbiAgICBwYXJzZXIuRU5USVRJRVMgPSBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPyBPYmplY3QuY3JlYXRlKHNheC5YTUxfRU5USVRJRVMpIDogT2JqZWN0LmNyZWF0ZShzYXguRU5USVRJRVMpXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXVxuXG4gICAgLy8gbmFtZXNwYWNlcyBmb3JtIGEgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIGl0IGFsd2F5cyBwb2ludHMgYXQgdGhlIGN1cnJlbnQgdGFnLFxuICAgIC8vIHdoaWNoIHByb3RvcyB0byBpdHMgcGFyZW50IHRhZy5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgcGFyc2VyLm5zID0gT2JqZWN0LmNyZWF0ZShyb290TlMpXG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGp1c3QgZm9yIGVycm9yIHJlcG9ydGluZ1xuICAgIHBhcnNlci50cmFja1Bvc2l0aW9uID0gcGFyc2VyLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2VcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIHBhcnNlci5wb3NpdGlvbiA9IHBhcnNlci5saW5lID0gcGFyc2VyLmNvbHVtbiA9IDBcbiAgICB9XG4gICAgZW1pdChwYXJzZXIsICdvbnJlYWR5JylcbiAgfVxuXG4gIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gRiAoKSB7fVxuICAgICAgRi5wcm90b3R5cGUgPSBvXG4gICAgICB2YXIgbmV3ZiA9IG5ldyBGKClcbiAgICAgIHJldHVybiBuZXdmXG4gICAgfVxuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhID0gW11cbiAgICAgIGZvciAodmFyIGkgaW4gbykgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIGEucHVzaChpKVxuICAgICAgcmV0dXJuIGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aCAocGFyc2VyKSB7XG4gICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXguTUFYX0JVRkZFUl9MRU5HVEgsIDEwKVxuICAgIHZhciBtYXhBY3R1YWwgPSAwXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGhcbiAgICAgIGlmIChsZW4gPiBtYXhBbGxvd2VkKSB7XG4gICAgICAgIC8vIFRleHQvY2RhdGEgbm9kZXMgY2FuIGdldCBiaWcsIGFuZCBzaW5jZSB0aGV5J3JlIGJ1ZmZlcmVkLFxuICAgICAgICAvLyB3ZSBjYW4gZ2V0IGhlcmUgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXG4gICAgICAgIC8vIEF2b2lkIGlzc3VlcyBieSBlbWl0dGluZyB0aGUgdGV4dCBub2RlIG5vdyxcbiAgICAgICAgLy8gc28gYXQgbGVhc3QgaXQgd29uJ3QgZ2V0IGFueSBiaWdnZXIuXG4gICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ3RleHROb2RlJzpcbiAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnY2RhdGEnOlxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsICdNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogJyArIGJ1ZmZlcnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heEFjdHVhbCA9IE1hdGgubWF4KG1heEFjdHVhbCwgbGVuKVxuICAgIH1cbiAgICAvLyBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGJ1ZmZlciBvdmVycnVuLlxuICAgIHZhciBtID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIIC0gbWF4QWN0dWFsXG4gICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcnMgKHBhcnNlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcnNlcltidWZmZXJzW2ldXSA9ICcnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIuY2RhdGEgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zY3JpcHQgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG4gIH1cblxuICBTQVhQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGVuZDogZnVuY3Rpb24gKCkgeyBlbmQodGhpcykgfSxcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7IHRoaXMuZXJyb3IgPSBudWxsOyByZXR1cm4gdGhpcyB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndyaXRlKG51bGwpIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHsgZmx1c2hCdWZmZXJzKHRoaXMpIH1cbiAgfVxuXG4gIHZhciBTdHJlYW1cbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIHN0cmVhbVdyYXBzID0gc2F4LkVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgcmV0dXJuIGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnZW5kJ1xuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdClcbiAgfVxuXG4gIGZ1bmN0aW9uIFNBWFN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgU3RyZWFtLmFwcGx5KHRoaXMpXG5cbiAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcblxuICAgIHZhciBtZSA9IHRoaXNcblxuICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmVtaXQoJ2VuZCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIG1lLmVtaXQoJ2Vycm9yJywgZXIpXG5cbiAgICAgIC8vIGlmIGRpZG4ndCB0aHJvdywgdGhlbiBtZWFucyBlcnJvciB3YXMgaGFuZGxlZC5cbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBjbGVhciBlcnJvciwgc28gd2UgY2FuIHdyaXRlIGFnYWluLlxuICAgICAgbWUuX3BhcnNlci5lcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuXG4gICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ29uJyArIGV2LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyWydvbicgKyBldl1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gaFxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgICB9XG4gICAgICAgICAgbWUub24oZXYsIGgpXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IFNBWFN0cmVhbVxuICAgIH1cbiAgfSlcblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICAgICAgdmFyIFNEID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG4gICAgICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU0QoJ3V0ZjgnKVxuICAgICAgfVxuICAgICAgZGF0YSA9IHRoaXMuX2RlY29kZXIud3JpdGUoZGF0YSlcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YS50b1N0cmluZygpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgdGhpcy53cml0ZShjaHVuaylcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VyLmVuZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGhhbmRsZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzXG4gICAgaWYgKCFtZS5fcGFyc2VyWydvbicgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICBtZS5fcGFyc2VyWydvbicgKyBldl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICBhcmdzLnNwbGljZSgwLCAwLCBldilcbiAgICAgICAgbWUuZW1pdC5hcHBseShtZSwgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKG1lLCBldiwgaGFuZGxlcilcbiAgfVxuXG4gIC8vIGNoYXJhY3RlciBjbGFzc2VzIGFuZCB0b2tlbnNcbiAgdmFyIHdoaXRlc3BhY2UgPSAnXFxyXFxuXFx0ICdcblxuICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gIHZhciBudW1iZXIgPSAnMDEyNDM1Njc4OSdcbiAgdmFyIGxldHRlciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ1xuXG4gIC8vIChMZXR0ZXIgfCBcIl9cIiB8IFwiOlwiKVxuICB2YXIgcXVvdGUgPSAnXFwnXCInXG4gIHZhciBhdHRyaWJFbmQgPSB3aGl0ZXNwYWNlICsgJz4nXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gdHVybiBhbGwgdGhlIHN0cmluZyBjaGFyYWN0ZXIgc2V0cyBpbnRvIGNoYXJhY3RlciBjbGFzcyBvYmplY3RzLlxuICB3aGl0ZXNwYWNlID0gY2hhckNsYXNzKHdoaXRlc3BhY2UpXG4gIG51bWJlciA9IGNoYXJDbGFzcyhudW1iZXIpXG4gIGxldHRlciA9IGNoYXJDbGFzcyhsZXR0ZXIpXG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXFwuXFxkLV0vXG5cbiAgdmFyIGVudGl0eVN0YXJ0ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuICB2YXIgZW50aXR5Qm9keSA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MFxcLlxcZC1dL1xuXG4gIHF1b3RlID0gY2hhckNsYXNzKHF1b3RlKVxuICBhdHRyaWJFbmQgPSBjaGFyQ2xhc3MoYXR0cmliRW5kKVxuXG4gIGZ1bmN0aW9uIGNoYXJDbGFzcyAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzLCBjKSB7XG4gICAgICBzW2NdID0gdHJ1ZVxuICAgICAgcmV0dXJuIHNcbiAgICB9LCB7fSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVnRXhwIChjKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzIChjaGFyY2xhc3MsIGMpIHtcbiAgICByZXR1cm4gaXNSZWdFeHAoY2hhcmNsYXNzKSA/ICEhYy5tYXRjaChjaGFyY2xhc3MpIDogY2hhcmNsYXNzW2NdXG4gIH1cblxuICBmdW5jdGlvbiBub3QgKGNoYXJjbGFzcywgYykge1xuICAgIHJldHVybiAhaXMoY2hhcmNsYXNzLCBjKVxuICB9XG5cbiAgdmFyIFMgPSAwXG4gIHNheC5TVEFURSA9IHtcbiAgICBCRUdJTjogUysrLCAvLyBsZWFkaW5nIGJ5dGUgb3JkZXIgbWFyayBvciB3aGl0ZXNwYWNlXG4gICAgQkVHSU5fV0hJVEVTUEFDRTogUysrLCAvLyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICBURVhUOiBTKyssIC8vIGdlbmVyYWwgc3R1ZmZcbiAgICBURVhUX0VOVElUWTogUysrLCAvLyAmYW1wIGFuZCBzdWNoLlxuICAgIE9QRU5fV0FLQTogUysrLCAvLyA8XG4gICAgU0dNTF9ERUNMOiBTKyssIC8vIDwhQkxBUkdcbiAgICBTR01MX0RFQ0xfUVVPVEVEOiBTKyssIC8vIDwhQkxBUkcgZm9vIFwiYmFyXG4gICAgRE9DVFlQRTogUysrLCAvLyA8IURPQ1RZUEVcbiAgICBET0NUWVBFX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcbiAgICBET0NUWVBFX0RURDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIC4uLlxuICAgIERPQ1RZUEVfRFREX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIFwiZm9vXG4gICAgQ09NTUVOVF9TVEFSVElORzogUysrLCAvLyA8IS1cbiAgICBDT01NRU5UOiBTKyssIC8vIDwhLS1cbiAgICBDT01NRU5UX0VORElORzogUysrLCAvLyA8IS0tIGJsYWggLVxuICAgIENPTU1FTlRfRU5ERUQ6IFMrKywgLy8gPCEtLSBibGFoIC0tXG4gICAgQ0RBVEE6IFMrKywgLy8gPCFbQ0RBVEFbIHNvbWV0aGluZ1xuICAgIENEQVRBX0VORElORzogUysrLCAvLyBdXG4gICAgQ0RBVEFfRU5ESU5HXzI6IFMrKywgLy8gXV1cbiAgICBQUk9DX0lOU1Q6IFMrKywgLy8gPD9oaVxuICAgIFBST0NfSU5TVF9CT0RZOiBTKyssIC8vIDw/aGkgdGhlcmVcbiAgICBQUk9DX0lOU1RfRU5ESU5HOiBTKyssIC8vIDw/aGkgXCJ0aGVyZVwiID9cbiAgICBPUEVOX1RBRzogUysrLCAvLyA8c3Ryb25nXG4gICAgT1BFTl9UQUdfU0xBU0g6IFMrKywgLy8gPHN0cm9uZyAvXG4gICAgQVRUUklCOiBTKyssIC8vIDxhXG4gICAgQVRUUklCX05BTUU6IFMrKywgLy8gPGEgZm9vXG4gICAgQVRUUklCX05BTUVfU0FXX1dISVRFOiBTKyssIC8vIDxhIGZvbyBfXG4gICAgQVRUUklCX1ZBTFVFOiBTKyssIC8vIDxhIGZvbz1cbiAgICBBVFRSSUJfVkFMVUVfUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1cImJhclxuICAgIEFUVFJJQl9WQUxVRV9DTE9TRUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXCJcbiAgICBBVFRSSUJfVkFMVUVfVU5RVU9URUQ6IFMrKywgLy8gPGEgZm9vPWJhclxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfUTogUysrLCAvLyA8Zm9vIGJhcj1cIiZxdW90O1wiXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9VOiBTKyssIC8vIDxmb28gYmFyPSZxdW90XG4gICAgQ0xPU0VfVEFHOiBTKyssIC8vIDwvYVxuICAgIENMT1NFX1RBR19TQVdfV0hJVEU6IFMrKywgLy8gPC9hICAgPlxuICAgIFNDUklQVDogUysrLCAvLyA8c2NyaXB0PiAuLi5cbiAgICBTQ1JJUFRfRU5ESU5HOiBTKysgLy8gPHNjcmlwdD4gLi4uIDxcbiAgfVxuXG4gIHNheC5YTUxfRU5USVRJRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdxdW90JzogJ1wiJyxcbiAgICAnYXBvcyc6IFwiJ1wiXG4gIH1cblxuICBzYXguRU5USVRJRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdxdW90JzogJ1wiJyxcbiAgICAnYXBvcyc6IFwiJ1wiLFxuICAgICdBRWxpZyc6IDE5OCxcbiAgICAnQWFjdXRlJzogMTkzLFxuICAgICdBY2lyYyc6IDE5NCxcbiAgICAnQWdyYXZlJzogMTkyLFxuICAgICdBcmluZyc6IDE5NyxcbiAgICAnQXRpbGRlJzogMTk1LFxuICAgICdBdW1sJzogMTk2LFxuICAgICdDY2VkaWwnOiAxOTksXG4gICAgJ0VUSCc6IDIwOCxcbiAgICAnRWFjdXRlJzogMjAxLFxuICAgICdFY2lyYyc6IDIwMixcbiAgICAnRWdyYXZlJzogMjAwLFxuICAgICdFdW1sJzogMjAzLFxuICAgICdJYWN1dGUnOiAyMDUsXG4gICAgJ0ljaXJjJzogMjA2LFxuICAgICdJZ3JhdmUnOiAyMDQsXG4gICAgJ0l1bWwnOiAyMDcsXG4gICAgJ050aWxkZSc6IDIwOSxcbiAgICAnT2FjdXRlJzogMjExLFxuICAgICdPY2lyYyc6IDIxMixcbiAgICAnT2dyYXZlJzogMjEwLFxuICAgICdPc2xhc2gnOiAyMTYsXG4gICAgJ090aWxkZSc6IDIxMyxcbiAgICAnT3VtbCc6IDIxNCxcbiAgICAnVEhPUk4nOiAyMjIsXG4gICAgJ1VhY3V0ZSc6IDIxOCxcbiAgICAnVWNpcmMnOiAyMTksXG4gICAgJ1VncmF2ZSc6IDIxNyxcbiAgICAnVXVtbCc6IDIyMCxcbiAgICAnWWFjdXRlJzogMjIxLFxuICAgICdhYWN1dGUnOiAyMjUsXG4gICAgJ2FjaXJjJzogMjI2LFxuICAgICdhZWxpZyc6IDIzMCxcbiAgICAnYWdyYXZlJzogMjI0LFxuICAgICdhcmluZyc6IDIyOSxcbiAgICAnYXRpbGRlJzogMjI3LFxuICAgICdhdW1sJzogMjI4LFxuICAgICdjY2VkaWwnOiAyMzEsXG4gICAgJ2VhY3V0ZSc6IDIzMyxcbiAgICAnZWNpcmMnOiAyMzQsXG4gICAgJ2VncmF2ZSc6IDIzMixcbiAgICAnZXRoJzogMjQwLFxuICAgICdldW1sJzogMjM1LFxuICAgICdpYWN1dGUnOiAyMzcsXG4gICAgJ2ljaXJjJzogMjM4LFxuICAgICdpZ3JhdmUnOiAyMzYsXG4gICAgJ2l1bWwnOiAyMzksXG4gICAgJ250aWxkZSc6IDI0MSxcbiAgICAnb2FjdXRlJzogMjQzLFxuICAgICdvY2lyYyc6IDI0NCxcbiAgICAnb2dyYXZlJzogMjQyLFxuICAgICdvc2xhc2gnOiAyNDgsXG4gICAgJ290aWxkZSc6IDI0NSxcbiAgICAnb3VtbCc6IDI0NixcbiAgICAnc3psaWcnOiAyMjMsXG4gICAgJ3Rob3JuJzogMjU0LFxuICAgICd1YWN1dGUnOiAyNTAsXG4gICAgJ3VjaXJjJzogMjUxLFxuICAgICd1Z3JhdmUnOiAyNDksXG4gICAgJ3V1bWwnOiAyNTIsXG4gICAgJ3lhY3V0ZSc6IDI1MyxcbiAgICAneXVtbCc6IDI1NSxcbiAgICAnY29weSc6IDE2OSxcbiAgICAncmVnJzogMTc0LFxuICAgICduYnNwJzogMTYwLFxuICAgICdpZXhjbCc6IDE2MSxcbiAgICAnY2VudCc6IDE2MixcbiAgICAncG91bmQnOiAxNjMsXG4gICAgJ2N1cnJlbic6IDE2NCxcbiAgICAneWVuJzogMTY1LFxuICAgICdicnZiYXInOiAxNjYsXG4gICAgJ3NlY3QnOiAxNjcsXG4gICAgJ3VtbCc6IDE2OCxcbiAgICAnb3JkZic6IDE3MCxcbiAgICAnbGFxdW8nOiAxNzEsXG4gICAgJ25vdCc6IDE3MixcbiAgICAnc2h5JzogMTczLFxuICAgICdtYWNyJzogMTc1LFxuICAgICdkZWcnOiAxNzYsXG4gICAgJ3BsdXNtbic6IDE3NyxcbiAgICAnc3VwMSc6IDE4NSxcbiAgICAnc3VwMic6IDE3OCxcbiAgICAnc3VwMyc6IDE3OSxcbiAgICAnYWN1dGUnOiAxODAsXG4gICAgJ21pY3JvJzogMTgxLFxuICAgICdwYXJhJzogMTgyLFxuICAgICdtaWRkb3QnOiAxODMsXG4gICAgJ2NlZGlsJzogMTg0LFxuICAgICdvcmRtJzogMTg2LFxuICAgICdyYXF1byc6IDE4NyxcbiAgICAnZnJhYzE0JzogMTg4LFxuICAgICdmcmFjMTInOiAxODksXG4gICAgJ2ZyYWMzNCc6IDE5MCxcbiAgICAnaXF1ZXN0JzogMTkxLFxuICAgICd0aW1lcyc6IDIxNSxcbiAgICAnZGl2aWRlJzogMjQ3LFxuICAgICdPRWxpZyc6IDMzOCxcbiAgICAnb2VsaWcnOiAzMzksXG4gICAgJ1NjYXJvbic6IDM1MixcbiAgICAnc2Nhcm9uJzogMzUzLFxuICAgICdZdW1sJzogMzc2LFxuICAgICdmbm9mJzogNDAyLFxuICAgICdjaXJjJzogNzEwLFxuICAgICd0aWxkZSc6IDczMixcbiAgICAnQWxwaGEnOiA5MTMsXG4gICAgJ0JldGEnOiA5MTQsXG4gICAgJ0dhbW1hJzogOTE1LFxuICAgICdEZWx0YSc6IDkxNixcbiAgICAnRXBzaWxvbic6IDkxNyxcbiAgICAnWmV0YSc6IDkxOCxcbiAgICAnRXRhJzogOTE5LFxuICAgICdUaGV0YSc6IDkyMCxcbiAgICAnSW90YSc6IDkyMSxcbiAgICAnS2FwcGEnOiA5MjIsXG4gICAgJ0xhbWJkYSc6IDkyMyxcbiAgICAnTXUnOiA5MjQsXG4gICAgJ051JzogOTI1LFxuICAgICdYaSc6IDkyNixcbiAgICAnT21pY3Jvbic6IDkyNyxcbiAgICAnUGknOiA5MjgsXG4gICAgJ1Jobyc6IDkyOSxcbiAgICAnU2lnbWEnOiA5MzEsXG4gICAgJ1RhdSc6IDkzMixcbiAgICAnVXBzaWxvbic6IDkzMyxcbiAgICAnUGhpJzogOTM0LFxuICAgICdDaGknOiA5MzUsXG4gICAgJ1BzaSc6IDkzNixcbiAgICAnT21lZ2EnOiA5MzcsXG4gICAgJ2FscGhhJzogOTQ1LFxuICAgICdiZXRhJzogOTQ2LFxuICAgICdnYW1tYSc6IDk0NyxcbiAgICAnZGVsdGEnOiA5NDgsXG4gICAgJ2Vwc2lsb24nOiA5NDksXG4gICAgJ3pldGEnOiA5NTAsXG4gICAgJ2V0YSc6IDk1MSxcbiAgICAndGhldGEnOiA5NTIsXG4gICAgJ2lvdGEnOiA5NTMsXG4gICAgJ2thcHBhJzogOTU0LFxuICAgICdsYW1iZGEnOiA5NTUsXG4gICAgJ211JzogOTU2LFxuICAgICdudSc6IDk1NyxcbiAgICAneGknOiA5NTgsXG4gICAgJ29taWNyb24nOiA5NTksXG4gICAgJ3BpJzogOTYwLFxuICAgICdyaG8nOiA5NjEsXG4gICAgJ3NpZ21hZic6IDk2MixcbiAgICAnc2lnbWEnOiA5NjMsXG4gICAgJ3RhdSc6IDk2NCxcbiAgICAndXBzaWxvbic6IDk2NSxcbiAgICAncGhpJzogOTY2LFxuICAgICdjaGknOiA5NjcsXG4gICAgJ3BzaSc6IDk2OCxcbiAgICAnb21lZ2EnOiA5NjksXG4gICAgJ3RoZXRhc3ltJzogOTc3LFxuICAgICd1cHNpaCc6IDk3OCxcbiAgICAncGl2JzogOTgyLFxuICAgICdlbnNwJzogODE5NCxcbiAgICAnZW1zcCc6IDgxOTUsXG4gICAgJ3RoaW5zcCc6IDgyMDEsXG4gICAgJ3p3bmonOiA4MjA0LFxuICAgICd6d2onOiA4MjA1LFxuICAgICdscm0nOiA4MjA2LFxuICAgICdybG0nOiA4MjA3LFxuICAgICduZGFzaCc6IDgyMTEsXG4gICAgJ21kYXNoJzogODIxMixcbiAgICAnbHNxdW8nOiA4MjE2LFxuICAgICdyc3F1byc6IDgyMTcsXG4gICAgJ3NicXVvJzogODIxOCxcbiAgICAnbGRxdW8nOiA4MjIwLFxuICAgICdyZHF1byc6IDgyMjEsXG4gICAgJ2JkcXVvJzogODIyMixcbiAgICAnZGFnZ2VyJzogODIyNCxcbiAgICAnRGFnZ2VyJzogODIyNSxcbiAgICAnYnVsbCc6IDgyMjYsXG4gICAgJ2hlbGxpcCc6IDgyMzAsXG4gICAgJ3Blcm1pbCc6IDgyNDAsXG4gICAgJ3ByaW1lJzogODI0MixcbiAgICAnUHJpbWUnOiA4MjQzLFxuICAgICdsc2FxdW8nOiA4MjQ5LFxuICAgICdyc2FxdW8nOiA4MjUwLFxuICAgICdvbGluZSc6IDgyNTQsXG4gICAgJ2ZyYXNsJzogODI2MCxcbiAgICAnZXVybyc6IDgzNjQsXG4gICAgJ2ltYWdlJzogODQ2NSxcbiAgICAnd2VpZXJwJzogODQ3MixcbiAgICAncmVhbCc6IDg0NzYsXG4gICAgJ3RyYWRlJzogODQ4MixcbiAgICAnYWxlZnN5bSc6IDg1MDEsXG4gICAgJ2xhcnInOiA4NTkyLFxuICAgICd1YXJyJzogODU5MyxcbiAgICAncmFycic6IDg1OTQsXG4gICAgJ2RhcnInOiA4NTk1LFxuICAgICdoYXJyJzogODU5NixcbiAgICAnY3JhcnInOiA4NjI5LFxuICAgICdsQXJyJzogODY1NixcbiAgICAndUFycic6IDg2NTcsXG4gICAgJ3JBcnInOiA4NjU4LFxuICAgICdkQXJyJzogODY1OSxcbiAgICAnaEFycic6IDg2NjAsXG4gICAgJ2ZvcmFsbCc6IDg3MDQsXG4gICAgJ3BhcnQnOiA4NzA2LFxuICAgICdleGlzdCc6IDg3MDcsXG4gICAgJ2VtcHR5JzogODcwOSxcbiAgICAnbmFibGEnOiA4NzExLFxuICAgICdpc2luJzogODcxMixcbiAgICAnbm90aW4nOiA4NzEzLFxuICAgICduaSc6IDg3MTUsXG4gICAgJ3Byb2QnOiA4NzE5LFxuICAgICdzdW0nOiA4NzIxLFxuICAgICdtaW51cyc6IDg3MjIsXG4gICAgJ2xvd2FzdCc6IDg3MjcsXG4gICAgJ3JhZGljJzogODczMCxcbiAgICAncHJvcCc6IDg3MzMsXG4gICAgJ2luZmluJzogODczNCxcbiAgICAnYW5nJzogODczNixcbiAgICAnYW5kJzogODc0MyxcbiAgICAnb3InOiA4NzQ0LFxuICAgICdjYXAnOiA4NzQ1LFxuICAgICdjdXAnOiA4NzQ2LFxuICAgICdpbnQnOiA4NzQ3LFxuICAgICd0aGVyZTQnOiA4NzU2LFxuICAgICdzaW0nOiA4NzY0LFxuICAgICdjb25nJzogODc3MyxcbiAgICAnYXN5bXAnOiA4Nzc2LFxuICAgICduZSc6IDg4MDAsXG4gICAgJ2VxdWl2JzogODgwMSxcbiAgICAnbGUnOiA4ODA0LFxuICAgICdnZSc6IDg4MDUsXG4gICAgJ3N1Yic6IDg4MzQsXG4gICAgJ3N1cCc6IDg4MzUsXG4gICAgJ25zdWInOiA4ODM2LFxuICAgICdzdWJlJzogODgzOCxcbiAgICAnc3VwZSc6IDg4MzksXG4gICAgJ29wbHVzJzogODg1MyxcbiAgICAnb3RpbWVzJzogODg1NSxcbiAgICAncGVycCc6IDg4NjksXG4gICAgJ3Nkb3QnOiA4OTAxLFxuICAgICdsY2VpbCc6IDg5NjgsXG4gICAgJ3JjZWlsJzogODk2OSxcbiAgICAnbGZsb29yJzogODk3MCxcbiAgICAncmZsb29yJzogODk3MSxcbiAgICAnbGFuZyc6IDkwMDEsXG4gICAgJ3JhbmcnOiA5MDAyLFxuICAgICdsb3onOiA5Njc0LFxuICAgICdzcGFkZXMnOiA5ODI0LFxuICAgICdjbHVicyc6IDk4MjcsXG4gICAgJ2hlYXJ0cyc6IDk4MjksXG4gICAgJ2RpYW1zJzogOTgzMFxuICB9XG5cbiAgT2JqZWN0LmtleXMoc2F4LkVOVElUSUVTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZSA9IHNheC5FTlRJVElFU1trZXldXG4gICAgdmFyIHMgPSB0eXBlb2YgZSA9PT0gJ251bWJlcicgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpIDogZVxuICAgIHNheC5FTlRJVElFU1trZXldID0gc1xuICB9KVxuXG4gIGZvciAodmFyIHMgaW4gc2F4LlNUQVRFKSB7XG4gICAgc2F4LlNUQVRFW3NheC5TVEFURVtzXV0gPSBzXG4gIH1cblxuICAvLyBzaG9ydGhhbmRcbiAgUyA9IHNheC5TVEFURVxuXG4gIGZ1bmN0aW9uIGVtaXQgKHBhcnNlciwgZXZlbnQsIGRhdGEpIHtcbiAgICBwYXJzZXJbZXZlbnRdICYmIHBhcnNlcltldmVudF0oZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXROb2RlIChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKSB7XG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBlbWl0KHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRleHQgKHBhcnNlcikge1xuICAgIHBhcnNlci50ZXh0Tm9kZSA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci50ZXh0Tm9kZSlcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBlbWl0KHBhcnNlciwgJ29udGV4dCcsIHBhcnNlci50ZXh0Tm9kZSlcbiAgICBwYXJzZXIudGV4dE5vZGUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dG9wdHMgKG9wdCwgdGV4dCkge1xuICAgIGlmIChvcHQudHJpbSkgdGV4dCA9IHRleHQudHJpbSgpXG4gICAgaWYgKG9wdC5ub3JtYWxpemUpIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvciAocGFyc2VyLCBlcikge1xuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBlciArPSAnXFxuTGluZTogJyArIHBhcnNlci5saW5lICtcbiAgICAgICAgJ1xcbkNvbHVtbjogJyArIHBhcnNlci5jb2x1bW4gK1xuICAgICAgICAnXFxuQ2hhcjogJyArIHBhcnNlci5jXG4gICAgfVxuICAgIGVyID0gbmV3IEVycm9yKGVyKVxuICAgIHBhcnNlci5lcnJvciA9IGVyXG4gICAgZW1pdChwYXJzZXIsICdvbmVycm9yJywgZXIpXG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgZnVuY3Rpb24gZW5kIChwYXJzZXIpIHtcbiAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuY2xvc2VkIHJvb3QgdGFnJylcbiAgICBpZiAoKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTikgJiZcbiAgICAgIChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU5fV0hJVEVTUEFDRSkgJiZcbiAgICAgIChwYXJzZXIuc3RhdGUgIT09IFMuVEVYVCkpIHtcbiAgICAgIGVycm9yKHBhcnNlciwgJ1VuZXhwZWN0ZWQgZW5kJylcbiAgICB9XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBwYXJzZXIuYyA9ICcnXG4gICAgcGFyc2VyLmNsb3NlZCA9IHRydWVcbiAgICBlbWl0KHBhcnNlciwgJ29uZW5kJylcbiAgICBTQVhQYXJzZXIuY2FsbChwYXJzZXIsIHBhcnNlci5zdHJpY3QsIHBhcnNlci5vcHQpXG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaWN0RmFpbCAocGFyc2VyLCBtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIgIT09ICdvYmplY3QnIHx8ICEocGFyc2VyIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY2FsbCB0byBzdHJpY3RGYWlsJylcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zdHJpY3QpIHtcbiAgICAgIGVycm9yKHBhcnNlciwgbWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXdUYWcgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgIHZhciB0YWcgPSBwYXJzZXIudGFnID0geyBuYW1lOiBwYXJzZXIudGFnTmFtZSwgYXR0cmlidXRlczoge30gfVxuXG4gICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuIGlmIHRhZyBjb250YWlscyBhbiB4bWxucz1cImZvb1wiIG9yIHhtbG5zOmZvbz1cImJhclwiXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHRhZy5ucyA9IHBhcmVudC5uc1xuICAgIH1cbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnc3RhcnQnLCB0YWcpXG4gIH1cblxuICBmdW5jdGlvbiBxbmFtZSAobmFtZSwgYXR0cmlidXRlKSB7XG4gICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJzonKVxuICAgIHZhciBxdWFsTmFtZSA9IGkgPCAwID8gWyAnJywgbmFtZSBdIDogbmFtZS5zcGxpdCgnOicpXG4gICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lWzBdXG4gICAgdmFyIGxvY2FsID0gcXVhbE5hbWVbMV1cblxuICAgIC8vIDx4IFwieG1sbnNcIj1cImh0dHA6Ly9mb29cIj5cbiAgICBpZiAoYXR0cmlidXRlICYmIG5hbWUgPT09ICd4bWxucycpIHtcbiAgICAgIHByZWZpeCA9ICd4bWxucydcbiAgICAgIGxvY2FsID0gJydcbiAgICB9XG5cbiAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgbG9jYWw6IGxvY2FsIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJpYiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLmF0dHJpYkxpc3QuaW5kZXhPZihwYXJzZXIuYXR0cmliTmFtZSkgIT09IC0xIHx8XG4gICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkocGFyc2VyLmF0dHJpYk5hbWUpKSB7XG4gICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLmF0dHJpYk5hbWUsIHRydWUpXG4gICAgICB2YXIgcHJlZml4ID0gcW4ucHJlZml4XG4gICAgICB2YXIgbG9jYWwgPSBxbi5sb2NhbFxuXG4gICAgICBpZiAocHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgICAgIC8vIG5hbWVzcGFjZSBiaW5kaW5nIGF0dHJpYnV0ZS4gcHVzaCB0aGUgYmluZGluZyBpbnRvIHNjb3BlXG4gICAgICAgIGlmIChsb2NhbCA9PT0gJ3htbCcgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MX05BTUVTUEFDRSArICdcXG4nICtcbiAgICAgICAgICAgICdBY3R1YWw6ICcgKyBwYXJzZXIuYXR0cmliVmFsdWUpXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWwgPT09ICd4bWxucycgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxOU19OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWxuczogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTE5TX05BTUVTUEFDRSArICdcXG4nICtcbiAgICAgICAgICAgICdBY3R1YWw6ICcgKyBwYXJzZXIuYXR0cmliVmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWdcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICAgICAgaWYgKHRhZy5ucyA9PT0gcGFyZW50Lm5zKSB7XG4gICAgICAgICAgICB0YWcubnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5ucylcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnLm5zW2xvY2FsXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmVyIG9uYXR0cmlidXRlIGV2ZW50cyB1bnRpbCBhbGwgYXR0cmlidXRlcyBoYXZlIGJlZW4gc2VlblxuICAgICAgLy8gc28gYW55IG5ldyBiaW5kaW5ncyBjYW4gdGFrZSBlZmZlY3QuIHByZXNlcnZlIGF0dHJpYnV0ZSBvcmRlclxuICAgICAgLy8gc28gZGVmZXJyZWQgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIGluIGRvY3VtZW50IG9yZGVyXG4gICAgICBwYXJzZXIuYXR0cmliTGlzdC5wdXNoKFtwYXJzZXIuYXR0cmliTmFtZSwgcGFyc2VyLmF0dHJpYlZhbHVlXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gbm9uLXhtbG5zIG1vZGUsIHdlIGNhbiBlbWl0IHRoZSBldmVudCByaWdodCBhd2F5XG4gICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIHtcbiAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgIHZhbHVlOiBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gb3BlblRhZyAocGFyc2VyLCBzZWxmQ2xvc2luZykge1xuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAvLyBlbWl0IG5hbWVzcGFjZSBiaW5kaW5nIGV2ZW50c1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWdcblxuICAgICAgLy8gYWRkIG5hbWVzcGFjZSBpbmZvIHRvIHRhZ1xuICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLnRhZ05hbWUpXG4gICAgICB0YWcucHJlZml4ID0gcW4ucHJlZml4XG4gICAgICB0YWcubG9jYWwgPSBxbi5sb2NhbFxuICAgICAgdGFnLnVyaSA9IHRhZy5uc1txbi5wcmVmaXhdIHx8ICcnXG5cbiAgICAgIGlmICh0YWcucHJlZml4ICYmICF0YWcudXJpKSB7XG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXJzZXIudGFnTmFtZSkpXG4gICAgICAgIHRhZy51cmkgPSBxbi5wcmVmaXhcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgaWYgKHRhZy5ucyAmJiBwYXJlbnQubnMgIT09IHRhZy5ucykge1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW5uYW1lc3BhY2UnLCB7XG4gICAgICAgICAgICBwcmVmaXg6IHAsXG4gICAgICAgICAgICB1cmk6IHRhZy5uc1twXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBkZWZlcnJlZCBvbmF0dHJpYnV0ZSBldmVudHNcbiAgICAgIC8vIE5vdGU6IGRvIG5vdCBhcHBseSBkZWZhdWx0IG5zIHRvIGF0dHJpYnV0ZXM6XG4gICAgICAvLyAgIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwtbmFtZXMvI2RlZmF1bHRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBudiA9IHBhcnNlci5hdHRyaWJMaXN0W2ldXG4gICAgICAgIHZhciBuYW1lID0gbnZbMF1cbiAgICAgICAgdmFyIHZhbHVlID0gbnZbMV1cbiAgICAgICAgdmFyIHF1YWxOYW1lID0gcW5hbWUobmFtZSwgdHJ1ZSlcbiAgICAgICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lLnByZWZpeFxuICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZS5sb2NhbFxuICAgICAgICB2YXIgdXJpID0gcHJlZml4ID09PSAnJyA/ICcnIDogKHRhZy5uc1twcmVmaXhdIHx8ICcnKVxuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICBsb2NhbDogbG9jYWwsXG4gICAgICAgICAgdXJpOiB1cmlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IGF0dHJpYnV0ZXMgd2l0aCBhbiB1bmRlZmluZWQgbmFtZXNwYWNlLFxuICAgICAgICAvLyB0aGVuIGZhaWwgb24gdGhlbSBub3cuXG4gICAgICAgIGlmIChwcmVmaXggJiYgcHJlZml4ICE9PSAneG1sbnMnICYmICF1cmkpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwcmVmaXgpKVxuICAgICAgICAgIGEudXJpID0gcHJlZml4XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW25hbWVdID0gYVxuICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIGEpXG4gICAgICB9XG4gICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgfVxuXG4gICAgcGFyc2VyLnRhZy5pc1NlbGZDbG9zaW5nID0gISFzZWxmQ2xvc2luZ1xuXG4gICAgLy8gcHJvY2VzcyB0aGUgdGFnXG4gICAgcGFyc2VyLnNhd1Jvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ3MucHVzaChwYXJzZXIudGFnKVxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZycsIHBhcnNlci50YWcpXG4gICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8c2NyaXB0PiBpbiBub24tc3RyaWN0IG1vZGUuXG4gICAgICBpZiAoIXBhcnNlci5ub3NjcmlwdCAmJiBwYXJzZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICB9XG4gICAgICBwYXJzZXIudGFnID0gbnVsbFxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgIH1cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUYWcgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnV2VpcmQgZW1wdHkgY2xvc2UgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvPidcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgIGlmIChwYXJzZXIudGFnTmFtZSAhPT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWUgKyAnPidcbiAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zaW5nIHRhZyBhY3R1YWxseSBleGlzdHMuXG4gICAgLy8gPGE+PGI+PC9jPjwvYj48L2E+IHdpbGwgY2xvc2UgZXZlcnl0aGluZywgb3RoZXJ3aXNlLlxuICAgIHZhciB0ID0gcGFyc2VyLnRhZ3MubGVuZ3RoXG4gICAgdmFyIHRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVxuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgdGFnTmFtZSA9IHRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cbiAgICB2YXIgY2xvc2VUbyA9IHRhZ05hbWVcbiAgICB3aGlsZSAodC0tKSB7XG4gICAgICB2YXIgY2xvc2UgPSBwYXJzZXIudGFnc1t0XVxuICAgICAgaWYgKGNsb3NlLm5hbWUgIT09IGNsb3NlVG8pIHtcbiAgICAgICAgLy8gZmFpbCB0aGUgZmlyc3QgdGltZSBpbiBzdHJpY3QgbW9kZVxuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZXhwZWN0ZWQgY2xvc2UgdGFnJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGlkbid0IGZpbmQgaXQuICB3ZSBhbHJlYWR5IGZhaWxlZCBmb3Igc3RyaWN0LCBzbyBqdXN0IGFib3J0LlxuICAgIGlmICh0IDwgMCkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbm1hdGNoZWQgY2xvc2luZyB0YWc6ICcgKyBwYXJzZXIudGFnTmFtZSlcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWUgKyAnPidcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHBhcnNlci50YWdOYW1lID0gdGFnTmFtZVxuICAgIHZhciBzID0gcGFyc2VyLnRhZ3MubGVuZ3RoXG4gICAgd2hpbGUgKHMtLSA+IHQpIHtcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnID0gcGFyc2VyLnRhZ3MucG9wKClcbiAgICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZy5uYW1lXG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NldGFnJywgcGFyc2VyLnRhZ05hbWUpXG5cbiAgICAgIHZhciB4ID0ge31cbiAgICAgIGZvciAodmFyIGkgaW4gdGFnLm5zKSB7XG4gICAgICAgIHhbaV0gPSB0YWcubnNbaV1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMgJiYgdGFnLm5zICE9PSBwYXJlbnQubnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIG5hbWVzcGFjZSBiaW5kaW5ncyBpbnRyb2R1Y2VkIGJ5IHRhZ1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICB2YXIgbiA9IHRhZy5uc1twXVxuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VuYW1lc3BhY2UnLCB7IHByZWZpeDogcCwgdXJpOiBuIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ID09PSAwKSBwYXJzZXIuY2xvc2VkUm9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVudGl0eSAocGFyc2VyKSB7XG4gICAgdmFyIGVudGl0eSA9IHBhcnNlci5lbnRpdHlcbiAgICB2YXIgZW50aXR5TEMgPSBlbnRpdHkudG9Mb3dlckNhc2UoKVxuICAgIHZhciBudW1cbiAgICB2YXIgbnVtU3RyID0gJydcblxuICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5XSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHldXG4gICAgfVxuICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHlMQ1xuICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIGlmIChlbnRpdHkuY2hhckF0KDEpID09PSAneCcpIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDIpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTYpXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxNilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgxKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDEwKVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTApXG4gICAgICB9XG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eS5yZXBsYWNlKC9eMCsvLCAnJylcbiAgICBpZiAobnVtU3RyLnRvTG93ZXJDYXNlKCkgIT09IGVudGl0eSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBlbnRpdHknKVxuICAgICAgcmV0dXJuICcmJyArIHBhcnNlci5lbnRpdHkgKyAnOydcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5XaGl0ZVNwYWNlIChwYXJzZXIsIGMpIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICB9IGVsc2UgaWYgKG5vdCh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgLy8gaGF2ZSB0byBwcm9jZXNzIHRoaXMgYXMgYSB0ZXh0IG5vZGUuXG4gICAgICAvLyB3ZWlyZCwgYnV0IGhhcHBlbnMuXG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ05vbi13aGl0ZXNwYWNlIGJlZm9yZSBmaXJzdCB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IGNcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJBdCAoY2h1bmssIGkpIHtcbiAgICB2YXIgcmVzdWx0ID0gJydcbiAgICBpZiAoaSA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gY2h1bmsuY2hhckF0KGkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlIChjaHVuaykge1xuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JcbiAgICB9XG4gICAgaWYgKHBhcnNlci5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBlcnJvcihwYXJzZXIsXG4gICAgICAgICdDYW5ub3Qgd3JpdGUgYWZ0ZXIgY2xvc2UuIEFzc2lnbiBhbiBvbnJlYWR5IGhhbmRsZXIuJylcbiAgICB9XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5kKHBhcnNlcilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoKVxuICAgIH1cbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgYyA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgIHBhcnNlci5jID0gY1xuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgUy5CRUdJTjpcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkJFR0lOX1dISVRFU1BBQ0VcbiAgICAgICAgICBpZiAoYyA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkJFR0lOX1dISVRFU1BBQ0U6XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5URVhUOlxuICAgICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHtcbiAgICAgICAgICAgIHZhciBzdGFydGkgPSBpIC0gMVxuICAgICAgICAgICAgd2hpbGUgKGMgJiYgYyAhPT0gJzwnICYmIGMgIT09ICcmJykge1xuICAgICAgICAgICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICAgICAgICAgIGlmIChjICYmIHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lKytcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGNodW5rLnN1YnN0cmluZyhzdGFydGksIGkgLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJzwnICYmICEocGFyc2VyLnNhd1Jvb3QgJiYgcGFyc2VyLmNsb3NlZFJvb3QgJiYgIXBhcnNlci5zdHJpY3QpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vdCh3aGl0ZXNwYWNlLCBjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1RleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgaXQuLi5cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVFxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZW5jb2RlZCA8JylcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvblxuICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbignICcpICsgY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVuY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSAnLS0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAgICAgJ0luYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zZ21sZGVjbGFyYXRpb24nLCBwYXJzZXIuc2dtbERlY2wpXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhxdW90ZSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uZG9jdHlwZScsIHBhcnNlci5kb2N0eXBlKVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSB0cnVlIC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhxdW90ZSwgYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX1FVT1RFRFxuICAgICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHF1b3RlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERURcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jb21tZW50JywgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgIGlmIChjICE9PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTWFsZm9ybWVkIGNvbW1lbnQnKVxuICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VjZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfQk9EWTpcbiAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbicsIHtcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLnByb2NJbnN0TmFtZSxcbiAgICAgICAgICAgICAgYm9keTogcGFyc2VyLnByb2NJbnN0Qm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9ICc/JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUc6XG4gICAgICAgICAgaWYgKGlzKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUYWcocGFyc2VyKVxuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIHRhZyBuYW1lJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBR19TTEFTSDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlciwgdHJ1ZSlcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdGb3J3YXJkLXNsYXNoIGluIG9wZW5pbmcgdGFnIG5vdCBmb2xsb3dlZCBieSA+JylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQjpcbiAgICAgICAgICAvLyBoYXZlbid0IHJlYWQgdGhlIGF0dHJpYnV0ZSBuYW1lIHlldC5cbiAgICAgICAgICBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWVcbiAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUU6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRFxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlcycpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDpcbiAgICAgICAgICBpZiAobm90KGF0dHJpYkVuZCwgYykpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUc6XG4gICAgICAgICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgY1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcuJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWVcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdfU0FXX1dISVRFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBR19TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhwYXJzZXIuZW50aXR5Lmxlbmd0aCA/IGVudGl0eUJvZHkgOiBlbnRpdHlTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIGVudGl0eSBuYW1lJylcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9ICcmJyArIHBhcnNlci5lbnRpdHkgKyBjXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXIsICdVbmtub3duIHN0YXRlOiAnICsgcGFyc2VyLnN0YXRlKVxuICAgICAgfVxuICAgIH0gLy8gd2hpbGVcblxuICAgIGlmIChwYXJzZXIucG9zaXRpb24gPj0gcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24pIHtcbiAgICAgIGNoZWNrQnVmZmVyTGVuZ3RoKHBhcnNlcilcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMS4wIGJ5IEBtYXRoaWFzICovXG4gIGlmICghU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3JcbiAgICAgIHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgTUFYX1NJWkUgPSAweDQwMDBcbiAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdXG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlXG4gICAgICAgIHZhciBsb3dTdXJyb2dhdGVcbiAgICAgICAgdmFyIGluZGV4ID0gLTFcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJydcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3VtZW50c1tpbmRleF0pXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgLy8gYE5hTmAsIGArSW5maW5pdHlgLCBvciBgLUluZmluaXR5YFxuICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBGRkZGIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgZmxvb3IoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQ6ICcgKyBjb2RlUG9pbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7IC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpXG4gICAgICAgICAgfSBlbHNlIHsgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwXG4gICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhEQzAwXG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKVxuICAgICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG4iLCJ2YXIgdjEgPSByZXF1aXJlKCcuL3YxJyk7XG52YXIgdjQgPSByZXF1aXJlKCcuL3Y0Jyk7XG5cbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gbm9kZS5qc1xuLy8gdGhpcyBpcyBwcmV0dHkgc3RyYWlnaHQtZm9yd2FyZCAtIHdlIHVzZSB0aGUgY3J5cHRvIEFQSS5cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vZGVSTkcoKSB7XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpO1xufTtcbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBleHBvcnRzLnN0cmlwQk9NID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKHN0clswXSA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIGJ1aWxkZXIsIGRlZmF1bHRzLCBlc2NhcGVDREFUQSwgcmVxdWlyZXNDREFUQSwgd3JhcENEQVRBLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBidWlsZGVyID0gcmVxdWlyZSgneG1sYnVpbGRlcicpO1xuXG4gIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpLmRlZmF1bHRzO1xuXG4gIHJlcXVpcmVzQ0RBVEEgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgJiYgKGVudHJ5LmluZGV4T2YoJyYnKSA+PSAwIHx8IGVudHJ5LmluZGV4T2YoJz4nKSA+PSAwIHx8IGVudHJ5LmluZGV4T2YoJzwnKSA+PSAwKTtcbiAgfTtcblxuICB3cmFwQ0RBVEEgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBcIjwhW0NEQVRBW1wiICsgKGVzY2FwZUNEQVRBKGVudHJ5KSkgKyBcIl1dPlwiO1xuICB9O1xuXG4gIGVzY2FwZUNEQVRBID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkucmVwbGFjZSgnXV0+JywgJ11dXV0+PCFbQ0RBVEFbPicpO1xuICB9O1xuXG4gIGV4cG9ydHMuQnVpbGRlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBCdWlsZGVyKG9wdHMpIHtcbiAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHJlZiA9IGRlZmF1bHRzW1wiMC4yXCJdO1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBvcHRzKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9wdHMsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IG9wdHNba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBCdWlsZGVyLnByb3RvdHlwZS5idWlsZE9iamVjdCA9IGZ1bmN0aW9uKHJvb3RPYmopIHtcbiAgICAgIHZhciBhdHRya2V5LCBjaGFya2V5LCByZW5kZXIsIHJvb3RFbGVtZW50LCByb290TmFtZTtcbiAgICAgIGF0dHJrZXkgPSB0aGlzLm9wdGlvbnMuYXR0cmtleTtcbiAgICAgIGNoYXJrZXkgPSB0aGlzLm9wdGlvbnMuY2hhcmtleTtcbiAgICAgIGlmICgoT2JqZWN0LmtleXMocm9vdE9iaikubGVuZ3RoID09PSAxKSAmJiAodGhpcy5vcHRpb25zLnJvb3ROYW1lID09PSBkZWZhdWx0c1snMC4yJ10ucm9vdE5hbWUpKSB7XG4gICAgICAgIHJvb3ROYW1lID0gT2JqZWN0LmtleXMocm9vdE9iailbMF07XG4gICAgICAgIHJvb3RPYmogPSByb290T2JqW3Jvb3ROYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3ROYW1lID0gdGhpcy5vcHRpb25zLnJvb3ROYW1lO1xuICAgICAgfVxuICAgICAgcmVuZGVyID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBvYmopIHtcbiAgICAgICAgICB2YXIgYXR0ciwgY2hpbGQsIGVudHJ5LCBpbmRleCwga2V5LCB2YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNkYXRhICYmIHJlcXVpcmVzQ0RBVEEob2JqKSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJhdyh3cmFwQ0RBVEEob2JqKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnR4dChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKGluZGV4IGluIG9iaikge1xuICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChvYmosIGluZGV4KSkgY29udGludWU7XG4gICAgICAgICAgICAgIGNoaWxkID0gb2JqW2luZGV4XTtcbiAgICAgICAgICAgICAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IGNoaWxkW2tleV07XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHJlbmRlcihlbGVtZW50LmVsZShrZXkpLCBlbnRyeSkudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2hpbGQgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gYXR0cmtleSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoYXR0ciBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoaWxkW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5hdHQoYXR0ciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGNoYXJrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jZGF0YSAmJiByZXF1aXJlc0NEQVRBKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmF3KHdyYXBDREFUQShjaGlsZCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC50eHQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKGNoaWxkLCBpbmRleCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgZW50cnkgPSBjaGlsZFtpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jZGF0YSAmJiByZXF1aXJlc0NEQVRBKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXkpLnJhdyh3cmFwQ0RBVEEoZW50cnkpKS51cCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXksIGVudHJ5KS51cCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVuZGVyKGVsZW1lbnQuZWxlKGtleSksIGVudHJ5KS51cCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVuZGVyKGVsZW1lbnQuZWxlKGtleSksIGNoaWxkKS51cCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnICYmIF90aGlzLm9wdGlvbnMuY2RhdGEgJiYgcmVxdWlyZXNDREFUQShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXkpLnJhdyh3cmFwQ0RBVEEoY2hpbGQpKS51cCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlKGtleSwgY2hpbGQudG9TdHJpbmcoKSkudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHJvb3RFbGVtZW50ID0gYnVpbGRlci5jcmVhdGUocm9vdE5hbWUsIHRoaXMub3B0aW9ucy54bWxkZWMsIHRoaXMub3B0aW9ucy5kb2N0eXBlLCB7XG4gICAgICAgIGhlYWRsZXNzOiB0aGlzLm9wdGlvbnMuaGVhZGxlc3MsXG4gICAgICAgIGFsbG93U3Vycm9nYXRlQ2hhcnM6IHRoaXMub3B0aW9ucy5hbGxvd1N1cnJvZ2F0ZUNoYXJzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZW5kZXIocm9vdEVsZW1lbnQsIHJvb3RPYmopLmVuZCh0aGlzLm9wdGlvbnMucmVuZGVyT3B0cyk7XG4gICAgfTtcblxuICAgIHJldHVybiBCdWlsZGVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIFwiMC4xXCI6IHtcbiAgICAgIGV4cGxpY2l0Q2hhcmtleTogZmFsc2UsXG4gICAgICB0cmltOiB0cnVlLFxuICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICAgICAgbm9ybWFsaXplVGFnczogZmFsc2UsXG4gICAgICBhdHRya2V5OiBcIkBcIixcbiAgICAgIGNoYXJrZXk6IFwiI1wiLFxuICAgICAgZXhwbGljaXRBcnJheTogZmFsc2UsXG4gICAgICBpZ25vcmVBdHRyczogZmFsc2UsXG4gICAgICBtZXJnZUF0dHJzOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Um9vdDogZmFsc2UsXG4gICAgICB2YWxpZGF0b3I6IG51bGwsXG4gICAgICB4bWxuczogZmFsc2UsXG4gICAgICBleHBsaWNpdENoaWxkcmVuOiBmYWxzZSxcbiAgICAgIGNoaWxka2V5OiAnQEAnLFxuICAgICAgY2hhcnNBc0NoaWxkcmVuOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVXaGl0ZUNoYXJzOiBmYWxzZSxcbiAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGF0dHJOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIGF0dHJWYWx1ZVByb2Nlc3NvcnM6IG51bGwsXG4gICAgICB0YWdOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIGVtcHR5VGFnOiAnJ1xuICAgIH0sXG4gICAgXCIwLjJcIjoge1xuICAgICAgZXhwbGljaXRDaGFya2V5OiBmYWxzZSxcbiAgICAgIHRyaW06IGZhbHNlLFxuICAgICAgbm9ybWFsaXplOiBmYWxzZSxcbiAgICAgIG5vcm1hbGl6ZVRhZ3M6IGZhbHNlLFxuICAgICAgYXR0cmtleTogXCIkXCIsXG4gICAgICBjaGFya2V5OiBcIl9cIixcbiAgICAgIGV4cGxpY2l0QXJyYXk6IHRydWUsXG4gICAgICBpZ25vcmVBdHRyczogZmFsc2UsXG4gICAgICBtZXJnZUF0dHJzOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Um9vdDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRvcjogbnVsbCxcbiAgICAgIHhtbG5zOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Q2hpbGRyZW46IGZhbHNlLFxuICAgICAgcHJlc2VydmVDaGlsZHJlbk9yZGVyOiBmYWxzZSxcbiAgICAgIGNoaWxka2V5OiAnJCQnLFxuICAgICAgY2hhcnNBc0NoaWxkcmVuOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVXaGl0ZUNoYXJzOiBmYWxzZSxcbiAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGF0dHJOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIGF0dHJWYWx1ZVByb2Nlc3NvcnM6IG51bGwsXG4gICAgICB0YWdOYW1lUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHJvb3ROYW1lOiAncm9vdCcsXG4gICAgICB4bWxkZWM6IHtcbiAgICAgICAgJ3ZlcnNpb24nOiAnMS4wJyxcbiAgICAgICAgJ2VuY29kaW5nJzogJ1VURi04JyxcbiAgICAgICAgJ3N0YW5kYWxvbmUnOiB0cnVlXG4gICAgICB9LFxuICAgICAgZG9jdHlwZTogbnVsbCxcbiAgICAgIHJlbmRlck9wdHM6IHtcbiAgICAgICAgJ3ByZXR0eSc6IHRydWUsXG4gICAgICAgICdpbmRlbnQnOiAnICAnLFxuICAgICAgICAnbmV3bGluZSc6ICdcXG4nXG4gICAgICB9LFxuICAgICAgaGVhZGxlc3M6IGZhbHNlLFxuICAgICAgY2h1bmtTaXplOiAxMDAwMCxcbiAgICAgIGVtcHR5VGFnOiAnJyxcbiAgICAgIGNkYXRhOiBmYWxzZVxuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgYm9tLCBkZWZhdWx0cywgZXZlbnRzLCBpc0VtcHR5LCBwcm9jZXNzSXRlbSwgcHJvY2Vzc29ycywgc2F4LCBzZXRJbW1lZGlhdGUsXG4gICAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBzYXggPSByZXF1aXJlKCdzYXgnKTtcblxuICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuICBib20gPSByZXF1aXJlKCcuL2JvbScpO1xuXG4gIHByb2Nlc3NvcnMgPSByZXF1aXJlKCcuL3Byb2Nlc3NvcnMnKTtcblxuICBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG5cbiAgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJykuZGVmYXVsdHM7XG5cbiAgaXNFbXB0eSA9IGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiAodGhpbmcgIT0gbnVsbCkgJiYgT2JqZWN0LmtleXModGhpbmcpLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICBwcm9jZXNzSXRlbSA9IGZ1bmN0aW9uKHByb2Nlc3NvcnMsIGl0ZW0sIGtleSkge1xuICAgIHZhciBpLCBsZW4sIHByb2Nlc3M7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcHJvY2Vzc29ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcHJvY2VzcyA9IHByb2Nlc3NvcnNbaV07XG4gICAgICBpdGVtID0gcHJvY2VzcyhpdGVtLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuICBleHBvcnRzLlBhcnNlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBhcnNlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0cykge1xuICAgICAgdGhpcy5wYXJzZVN0cmluZyA9IGJpbmQodGhpcy5wYXJzZVN0cmluZywgdGhpcyk7XG4gICAgICB0aGlzLnJlc2V0ID0gYmluZCh0aGlzLnJlc2V0LCB0aGlzKTtcbiAgICAgIHRoaXMuYXNzaWduT3JQdXNoID0gYmluZCh0aGlzLmFzc2lnbk9yUHVzaCwgdGhpcyk7XG4gICAgICB0aGlzLnByb2Nlc3NBc3luYyA9IGJpbmQodGhpcy5wcm9jZXNzQXN5bmMsIHRoaXMpO1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBleHBvcnRzLlBhcnNlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlBhcnNlcihvcHRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgcmVmID0gZGVmYXVsdHNbXCIwLjJcIl07XG4gICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5IGluIG9wdHMpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob3B0cywga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gb3B0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy54bWxucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMueG1sbnNrZXkgPSB0aGlzLm9wdGlvbnMuYXR0cmtleSArIFwibnNcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9ybWFsaXplVGFncykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycy51bnNoaWZ0KHByb2Nlc3NvcnMubm9ybWFsaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNodW5rLCBlcnI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcubGVuZ3RoIDw9IHRoaXMub3B0aW9ucy5jaHVua1NpemUpIHtcbiAgICAgICAgICBjaHVuayA9IHRoaXMucmVtYWluaW5nO1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gJyc7XG4gICAgICAgICAgdGhpcy5zYXhQYXJzZXIgPSB0aGlzLnNheFBhcnNlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHIoMCwgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHIodGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgdGhpcy5yZW1haW5pbmcubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnNheFBhcnNlciA9IHRoaXMuc2F4UGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKHRoaXMucHJvY2Vzc0FzeW5jKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgIGVyciA9IGVycm9yMTtcbiAgICAgICAgaWYgKCF0aGlzLnNheFBhcnNlci5lcnJUaHJvd24pIHtcbiAgICAgICAgICB0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFzc2lnbk9yUHVzaCA9IGZ1bmN0aW9uKG9iaiwga2V5LCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKCEoa2V5IGluIG9iaikpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhwbGljaXRBcnJheSkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IFtuZXdWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKG9ialtrZXldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpba2V5XS5wdXNoKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJrZXksIGNoYXJrZXksIG9udGV4dCwgc3RhY2s7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIgPSBzYXgucGFyc2VyKHRoaXMub3B0aW9ucy5zdHJpY3QsIHtcbiAgICAgICAgdHJpbTogZmFsc2UsXG4gICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsXG4gICAgICAgIHhtbG5zOiB0aGlzLm9wdGlvbnMueG1sbnNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYXhQYXJzZXIuZXJyVGhyb3duID0gZmFsc2U7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmVycm9yID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIF90aGlzLnNheFBhcnNlci5yZXN1bWUoKTtcbiAgICAgICAgICBpZiAoIV90aGlzLnNheFBhcnNlci5lcnJUaHJvd24pIHtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmVuZCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5zYXhQYXJzZXIuZW5kZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcImVuZFwiLCBfdGhpcy5yZXN1bHRPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIuZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuRVhQTElDSVRfQ0hBUktFWSA9IHRoaXMub3B0aW9ucy5leHBsaWNpdENoYXJrZXk7XG4gICAgICB0aGlzLnJlc3VsdE9iamVjdCA9IG51bGw7XG4gICAgICBzdGFjayA9IFtdO1xuICAgICAgYXR0cmtleSA9IHRoaXMub3B0aW9ucy5hdHRya2V5O1xuICAgICAgY2hhcmtleSA9IHRoaXMub3B0aW9ucy5jaGFya2V5O1xuICAgICAgdGhpcy5zYXhQYXJzZXIub25vcGVudGFnID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGtleSwgbmV3VmFsdWUsIG9iaiwgcHJvY2Vzc2VkS2V5LCByZWY7XG4gICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgb2JqW2NoYXJrZXldID0gXCJcIjtcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuaWdub3JlQXR0cnMpIHtcbiAgICAgICAgICAgIHJlZiA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpZiAoIShhdHRya2V5IGluIG9iaikgJiYgIV90aGlzLm9wdGlvbnMubWVyZ2VBdHRycykge1xuICAgICAgICAgICAgICAgIG9ialthdHRya2V5XSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5hdHRyVmFsdWVQcm9jZXNzb3JzID8gcHJvY2Vzc0l0ZW0oX3RoaXMub3B0aW9ucy5hdHRyVmFsdWVQcm9jZXNzb3JzLCBub2RlLmF0dHJpYnV0ZXNba2V5XSwga2V5KSA6IG5vZGUuYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICBwcm9jZXNzZWRLZXkgPSBfdGhpcy5vcHRpb25zLmF0dHJOYW1lUHJvY2Vzc29ycyA/IHByb2Nlc3NJdGVtKF90aGlzLm9wdGlvbnMuYXR0ck5hbWVQcm9jZXNzb3JzLCBrZXkpIDoga2V5O1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5tZXJnZUF0dHJzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXNzaWduT3JQdXNoKG9iaiwgcHJvY2Vzc2VkS2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2F0dHJrZXldW3Byb2Nlc3NlZEtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpbXCIjbmFtZVwiXSA9IF90aGlzLm9wdGlvbnMudGFnTmFtZVByb2Nlc3NvcnMgPyBwcm9jZXNzSXRlbShfdGhpcy5vcHRpb25zLnRhZ05hbWVQcm9jZXNzb3JzLCBub2RlLm5hbWUpIDogbm9kZS5uYW1lO1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnhtbG5zKSB7XG4gICAgICAgICAgICBvYmpbX3RoaXMub3B0aW9ucy54bWxuc2tleV0gPSB7XG4gICAgICAgICAgICAgIHVyaTogbm9kZS51cmksXG4gICAgICAgICAgICAgIGxvY2FsOiBub2RlLmxvY2FsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RhY2sucHVzaChvYmopO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmNsb3NldGFnID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY2RhdGEsIGVtcHR5U3RyLCBrZXksIG5vZGUsIG5vZGVOYW1lLCBvYmosIG9iakNsb25lLCBvbGQsIHMsIHhwYXRoO1xuICAgICAgICAgIG9iaiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIG5vZGVOYW1lID0gb2JqW1wiI25hbWVcIl07XG4gICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmV4cGxpY2l0Q2hpbGRyZW4gfHwgIV90aGlzLm9wdGlvbnMucHJlc2VydmVDaGlsZHJlbk9yZGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW1wiI25hbWVcIl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmouY2RhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNkYXRhID0gb2JqLmNkYXRhO1xuICAgICAgICAgICAgZGVsZXRlIG9iai5jZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChvYmpbY2hhcmtleV0ubWF0Y2goL15cXHMqJC8pICYmICFjZGF0YSkge1xuICAgICAgICAgICAgZW1wdHlTdHIgPSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgICBkZWxldGUgb2JqW2NoYXJrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy50cmltKSB7XG4gICAgICAgICAgICAgIG9ialtjaGFya2V5XSA9IG9ialtjaGFya2V5XS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgb2JqW2NoYXJrZXldID0gb2JqW2NoYXJrZXldLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtjaGFya2V5XSA9IF90aGlzLm9wdGlvbnMudmFsdWVQcm9jZXNzb3JzID8gcHJvY2Vzc0l0ZW0oX3RoaXMub3B0aW9ucy52YWx1ZVByb2Nlc3NvcnMsIG9ialtjaGFya2V5XSwgbm9kZU5hbWUpIDogb2JqW2NoYXJrZXldO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAxICYmIGNoYXJrZXkgaW4gb2JqICYmICFfdGhpcy5FWFBMSUNJVF9DSEFSS0VZKSB7XG4gICAgICAgICAgICAgIG9iaiA9IG9ialtjaGFya2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRW1wdHkob2JqKSkge1xuICAgICAgICAgICAgb2JqID0gX3RoaXMub3B0aW9ucy5lbXB0eVRhZyAhPT0gJycgPyBfdGhpcy5vcHRpb25zLmVtcHR5VGFnIDogZW1wdHlTdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnZhbGlkYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICB4cGF0aCA9IFwiL1wiICsgKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZVtcIiNuYW1lXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCkpLmNvbmNhdChub2RlTmFtZSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBlcnI7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiA9IF90aGlzLm9wdGlvbnMudmFsaWRhdG9yKHhwYXRoLCBzICYmIHNbbm9kZU5hbWVdLCBvYmopO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlcnJvcjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5leHBsaWNpdENoaWxkcmVuICYmICFfdGhpcy5vcHRpb25zLm1lcmdlQXR0cnMgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5wcmVzZXJ2ZUNoaWxkcmVuT3JkZXIpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IHt9O1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hdHRya2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIG5vZGVbX3RoaXMub3B0aW9ucy5hdHRya2V5XSA9IG9ialtfdGhpcy5vcHRpb25zLmF0dHJrZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbX3RoaXMub3B0aW9ucy5hdHRya2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2hhcnNBc0NoaWxkcmVuICYmIF90aGlzLm9wdGlvbnMuY2hhcmtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBub2RlW190aGlzLm9wdGlvbnMuY2hhcmtleV0gPSBvYmpbX3RoaXMub3B0aW9ucy5jaGFya2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW190aGlzLm9wdGlvbnMuY2hhcmtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0gPSBvYmo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocykge1xuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldID0gc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgb2JqQ2xvbmUgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBvYmpDbG9uZVtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XS5wdXNoKG9iakNsb25lKTtcbiAgICAgICAgICAgICAgZGVsZXRlIG9ialtcIiNuYW1lXCJdO1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDEgJiYgY2hhcmtleSBpbiBvYmogJiYgIV90aGlzLkVYUExJQ0lUX0NIQVJLRVkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hc3NpZ25PclB1c2gocywgbm9kZU5hbWUsIG9iaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmV4cGxpY2l0Um9vdCkge1xuICAgICAgICAgICAgICBvbGQgPSBvYmo7XG4gICAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgICAgICBvYmpbbm9kZU5hbWVdID0gb2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVzdWx0T2JqZWN0ID0gb2JqO1xuICAgICAgICAgICAgX3RoaXMuc2F4UGFyc2VyLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KFwiZW5kXCIsIF90aGlzLnJlc3VsdE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBvbnRleHQgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICB2YXIgY2hhckNoaWxkLCBzO1xuICAgICAgICAgIHMgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgc1tjaGFya2V5XSArPSB0ZXh0O1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXhwbGljaXRDaGlsZHJlbiAmJiBfdGhpcy5vcHRpb25zLnByZXNlcnZlQ2hpbGRyZW5PcmRlciAmJiBfdGhpcy5vcHRpb25zLmNoYXJzQXNDaGlsZHJlbiAmJiAoX3RoaXMub3B0aW9ucy5pbmNsdWRlV2hpdGVDaGFycyB8fCB0ZXh0LnJlcGxhY2UoL1xcXFxuL2csICcnKS50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldID0gc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgY2hhckNoaWxkID0ge1xuICAgICAgICAgICAgICAgICcjbmFtZSc6ICdfX3RleHRfXydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY2hhckNoaWxkW2NoYXJrZXldID0gdGV4dDtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgY2hhckNoaWxkW2NoYXJrZXldID0gY2hhckNoaWxkW2NoYXJrZXldLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldLnB1c2goY2hhckNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIub250ZXh0ID0gb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLm9uY2RhdGEgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICB2YXIgcztcbiAgICAgICAgICBzID0gb250ZXh0KHRleHQpO1xuICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5jZGF0YSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbihzdHIsIGNiKSB7XG4gICAgICB2YXIgZXJyO1xuICAgICAgaWYgKChjYiAhPSBudWxsKSAmJiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdHIudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBib20uc3RyaXBCT00oc3RyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3luYykge1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gc3RyO1xuICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLnByb2Nlc3NBc3luYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNheFBhcnNlci53cml0ZShzdHIpLmNsb3NlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgZXJyID0gZXJyb3IxO1xuICAgICAgICBpZiAoISh0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gfHwgdGhpcy5zYXhQYXJzZXIuZW5kZWQpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLmVyclRocm93biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zYXhQYXJzZXIuZW5kZWQpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcblxuICB9KShldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuICBleHBvcnRzLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBhLCBiKSB7XG4gICAgdmFyIGNiLCBvcHRpb25zLCBwYXJzZXI7XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gYjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IGE7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlBhcnNlcihvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlU3RyaW5nKHN0ciwgY2IpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBwcmVmaXhNYXRjaDtcblxuICBwcmVmaXhNYXRjaCA9IG5ldyBSZWdFeHAoLyg/IXhtbG5zKV4uKjovKTtcblxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICBleHBvcnRzLmZpcnN0Q2hhckxvd2VyQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH07XG5cbiAgZXhwb3J0cy5zdHJpcFByZWZpeCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShwcmVmaXhNYXRjaCwgJycpO1xuICB9O1xuXG4gIGV4cG9ydHMucGFyc2VOdW1iZXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFpc05hTihzdHIpKSB7XG4gICAgICBzdHIgPSBzdHIgJSAxID09PSAwID8gcGFyc2VJbnQoc3RyLCAxMCkgOiBwYXJzZUZsb2F0KHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgZXhwb3J0cy5wYXJzZUJvb2xlYW5zID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKC9eKD86dHJ1ZXxmYWxzZSkkL2kudGVzdChzdHIpKSB7XG4gICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBidWlsZGVyLCBkZWZhdWx0cywgcGFyc2VyLCBwcm9jZXNzb3JzLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbiAgYnVpbGRlciA9IHJlcXVpcmUoJy4vYnVpbGRlcicpO1xuXG4gIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5cbiAgcHJvY2Vzc29ycyA9IHJlcXVpcmUoJy4vcHJvY2Vzc29ycycpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cy5kZWZhdWx0cztcblxuICBleHBvcnRzLnByb2Nlc3NvcnMgPSBwcm9jZXNzb3JzO1xuXG4gIGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVmFsaWRhdGlvbkVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIGV4cG9ydHMuQnVpbGRlciA9IGJ1aWxkZXIuQnVpbGRlcjtcblxuICBleHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5cbiAgZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlci5wYXJzZVN0cmluZztcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBhc3NpZ24sIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LFxuICAgIHNsaWNlID0gW10uc2xpY2UsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGFzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBrZXksIGxlbiwgc291cmNlLCBzb3VyY2VzLCB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdLCBzb3VyY2VzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgaWYgKGlzRnVuY3Rpb24oT2JqZWN0LmFzc2lnbikpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gISF2YWwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG5cbiAgaXNPYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAhIXZhbCAmJiAoKHJlZiA9IHR5cGVvZiB2YWwpID09PSAnZnVuY3Rpb24nIHx8IHJlZiA9PT0gJ29iamVjdCcpO1xuICB9O1xuXG4gIGlzQXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihBcnJheS5pc0FycmF5KSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cbiAgfTtcblxuICBpc0VtcHR5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gIXZhbC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIHZhbCkge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh2YWwsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBjdG9yLCBwcm90bztcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiAocHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSkgJiYgKGN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcikgJiYgKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nKSAmJiAoY3RvciBpbnN0YW5jZW9mIGN0b3IpICYmIChGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjdG9yKSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoT2JqZWN0KSk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTEF0dHJpYnV0ZShwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBwYXJlbnQub3B0aW9ucztcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gcGFyZW50LnN0cmluZ2lmeTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGUgbmFtZSBvZiBlbGVtZW50IFwiICsgcGFyZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUgKyBcIiBvZiBlbGVtZW50IFwiICsgcGFyZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuYXR0TmFtZShuYW1lKTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5hdHRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgWE1MQXR0cmlidXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTEF0dHJpYnV0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuYXR0cmlidXRlKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQXR0cmlidXRlO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTE5vZGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxDRGF0YSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTENEYXRhLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTENEYXRhKHBhcmVudCwgdGV4dCkge1xuICAgICAgWE1MQ0RhdGEuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBDREFUQSB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdHJpbmdpZnkuY2RhdGEodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MQ0RhdGEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MQ0RhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmNkYXRhKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQ0RhdGE7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ29tbWVudCwgWE1MTm9kZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTENvbW1lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxDb21tZW50LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTENvbW1lbnQocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxDb21tZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY29tbWVudCB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdHJpbmdpZnkuY29tbWVudCh0ZXh0KTtcbiAgICB9XG5cbiAgICBYTUxDb21tZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTENvbW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmNvbW1lbnQodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxDb21tZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERUREF0dExpc3QsIFhNTE5vZGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERBdHRMaXN0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRFREQXR0TGlzdCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEVERBdHRMaXN0KHBhcmVudCwgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgWE1MRFREQXR0TGlzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKGVsZW1lbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgZWxlbWVudCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cmlidXRlVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVmYXVsdFZhbHVlVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgZGVmYXVsdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlLmluZGV4T2YoJyMnKSAhPT0gMCkge1xuICAgICAgICBkZWZhdWx0VmFsdWVUeXBlID0gJyMnICsgZGVmYXVsdFZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVmYXVsdFZhbHVlVHlwZS5tYXRjaCgvXigjUkVRVUlSRUR8I0lNUExJRUR8I0ZJWEVEfCNERUZBVUxUKSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRlZmF1bHQgdmFsdWUgdHlwZTsgZXhwZWN0ZWQ6ICNSRVFVSVJFRCwgI0lNUExJRUQsICNGSVhFRCBvciAjREVGQVVMVFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgJiYgIWRlZmF1bHRWYWx1ZVR5cGUubWF0Y2goL14oI0ZJWEVEfCNERUZBVUxUKSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IHZhbHVlIG9ubHkgYXBwbGllcyB0byAjRklYRUQgb3IgI0RFRkFVTFRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnROYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShlbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSB0aGlzLnN0cmluZ2lmeS5hdHROYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVUeXBlID0gdGhpcy5zdHJpbmdpZnkuZHRkQXR0VHlwZShhdHRyaWJ1dGVUeXBlKTtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkQXR0RGVmYXVsdChkZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWVUeXBlID0gZGVmYXVsdFZhbHVlVHlwZTtcbiAgICB9XG5cbiAgICBYTUxEVERBdHRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGRBdHRMaXN0KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFREQXR0TGlzdDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERFbGVtZW50LCBYTUxOb2RlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRFRERWxlbWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTERUREVsZW1lbnQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MRFRERWxlbWVudChwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBYTUxEVERFbGVtZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSAnKCNQQ0RBVEEpJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9ICcoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkRWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBYTUxEVERFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGRFbGVtZW50KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFRERWxlbWVudDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERFbnRpdHksIFhNTE5vZGUsIGlzT2JqZWN0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgaXNPYmplY3QgPSByZXF1aXJlKCcuL1V0aWxpdHknKS5pc09iamVjdDtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERFbnRpdHkgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEVERFbnRpdHksIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MRFRERW50aXR5KHBhcmVudCwgcGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBYTUxEVERFbnRpdHkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbnRpdHkgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZW50aXR5IHZhbHVlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wZSA9ICEhcGU7XG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVOYW1lKG5hbWUpO1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmR0ZEVudGl0eVZhbHVlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmFsdWUucHViSUQgJiYgIXZhbHVlLnN5c0lEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGljIGFuZC9vciBzeXN0ZW0gaWRlbnRpZmllcnMgYXJlIHJlcXVpcmVkIGZvciBhbiBleHRlcm5hbCBlbnRpdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSBpZGVudGlmaWVyIGlzIHJlcXVpcmVkIGZvciBhIHB1YmxpYyBleHRlcm5hbCBlbnRpdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnB1YklEICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnB1YklEID0gdGhpcy5zdHJpbmdpZnkuZHRkUHViSUQodmFsdWUucHViSUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5zeXNJRCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zeXNJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFN5c0lEKHZhbHVlLnN5c0lEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubkRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubkRhdGEgPSB0aGlzLnN0cmluZ2lmeS5kdGRORGF0YSh2YWx1ZS5uRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGUgJiYgdGhpcy5uRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdGF0aW9uIGRlY2xhcmF0aW9uIGlzIG5vdCBhbGxvd2VkIGluIGEgcGFyYW1ldGVyIGVudGl0eVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERUREVudGl0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZHRkRW50aXR5KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFRERW50aXR5O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERURE5vdGF0aW9uLCBYTUxOb2RlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRFRETm90YXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEVEROb3RhdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEVEROb3RhdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBYTUxEVEROb3RhdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG5vdGF0aW9uIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMgb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIGlmICh2YWx1ZS5wdWJJRCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRCh2YWx1ZS5wdWJJRCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUuc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQodmFsdWUuc3lzSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERURE5vdGF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGROb3RhdGlvbih0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERURE5vdGF0aW9uO1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERlY2xhcmF0aW9uLCBYTUxOb2RlLCBpc09iamVjdCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9VdGlsaXR5JykuaXNPYmplY3Q7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEZWNsYXJhdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEZWNsYXJhdGlvbihwYXJlbnQsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgWE1MRGVjbGFyYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChpc09iamVjdCh2ZXJzaW9uKSkge1xuICAgICAgICByZWYgPSB2ZXJzaW9uLCB2ZXJzaW9uID0gcmVmLnZlcnNpb24sIGVuY29kaW5nID0gcmVmLmVuY29kaW5nLCBzdGFuZGFsb25lID0gcmVmLnN0YW5kYWxvbmU7XG4gICAgICB9XG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgdmVyc2lvbiA9ICcxLjAnO1xuICAgICAgfVxuICAgICAgdGhpcy52ZXJzaW9uID0gdGhpcy5zdHJpbmdpZnkueG1sVmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgIGlmIChlbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSB0aGlzLnN0cmluZ2lmeS54bWxFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhbmRhbG9uZSA9IHRoaXMuc3RyaW5naWZ5LnhtbFN0YW5kYWxvbmUoc3RhbmRhbG9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRGVjbGFyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmRlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRGVjbGFyYXRpb247XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFREQXR0TGlzdCwgWE1MRFRERWxlbWVudCwgWE1MRFRERW50aXR5LCBYTUxEVEROb3RhdGlvbiwgWE1MRG9jVHlwZSwgWE1MTm9kZSwgaXNPYmplY3QsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBpc09iamVjdCA9IHJlcXVpcmUoJy4vVXRpbGl0eScpLmlzT2JqZWN0O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBYTUxEVERBdHRMaXN0ID0gcmVxdWlyZSgnLi9YTUxEVERBdHRMaXN0Jyk7XG5cbiAgWE1MRFRERW50aXR5ID0gcmVxdWlyZSgnLi9YTUxEVERFbnRpdHknKTtcblxuICBYTUxEVERFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxEVERFbGVtZW50Jyk7XG5cbiAgWE1MRFRETm90YXRpb24gPSByZXF1aXJlKCcuL1hNTERURE5vdGF0aW9uJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2NUeXBlID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRG9jVHlwZSwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEb2NUeXBlKHBhcmVudCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICB2YXIgcmVmLCByZWYxO1xuICAgICAgWE1MRG9jVHlwZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgdGhpcy5kb2N1bWVudE9iamVjdCA9IHBhcmVudDtcbiAgICAgIGlmIChpc09iamVjdChwdWJJRCkpIHtcbiAgICAgICAgcmVmID0gcHViSUQsIHB1YklEID0gcmVmLnB1YklELCBzeXNJRCA9IHJlZi5zeXNJRDtcbiAgICAgIH1cbiAgICAgIGlmIChzeXNJRCA9PSBudWxsKSB7XG4gICAgICAgIHJlZjEgPSBbcHViSUQsIHN5c0lEXSwgc3lzSUQgPSByZWYxWzBdLCBwdWJJRCA9IHJlZjFbMV07XG4gICAgICB9XG4gICAgICBpZiAocHViSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnB1YklEID0gdGhpcy5zdHJpbmdpZnkuZHRkUHViSUQocHViSUQpO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zeXNJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFN5c0lEKHN5c0lEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVsZW1lbnQodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5hdHRMaXN0ID0gZnVuY3Rpb24oZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFREQXR0TGlzdCh0aGlzLCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCBmYWxzZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5wRW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCB0cnVlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLm5vdGF0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERURE5vdGF0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZG9jVHlwZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5hdHQgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRMaXN0KGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUucGVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wRW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdGF0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QoKSB8fCB0aGlzLmRvY3VtZW50T2JqZWN0O1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRG9jVHlwZTtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEb2N1bWVudCwgWE1MTm9kZSwgWE1MU3RyaW5nV3JpdGVyLCBYTUxTdHJpbmdpZmllciwgaXNQbGFpbk9iamVjdCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL1V0aWxpdHknKS5pc1BsYWluT2JqZWN0O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBYTUxTdHJpbmdpZmllciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5naWZpZXInKTtcblxuICBYTUxTdHJpbmdXcml0ZXIgPSByZXF1aXJlKCcuL1hNTFN0cmluZ1dyaXRlcicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRG9jdW1lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEb2N1bWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEb2N1bWVudChvcHRpb25zKSB7XG4gICAgICBYTUxEb2N1bWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBpZiAoIW9wdGlvbnMud3JpdGVyKSB7XG4gICAgICAgIG9wdGlvbnMud3JpdGVyID0gbmV3IFhNTFN0cmluZ1dyaXRlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gbmV3IFhNTFN0cmluZ2lmaWVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5pc0RvY3VtZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBYTUxEb2N1bWVudC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICB2YXIgd3JpdGVyT3B0aW9ucztcbiAgICAgIGlmICghd3JpdGVyKSB7XG4gICAgICAgIHdyaXRlciA9IHRoaXMub3B0aW9ucy53cml0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qod3JpdGVyKSkge1xuICAgICAgICB3cml0ZXJPcHRpb25zID0gd3JpdGVyO1xuICAgICAgICB3cml0ZXIgPSB0aGlzLm9wdGlvbnMud3JpdGVyLnNldCh3cml0ZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cml0ZXIuZG9jdW1lbnQodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kb2N1bWVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERvY3VtZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEF0dHJpYnV0ZSwgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERUREF0dExpc3QsIFhNTERUREVsZW1lbnQsIFhNTERUREVudGl0eSwgWE1MRFRETm90YXRpb24sIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxEb2N1bWVudENCLCBYTUxFbGVtZW50LCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MU3RyaW5nV3JpdGVyLCBYTUxTdHJpbmdpZmllciwgWE1MVGV4dCwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QsIHJlZixcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGlzT2JqZWN0ID0gcmVmLmlzT2JqZWN0LCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb24sIGlzUGxhaW5PYmplY3QgPSByZWYuaXNQbGFpbk9iamVjdDtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgWE1MQ0RhdGEgPSByZXF1aXJlKCcuL1hNTENEYXRhJyk7XG5cbiAgWE1MQ29tbWVudCA9IHJlcXVpcmUoJy4vWE1MQ29tbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTERUREF0dExpc3QgPSByZXF1aXJlKCcuL1hNTERUREF0dExpc3QnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVEROb3RhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRFRETm90YXRpb24nKTtcblxuICBYTUxBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL1hNTEF0dHJpYnV0ZScpO1xuXG4gIFhNTFN0cmluZ2lmaWVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdpZmllcicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2N1bWVudENCID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTERvY3VtZW50Q0Iob3B0aW9ucywgb25EYXRhLCBvbkVuZCkge1xuICAgICAgdmFyIHdyaXRlck9wdGlvbnM7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgaWYgKCFvcHRpb25zLndyaXRlcikge1xuICAgICAgICBvcHRpb25zLndyaXRlciA9IG5ldyBYTUxTdHJpbmdXcml0ZXIob3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qob3B0aW9ucy53cml0ZXIpKSB7XG4gICAgICAgIHdyaXRlck9wdGlvbnMgPSBvcHRpb25zLndyaXRlcjtcbiAgICAgICAgb3B0aW9ucy53cml0ZXIgPSBuZXcgWE1MU3RyaW5nV3JpdGVyKHdyaXRlck9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMud3JpdGVyID0gb3B0aW9ucy53cml0ZXI7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IG5ldyBYTUxTdHJpbmdpZmllcihvcHRpb25zKTtcbiAgICAgIHRoaXMub25EYXRhQ2FsbGJhY2sgPSBvbkRhdGEgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICAgIHRoaXMub25FbmRDYWxsYmFjayA9IG9uRW5kIHx8IGZ1bmN0aW9uKCkge307XG4gICAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudExldmVsID0gLTE7XG4gICAgICB0aGlzLm9wZW5UYWdzID0ge307XG4gICAgICB0aGlzLmRvY3VtZW50U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kb2N1bWVudENvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIHJlZjE7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgbm9kZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLmN1cnJlbnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9jdW1lbnQgY2FuIG9ubHkgaGF2ZSBvbmUgcm9vdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJlZjEgPSBbYXR0cmlidXRlcywgdGV4dF0sIHRleHQgPSByZWYxWzBdLCBhdHRyaWJ1dGVzID0gcmVmMVsxXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBuZXcgWE1MRWxlbWVudCh0aGlzLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsKys7XG4gICAgICB0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudGV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgJiYgdGhpcy5jdXJyZW50Tm9kZSBpbnN0YW5jZW9mIFhNTERvY1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHRkRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBhdHRWYWx1ZTtcbiAgICAgIGlmICghdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLmN1cnJlbnROb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dCgpIGNhbiBvbmx5IGJlIHVzZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW4gZWxlKCkgY2FsbCBpbiBjYWxsYmFjayBtb2RlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChhdHROYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChuYW1lLCBhdHROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0VmFsdWUgPSBuYW1lW2F0dE5hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dE5hbWUsIGF0dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBOdWxsQXR0cmlidXRlcyB8fCAodmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlLmF0dHJpYnV0ZXNbbmFtZV0gPSBuZXcgWE1MQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBub2RlID0gbmV3IFhNTFRleHQodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIudGV4dChub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MQ0RhdGEodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuY2RhdGEobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuY29tbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MQ29tbWVudCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5jb21tZW50KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MUmF3KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLnJhdyhub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBpLCBpbnNUYXJnZXQsIGluc1ZhbHVlLCBsZW4sIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YXJnZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpbnNUYXJnZXQgPSB0YXJnZXRbaV07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgZm9yIChpbnNUYXJnZXQgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwodGFyZ2V0LCBpbnNUYXJnZXQpKSBjb250aW51ZTtcbiAgICAgICAgICBpbnNWYWx1ZSA9IHRhcmdldFtpbnNUYXJnZXRdO1xuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24oaW5zVGFyZ2V0LCBpbnNWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIucHJvY2Vzc2luZ0luc3RydWN0aW9uKG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmRlY2xhcmF0aW9uID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgaWYgKHRoaXMuZG9jdW1lbnRTdGFydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY2xhcmF0aW9uKCkgbXVzdCBiZSB0aGUgZmlyc3Qgbm9kZVwiKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgWE1MRGVjbGFyYXRpb24odGhpcywgdmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZGVjbGFyYXRpb24obm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZG9jdHlwZSA9IGZ1bmN0aW9uKHJvb3QsIHB1YklELCBzeXNJRCkge1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgaWYgKHJvb3QgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJvb3Qgbm9kZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdGQoKSBtdXN0IGNvbWUgYmVmb3JlIHRoZSByb290IG5vZGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnROb2RlID0gbmV3IFhNTERvY1R5cGUodGhpcywgcHViSUQsIHN5c0lEKTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUucm9vdE5vZGVOYW1lID0gcm9vdDtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsKys7XG4gICAgICB0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZHRkRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFRERWxlbWVudCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kdGRFbGVtZW50KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmF0dExpc3QgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFREQXR0TGlzdCh0aGlzLCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEF0dExpc3Qobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbnRpdHkodGhpcywgZmFsc2UsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEVudGl0eShub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5wRW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbnRpdHkodGhpcywgdHJ1ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZHRkRW50aXR5KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vdGF0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVEROb3RhdGlvbih0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kdGROb3RhdGlvbihub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZG9jdW1lbnQgbm9kZSBoYXMgbm8gcGFyZW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLmNsb3NlTm9kZSh0aGlzLmN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wZW5Ob2RlKHRoaXMuY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZU5vZGUodGhpcy5vcGVuVGFnc1t0aGlzLmN1cnJlbnRMZXZlbF0pO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMub3BlblRhZ3NbdGhpcy5jdXJyZW50TGV2ZWxdO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwtLTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnRMZXZlbCA+PSAwKSB7XG4gICAgICAgIHRoaXMudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9uRW5kKCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9wZW5DdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlLmNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbk5vZGUodGhpcy5jdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9wZW5Ob2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLmlzT3Blbikge1xuICAgICAgICBpZiAoIXRoaXMucm9vdCAmJiB0aGlzLmN1cnJlbnRMZXZlbCA9PT0gMCAmJiBub2RlIGluc3RhbmNlb2YgWE1MRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIub3Blbk5vZGUobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuY2xvc2VOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmNsb3NlTm9kZShub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCkpO1xuICAgICAgICByZXR1cm4gbm9kZS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICB0aGlzLmRvY3VtZW50U3RhcnRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5vbkRhdGFDYWxsYmFjayhjaHVuayk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvY3VtZW50Q29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm9uRW5kQ2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vZCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnR4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZGF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuY29tID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5pbnMgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZGVjID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZHRkID0gZnVuY3Rpb24ocm9vdCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N0eXBlKHJvb3QsIHB1YklELCBzeXNJRCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5uID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZGF0YSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuaSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5hdHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlICYmIHRoaXMuY3VycmVudE5vZGUgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dExpc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5hID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSAmJiB0aGlzLmN1cnJlbnROb2RlIGluc3RhbmNlb2YgWE1MRG9jVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRMaXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudGl0eShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnBlbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucEVudGl0eShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RhdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEb2N1bWVudENCO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlLCBYTUxFbGVtZW50LCBYTUxOb2RlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVmLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGlzT2JqZWN0ID0gcmVmLmlzT2JqZWN0LCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb247XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIFhNTEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vWE1MQXR0cmlidXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxFbGVtZW50ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRWxlbWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxFbGVtZW50KHBhcmVudCwgbmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgWE1MRWxlbWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUoYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlzRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5pc1Jvb3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmRvY3VtZW50T2JqZWN0ID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQucm9vdE9iamVjdCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHQsIGF0dE5hbWUsIGNsb25lZFNlbGYsIHJlZjE7XG4gICAgICBjbG9uZWRTZWxmID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgIGlmIChjbG9uZWRTZWxmLmlzUm9vdCkge1xuICAgICAgICBjbG9uZWRTZWxmLmRvY3VtZW50T2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsb25lZFNlbGYuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgcmVmMSA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAoYXR0TmFtZSBpbiByZWYxKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZjEsIGF0dE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgYXR0ID0gcmVmMVthdHROYW1lXTtcbiAgICAgICAgY2xvbmVkU2VsZi5hdHRyaWJ1dGVzW2F0dE5hbWVdID0gYXR0LmNsb25lKCk7XG4gICAgICB9XG4gICAgICBjbG9uZWRTZWxmLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIGNsb25lZENoaWxkO1xuICAgICAgICBjbG9uZWRDaGlsZCA9IGNoaWxkLmNsb25lKCk7XG4gICAgICAgIGNsb25lZENoaWxkLnBhcmVudCA9IGNsb25lZFNlbGY7XG4gICAgICAgIHJldHVybiBjbG9uZWRTZWxmLmNoaWxkcmVuLnB1c2goY2xvbmVkQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xvbmVkU2VsZjtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBhdHRWYWx1ZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIGZvciAoYXR0TmFtZSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwgYXR0TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dFZhbHVlID0gbmFtZVthdHROYW1lXTtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHROYW1lLCBhdHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwTnVsbEF0dHJpYnV0ZXMgfHwgKHZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gbmV3IFhNTEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgYXR0TmFtZSwgaSwgbGVuO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGF0dE5hbWUgPSBuYW1lW2ldO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZWxlbWVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYXR0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLmEgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEVsZW1lbnQ7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxFbGVtZW50LCBYTUxOb2RlLCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MVGV4dCwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJlZixcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGlzT2JqZWN0ID0gcmVmLmlzT2JqZWN0LCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb24sIGlzRW1wdHkgPSByZWYuaXNFbXB0eTtcblxuICBYTUxFbGVtZW50ID0gbnVsbDtcblxuICBYTUxDRGF0YSA9IG51bGw7XG5cbiAgWE1MQ29tbWVudCA9IG51bGw7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSBudWxsO1xuXG4gIFhNTERvY1R5cGUgPSBudWxsO1xuXG4gIFhNTFJhdyA9IG51bGw7XG5cbiAgWE1MVGV4dCA9IG51bGw7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gbnVsbDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTE5vZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MTm9kZShwYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucGFyZW50Lm9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5ID0gdGhpcy5wYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKCFYTUxFbGVtZW50KSB7XG4gICAgICAgIFhNTEVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTEVsZW1lbnQnKTtcbiAgICAgICAgWE1MQ0RhdGEgPSByZXF1aXJlKCcuL1hNTENEYXRhJyk7XG4gICAgICAgIFhNTENvbW1lbnQgPSByZXF1aXJlKCcuL1hNTENvbW1lbnQnKTtcbiAgICAgICAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG4gICAgICAgIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcbiAgICAgICAgWE1MUmF3ID0gcmVxdWlyZSgnLi9YTUxSYXcnKTtcbiAgICAgICAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuICAgICAgICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSByZXF1aXJlKCcuL1hNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgY2hpbGROb2RlLCBpdGVtLCBqLCBrLCBrZXksIGxhc3RDaGlsZCwgbGVuLCBsZW4xLCByZWYxLCB2YWw7XG4gICAgICBsYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJlZjEgPSBbYXR0cmlidXRlcywgdGV4dF0sIHRleHQgPSByZWYxWzBdLCBhdHRyaWJ1dGVzID0gcmVmMVsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGl0ZW0gPSBuYW1lW2pdO1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChuYW1lLmFwcGx5KCkpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgdmFsID0gbmFtZVtrZXldO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGlzT2JqZWN0KHZhbCkpICYmIChpc0VtcHR5KHZhbCkpKSB7XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzICYmIHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRBdHRLZXkgJiYga2V5LmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleSkgPT09IDApIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuYXR0cmlidXRlKGtleS5zdWJzdHIodGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleS5sZW5ndGgpLCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5zZXBhcmF0ZUFycmF5SXRlbXMgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdmFsLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICBpdGVtID0gdmFsW2tdO1xuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSB7fTtcbiAgICAgICAgICAgICAgY2hpbGROb2RlW2tleV0gPSBpdGVtO1xuICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChrZXkpO1xuICAgICAgICAgICAgbGFzdENoaWxkLmVsZW1lbnQodmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGtleSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFRleHRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRUZXh0S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMudGV4dCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENEYXRhS2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q0RhdGFLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5jZGF0YSh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENvbW1lbnRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDb21tZW50S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuY29tbWVudCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFJhd0tleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFJhd0tleSkgPT09IDApIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLnJhdyh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFBJS2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5pbnN0cnVjdGlvbihuYW1lLnN1YnN0cih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkubGVuZ3RoKSwgdGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdENoaWxkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBhbnkgZWxlbWVudHMgd2l0aDogXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5zZXJ0IGVsZW1lbnRzIGF0IHJvb3QgbGV2ZWxcIik7XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnNlcnQgZWxlbWVudHMgYXQgcm9vdCBsZXZlbFwiKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHJlZjE7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgcm9vdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICBbXS5zcGxpY2UuYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIFtpLCBpIC0gaSArIDFdLmNvbmNhdChyZWYxID0gW10pKSwgcmVmMTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZCwgcmVmMTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KTtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnZhbHVlT2YoKTtcbiAgICAgIGlmICghaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgcmVmMSA9IFthdHRyaWJ1dGVzLCB0ZXh0XSwgdGV4dCA9IHJlZjFbMF0sIGF0dHJpYnV0ZXMgPSByZWYxWzFdO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBuZXcgWE1MRWxlbWVudCh0aGlzLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgY2hpbGQudGV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MVGV4dCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTENEYXRhKHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY29tbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxDb21tZW50KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY29tbWVudEJlZm9yZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmNvbW1lbnQodmFsdWUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNvbW1lbnRBZnRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSArIDEpO1xuICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudC5jb21tZW50KHZhbHVlKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MUmF3KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgaW5zVGFyZ2V0LCBpbnNWYWx1ZSwgaW5zdHJ1Y3Rpb24sIGosIGxlbjtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGluc1RhcmdldCA9IHRhcmdldFtqXTtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9uKGluc1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBmb3IgKGluc1RhcmdldCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh0YXJnZXQsIGluc1RhcmdldCkpIGNvbnRpbnVlO1xuICAgICAgICAgIGluc1ZhbHVlID0gdGFyZ2V0W2luc1RhcmdldF07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQsIGluc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RydWN0aW9uID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbnN0cnVjdGlvbkJlZm9yZSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zdHJ1Y3Rpb25BZnRlciA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50Lmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRlY2xhcmF0aW9uID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciBkb2MsIHhtbGRlYztcbiAgICAgIGRvYyA9IHRoaXMuZG9jdW1lbnQoKTtcbiAgICAgIHhtbGRlYyA9IG5ldyBYTUxEZWNsYXJhdGlvbihkb2MsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICAgIGlmIChkb2MuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBYTUxEZWNsYXJhdGlvbikge1xuICAgICAgICBkb2MuY2hpbGRyZW5bMF0gPSB4bWxkZWM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2MuY2hpbGRyZW4udW5zaGlmdCh4bWxkZWMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvYy5yb290KCkgfHwgZG9jO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2N0eXBlID0gZnVuY3Rpb24ocHViSUQsIHN5c0lEKSB7XG4gICAgICB2YXIgY2hpbGQsIGRvYywgZG9jdHlwZSwgaSwgaiwgaywgbGVuLCBsZW4xLCByZWYxLCByZWYyO1xuICAgICAgZG9jID0gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgZG9jdHlwZSA9IG5ldyBYTUxEb2NUeXBlKGRvYywgcHViSUQsIHN5c0lEKTtcbiAgICAgIHJlZjEgPSBkb2MuY2hpbGRyZW47XG4gICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKSB7XG4gICAgICAgICAgZG9jLmNoaWxkcmVuW2ldID0gZG9jdHlwZTtcbiAgICAgICAgICByZXR1cm4gZG9jdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVmMiA9IGRvYy5jaGlsZHJlbjtcbiAgICAgIGZvciAoaSA9IGsgPSAwLCBsZW4xID0gcmVmMi5sZW5ndGg7IGsgPCBsZW4xOyBpID0gKytrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmMltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmlzUm9vdCkge1xuICAgICAgICAgIGRvYy5jaGlsZHJlbi5zcGxpY2UoaSwgMCwgZG9jdHlwZSk7XG4gICAgICAgICAgcmV0dXJuIGRvY3R5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvYy5jaGlsZHJlbi5wdXNoKGRvY3R5cGUpO1xuICAgICAgcmV0dXJuIGRvY3R5cGU7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJvb3Qgbm9kZSBoYXMgbm8gcGFyZW50LiBVc2UgZG9jKCkgaWYgeW91IG5lZWQgdG8gZ2V0IHRoZSBkb2N1bWVudCBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIG5vZGUgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNEb2N1bWVudCkge1xuICAgICAgICAgIHJldHVybiBub2RlLnJvb3RPYmplY3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc1Jvb3QpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgbm9kZSA9IHRoaXM7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc0RvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCkuZW5kKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgYXQgdGhlIGZpcnN0IG5vZGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW5baSAtIDFdO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPT09IC0xIHx8IGkgPT09IHRoaXMucGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdCB0aGUgbGFzdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuW2kgKyAxXTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW1wb3J0RG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBjbG9uZWRSb290O1xuICAgICAgY2xvbmVkUm9vdCA9IGRvYy5yb290KCkuY2xvbmUoKTtcbiAgICAgIGNsb25lZFJvb3QucGFyZW50ID0gdGhpcztcbiAgICAgIGNsb25lZFJvb3QuaXNSb290ID0gZmFsc2U7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2xvbmVkUm9vdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubm9kID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudHh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRlYyA9IGZ1bmN0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmR0ZCA9IGZ1bmN0aW9uKHB1YklELCBzeXNJRCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdHlwZShwdWJJRCwgc3lzSUQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubiA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmkgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXAoKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW1wb3J0WE1MQnVpbGRlciA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0RG9jdW1lbnQoZG9jKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTE5vZGU7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxOb2RlLCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHBhcmVudCwgdGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBpbnN0cnVjdGlvbiB0YXJnZXRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldCA9IHRoaXMuc3RyaW5naWZ5Lmluc1RhcmdldCh0YXJnZXQpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5pbnNWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykucHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTE5vZGUsIFhNTFJhdyxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFJhdyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFJhdywgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxSYXcocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxSYXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByYXcgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5yYXcodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MUmF3LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTFJhdy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykucmF3KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MUmF3O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTENEYXRhLCBYTUxDb21tZW50LCBYTUxEVERBdHRMaXN0LCBYTUxEVERFbGVtZW50LCBYTUxEVERFbnRpdHksIFhNTERURE5vdGF0aW9uLCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRWxlbWVudCwgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBYTUxSYXcsIFhNTFN0cmVhbVdyaXRlciwgWE1MVGV4dCwgWE1MV3JpdGVyQmFzZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9YTUxEZWNsYXJhdGlvbicpO1xuXG4gIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcblxuICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcblxuICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG5cbiAgWE1MRWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRWxlbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRFREQXR0TGlzdCA9IHJlcXVpcmUoJy4vWE1MRFREQXR0TGlzdCcpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERURE5vdGF0aW9uID0gcmVxdWlyZSgnLi9YTUxEVEROb3RhdGlvbicpO1xuXG4gIFhNTFdyaXRlckJhc2UgPSByZXF1aXJlKCcuL1hNTFdyaXRlckJhc2UnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFN0cmVhbVdyaXRlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFN0cmVhbVdyaXRlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxTdHJlYW1Xcml0ZXIoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICBYTUxTdHJlYW1Xcml0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICB9XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmRvY3VtZW50ID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIGosIGxlbiwgbGVuMSwgcmVmLCByZWYxLCByZXN1bHRzO1xuICAgICAgcmVmID0gZG9jLmNoaWxkcmVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICBjaGlsZC5pc0xhc3RSb290Tm9kZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZG9jLmNoaWxkcmVuW2RvYy5jaGlsZHJlbi5sZW5ndGggLSAxXS5pc0xhc3RSb290Tm9kZSA9IHRydWU7XG4gICAgICByZWYxID0gZG9jLmNoaWxkcmVuO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmMVtqXTtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERlY2xhcmF0aW9uKTpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmRlY2xhcmF0aW9uKGNoaWxkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKTpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmRvY1R5cGUoY2hpbGQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuY29tbWVudChjaGlsZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKTpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmVsZW1lbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24oYXR0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUoJyAnICsgYXR0Lm5hbWUgKyAnPVwiJyArIGF0dC52YWx1ZSArICdcIicpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IVtDREFUQVsnICsgbm9kZS50ZXh0ICsgJ11dPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhLS0gJyArIG5vZGUudGV4dCArICcgLS0+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkpO1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJzw/eG1sIHZlcnNpb249XCInICsgbm9kZS52ZXJzaW9uICsgJ1wiJyk7XG4gICAgICBpZiAobm9kZS5lbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgZW5jb2Rpbmc9XCInICsgbm9kZS5lbmNvZGluZyArICdcIicpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgc3RhbmRhbG9uZT1cIicgKyBub2RlLnN0YW5kYWxvbmUgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc/PicpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZG9jVHlwZSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSk7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPCFET0NUWVBFICcgKyBub2RlLnJvb3QoKS5uYW1lKTtcbiAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIicpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFsnKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICAgICAgcmVmID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRFREQXR0TGlzdCk6XG4gICAgICAgICAgICAgIHRoaXMuZHRkQXR0TGlzdChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERFbGVtZW50KTpcbiAgICAgICAgICAgICAgdGhpcy5kdGRFbGVtZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERUREVudGl0eSk6XG4gICAgICAgICAgICAgIHRoaXMuZHRkRW50aXR5KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERURE5vdGF0aW9uKTpcbiAgICAgICAgICAgICAgdGhpcy5kdGROb3RhdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDRGF0YSk6XG4gICAgICAgICAgICAgIHRoaXMuY2RhdGEoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MQ29tbWVudCk6XG4gICAgICAgICAgICAgIHRoaXMuY29tbWVudChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIERURCBub2RlIHR5cGU6IFwiICsgY2hpbGQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCddJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgYXR0LCBjaGlsZCwgaSwgbGVuLCBuYW1lLCByZWYsIHJlZjEsIHNwYWNlO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IHRoaXMuc3BhY2UobGV2ZWwpO1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoc3BhY2UgKyAnPCcgKyBub2RlLm5hbWUpO1xuICAgICAgcmVmID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgYXR0ID0gcmVmW25hbWVdO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHQpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IG5vZGUuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS52YWx1ZSA9PT0gJyc7XG4gICAgICB9KSkge1xuICAgICAgICBpZiAodGhpcy5hbGxvd0VtcHR5KSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJz48LycgKyBub2RlLm5hbWUgKyAnPicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICcvPicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJldHR5ICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChub2RlLmNoaWxkcmVuWzBdLnZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc+Jyk7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKG5vZGUuY2hpbGRyZW5bMF0udmFsdWUpO1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPC8nICsgbm9kZS5uYW1lICsgJz4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc+JyArIHRoaXMubmV3bGluZSk7XG4gICAgICAgIHJlZjEgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENEYXRhKTpcbiAgICAgICAgICAgICAgdGhpcy5jZGF0YShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDb21tZW50KTpcbiAgICAgICAgICAgICAgdGhpcy5jb21tZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTEVsZW1lbnQpOlxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MUmF3KTpcbiAgICAgICAgICAgICAgdGhpcy5yYXcoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MVGV4dCk6XG4gICAgICAgICAgICAgIHRoaXMudGV4dChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFhNTCBub2RlIHR5cGU6IFwiICsgY2hpbGQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHNwYWNlICsgJzwvJyArIG5vZGUubmFtZSArICc+Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkgKyAnPD8nICsgbm9kZS50YXJnZXQpO1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyAnICsgbm9kZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz8+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArIG5vZGUudmFsdWUgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgbm9kZS52YWx1ZSArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZHRkQXR0TGlzdCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IUFUVExJU1QgJyArIG5vZGUuZWxlbWVudE5hbWUgKyAnICcgKyBub2RlLmF0dHJpYnV0ZU5hbWUgKyAnICcgKyBub2RlLmF0dHJpYnV0ZVR5cGUpO1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlVHlwZSAhPT0gJyNERUZBVUxUJykge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnICcgKyBub2RlLmRlZmF1bHRWYWx1ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgXCInICsgbm9kZS5kZWZhdWx0VmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmR0ZEVsZW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkgKyAnPCFFTEVNRU5UICcgKyBub2RlLm5hbWUgKyAnICcgKyBub2RlLnZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmR0ZEVudGl0eSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IUVOVElUWScpO1xuICAgICAgaWYgKG5vZGUucGUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyAlJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSgnICcgKyBub2RlLm5hbWUpO1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBcIicgKyBub2RlLnZhbHVlICsgJ1wiJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5wdWJJRCAmJiBub2RlLnN5c0lEKSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgU1lTVEVNIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uRGF0YSkge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgTkRBVEEgJyArIG5vZGUubkRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5kdGROb3RhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IU5PVEFUSU9OICcgKyBub2RlLm5hbWUpO1xuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5wdWJJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZW5kbGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZS5pc0xhc3RSb290Tm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gWE1MU3RyZWFtV3JpdGVyO1xuXG4gIH0pKFhNTFdyaXRlckJhc2UpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTENEYXRhLCBYTUxDb21tZW50LCBYTUxEVERBdHRMaXN0LCBYTUxEVERFbGVtZW50LCBYTUxEVERFbnRpdHksIFhNTERURE5vdGF0aW9uLCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRWxlbWVudCwgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBYTUxSYXcsIFhNTFN0cmluZ1dyaXRlciwgWE1MVGV4dCwgWE1MV3JpdGVyQmFzZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9YTUxEZWNsYXJhdGlvbicpO1xuXG4gIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcblxuICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcblxuICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG5cbiAgWE1MRWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRWxlbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRFREQXR0TGlzdCA9IHJlcXVpcmUoJy4vWE1MRFREQXR0TGlzdCcpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERURE5vdGF0aW9uID0gcmVxdWlyZSgnLi9YTUxEVEROb3RhdGlvbicpO1xuXG4gIFhNTFdyaXRlckJhc2UgPSByZXF1aXJlKCcuL1hNTFdyaXRlckJhc2UnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFN0cmluZ1dyaXRlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFN0cmluZ1dyaXRlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxTdHJpbmdXcml0ZXIob3B0aW9ucykge1xuICAgICAgWE1MU3RyaW5nV3JpdGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByLCByZWY7XG4gICAgICB0aGlzLnRleHRpc3ByZXNlbnQgPSBmYWxzZTtcbiAgICAgIHIgPSAnJztcbiAgICAgIHJlZiA9IGRvYy5jaGlsZHJlbjtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgciArPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRGVjbGFyYXRpb24pOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbihjaGlsZCk7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jVHlwZShjaGlsZCk7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDb21tZW50KTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudChjaGlsZCk7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oY2hpbGQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChjaGlsZCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJldHR5ICYmIHIuc2xpY2UoLXRoaXMubmV3bGluZS5sZW5ndGgpID09PSB0aGlzLm5ld2xpbmUpIHtcbiAgICAgICAgciA9IHIuc2xpY2UoMCwgLXRoaXMubmV3bGluZS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24oYXR0KSB7XG4gICAgICByZXR1cm4gJyAnICsgYXR0Lm5hbWUgKyAnPVwiJyArIGF0dC52YWx1ZSArICdcIic7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhW0NEQVRBWycgKyBub2RlLnRleHQgKyAnXV0+JyArIHRoaXMubmV3bGluZTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYWNlKGxldmVsKSArICc8IS0tICcgKyBub2RlLnRleHQgKyAnIC0tPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICByID0gdGhpcy5zcGFjZShsZXZlbCk7XG4gICAgICByICs9ICc8P3htbCB2ZXJzaW9uPVwiJyArIG5vZGUudmVyc2lvbiArICdcIic7XG4gICAgICBpZiAobm9kZS5lbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHIgKz0gJyBlbmNvZGluZz1cIicgKyBub2RlLmVuY29kaW5nICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnN0YW5kYWxvbmUgIT0gbnVsbCkge1xuICAgICAgICByICs9ICcgc3RhbmRhbG9uZT1cIicgKyBub2RlLnN0YW5kYWxvbmUgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPz4nO1xuICAgICAgciArPSB0aGlzLm5ld2xpbmU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kb2NUeXBlID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByLCByZWY7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKTtcbiAgICAgIHIgKz0gJzwhRE9DVFlQRSAnICsgbm9kZS5yb290KCkubmFtZTtcbiAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHIgKz0gJyBbJztcbiAgICAgICAgciArPSB0aGlzLm5ld2xpbmU7XG4gICAgICAgIHJlZiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgIHIgKz0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERBdHRMaXN0KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kdGRBdHRMaXN0KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERFbGVtZW50KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kdGRFbGVtZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERFbnRpdHkpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR0ZEVudGl0eShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRFRETm90YXRpb24pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR0ZE5vdGF0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDRGF0YSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RhdGEoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ0luc3RydWN0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gRFREIG5vZGUgdHlwZTogXCIgKyBjaGlsZC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gJ10nO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPic7XG4gICAgICByICs9IHRoaXMubmV3bGluZTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIGF0dCwgY2hpbGQsIGksIGosIGxlbiwgbGVuMSwgbmFtZSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZSwgdGV4dGlzcHJlc2VudHdhc3NldDtcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgdGV4dGlzcHJlc2VudHdhc3NldCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMudGV4dGlzcHJlc2VudCkge1xuICAgICAgICB0aGlzLm5ld2xpbmUgPSAnJztcbiAgICAgICAgdGhpcy5wcmV0dHkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmV3bGluZSA9IHRoaXMubmV3bGluZWRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJldHR5ID0gdGhpcy5wcmV0dHlkZWZhdWx0O1xuICAgICAgfVxuICAgICAgc3BhY2UgPSB0aGlzLnNwYWNlKGxldmVsKTtcbiAgICAgIHIgPSAnJztcbiAgICAgIHIgKz0gc3BhY2UgKyAnPCcgKyBub2RlLm5hbWU7XG4gICAgICByZWYgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBhdHQgPSByZWZbbmFtZV07XG4gICAgICAgIHIgKz0gdGhpcy5hdHRyaWJ1dGUoYXR0KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBub2RlLmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudmFsdWUgPT09ICcnO1xuICAgICAgfSkpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dFbXB0eSkge1xuICAgICAgICAgIHIgKz0gJz48LycgKyBub2RlLm5hbWUgKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnLz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJldHR5ICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChub2RlLmNoaWxkcmVuWzBdLnZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgIHIgKz0gJz4nO1xuICAgICAgICByICs9IG5vZGUuY2hpbGRyZW5bMF0udmFsdWU7XG4gICAgICAgIHIgKz0gJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRvbnRwcmV0dHl0ZXh0bm9kZXMpIHtcbiAgICAgICAgICByZWYxID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZjFbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnRleHRpc3ByZXNlbnQrKztcbiAgICAgICAgICAgICAgdGV4dGlzcHJlc2VudHdhc3NldCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXh0aXNwcmVzZW50KSB7XG4gICAgICAgICAgdGhpcy5uZXdsaW5lID0gJyc7XG4gICAgICAgICAgdGhpcy5wcmV0dHkgPSBmYWxzZTtcbiAgICAgICAgICBzcGFjZSA9IHRoaXMuc3BhY2UobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICByZWYyID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjIubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYyW2pdO1xuICAgICAgICAgIHIgKz0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDRGF0YSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RhdGEoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTEVsZW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFJhdyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxUZXh0KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFhNTCBub2RlIHR5cGU6IFwiICsgY2hpbGQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dGlzcHJlc2VudHdhc3NldCkge1xuICAgICAgICAgIHRoaXMudGV4dGlzcHJlc2VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50ZXh0aXNwcmVzZW50KSB7XG4gICAgICAgICAgdGhpcy5uZXdsaW5lID0gdGhpcy5uZXdsaW5lZGVmYXVsdDtcbiAgICAgICAgICB0aGlzLnByZXR0eSA9IHRoaXMucHJldHR5ZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByICs9IHNwYWNlICsgJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8PycgKyBub2RlLnRhcmdldDtcbiAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHIgKz0gJyAnICsgbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz8+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyBub2RlLnZhbHVlICsgdGhpcy5uZXdsaW5lO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgbm9kZS52YWx1ZSArIHRoaXMubmV3bGluZTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kdGRBdHRMaXN0ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgciA9IHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhQVRUTElTVCAnICsgbm9kZS5lbGVtZW50TmFtZSArICcgJyArIG5vZGUuYXR0cmlidXRlTmFtZSArICcgJyArIG5vZGUuYXR0cmlidXRlVHlwZTtcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZVR5cGUgIT09ICcjREVGQVVMVCcpIHtcbiAgICAgICAgciArPSAnICcgKyBub2RlLmRlZmF1bHRWYWx1ZVR5cGU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgciArPSAnIFwiJyArIG5vZGUuZGVmYXVsdFZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZHRkRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCFFTEVNRU5UICcgKyBub2RlLm5hbWUgKyAnICcgKyBub2RlLnZhbHVlICsgdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmR0ZEVudGl0eSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8IUVOVElUWSc7XG4gICAgICBpZiAobm9kZS5wZSkge1xuICAgICAgICByICs9ICcgJSc7XG4gICAgICB9XG4gICAgICByICs9ICcgJyArIG5vZGUubmFtZTtcbiAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHIgKz0gJyBcIicgKyBub2RlLnZhbHVlICsgJ1wiJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubkRhdGEpIHtcbiAgICAgICAgICByICs9ICcgTkRBVEEgJyArIG5vZGUubkRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZHRkTm90YXRpb24gPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICByID0gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCFOT1RBVElPTiAnICsgbm9kZS5uYW1lO1xuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUucHViSUQpIHtcbiAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5vcGVuTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgYXR0LCBuYW1lLCByLCByZWY7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgWE1MRWxlbWVudCkge1xuICAgICAgICByID0gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCcgKyBub2RlLm5hbWU7XG4gICAgICAgIHJlZiA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dCA9IHJlZltuYW1lXTtcbiAgICAgICAgICByICs9IHRoaXMuYXR0cmlidXRlKGF0dCk7XG4gICAgICAgIH1cbiAgICAgICAgciArPSAobm9kZS5jaGlsZHJlbiA/ICc+JyA6ICcvPicpICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8IURPQ1RZUEUgJyArIG5vZGUucm9vdE5vZGVOYW1lO1xuICAgICAgICBpZiAobm9kZS5wdWJJRCAmJiBub2RlLnN5c0lEKSB7XG4gICAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gKG5vZGUuY2hpbGRyZW4gPyAnIFsnIDogJz4nKSArIHRoaXMubmV3bGluZTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuY2xvc2VOb2RlID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICEobm9kZSBpbnN0YW5jZW9mIFhNTEVsZW1lbnQpOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNwYWNlKGxldmVsKSArICc8LycgKyBub2RlLm5hbWUgKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIGNhc2UgIShub2RlIGluc3RhbmNlb2YgWE1MRG9jVHlwZSk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgJ10+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTFN0cmluZ1dyaXRlcjtcblxuICB9KShYTUxXcml0ZXJCYXNlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxTdHJpbmdpZmllcixcbiAgICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxTdHJpbmdpZmllciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxTdHJpbmdpZmllcihvcHRpb25zKSB7XG4gICAgICB0aGlzLmFzc2VydExlZ2FsQ2hhciA9IGJpbmQodGhpcy5hc3NlcnRMZWdhbENoYXIsIHRoaXMpO1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICB0aGlzLm5vRG91YmxlRW5jb2RpbmcgPSBvcHRpb25zLm5vRG91YmxlRW5jb2Rpbmc7XG4gICAgICByZWYgPSBvcHRpb25zLnN0cmluZ2lmeSB8fCB7fTtcbiAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZWxlTmFtZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmVsZVRleHQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHRoaXMuZWxFc2NhcGUodmFsKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgnXV0+JywgJ11dXV0+PCFbQ0RBVEFbPicpO1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICh2YWwubWF0Y2goLy0tLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudCB0ZXh0IGNhbm5vdCBjb250YWluIGRvdWJsZS1oeXBlbjogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dE5hbWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHJldHVybiB0aGlzLmF0dEVzY2FwZSh2YWwpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuaW5zVGFyZ2V0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5pbnNWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAodmFsLm1hdGNoKC9cXD8+LykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9jZXNzaW5nIGluc3RydWN0aW9uIHZhbHVlOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUueG1sVmVyc2lvbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAoIXZhbC5tYXRjaCgvMVxcLlswLTldKy8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbiBudW1iZXI6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxFbmNvZGluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAoIXZhbC5tYXRjaCgvXltBLVphLXpdKD86W0EtWmEtejAtOS5fLV0pKiQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVuY29kaW5nOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUueG1sU3RhbmRhbG9uZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICByZXR1cm4gXCJ5ZXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIm5vXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRQdWJJRCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkU3lzSUQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkQXR0VHlwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkQXR0RGVmYXVsdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRFbnRpdHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkTkRhdGEgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRBdHRLZXkgPSAnQCc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydFBJS2V5ID0gJz8nO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRUZXh0S2V5ID0gJyN0ZXh0JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0Q0RhdGFLZXkgPSAnI2NkYXRhJztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0Q29tbWVudEtleSA9ICcjY29tbWVudCc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydFJhd0tleSA9ICcjcmF3JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5hc3NlcnRMZWdhbENoYXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXM7XG4gICAgICByZXMgPSBzdHIubWF0Y2goL1tcXDBcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gc3RyaW5nOiBcIiArIHN0ciArIFwiIGF0IGluZGV4IFwiICsgcmVzLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5lbEVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGFtcHJlZ2V4O1xuICAgICAgYW1wcmVnZXggPSB0aGlzLm5vRG91YmxlRW5jb2RpbmcgPyAvKD8hJlxcUys7KSYvZyA6IC8mL2c7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYW1wcmVnZXgsICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFxyL2csICcmI3hEOycpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXR0RXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYW1wcmVnZXg7XG4gICAgICBhbXByZWdleCA9IHRoaXMubm9Eb3VibGVFbmNvZGluZyA/IC8oPyEmXFxTKzspJi9nIDogLyYvZztcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShhbXByZWdleCwgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC9cXHQvZywgJyYjeDk7JykucmVwbGFjZSgvXFxuL2csICcmI3hBOycpLnJlcGxhY2UoL1xcci9nLCAnJiN4RDsnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTFN0cmluZ2lmaWVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MTm9kZSwgWE1MVGV4dCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFRleHQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxUZXh0LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTFRleHQocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxUZXh0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZWxlbWVudCB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmVsZVRleHQodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MVGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxUZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS50ZXh0KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MVGV4dDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxXcml0ZXJCYXNlLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFdyaXRlckJhc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MV3JpdGVyQmFzZShvcHRpb25zKSB7XG4gICAgICB2YXIga2V5LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHZhbHVlO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHRoaXMucHJldHR5ID0gb3B0aW9ucy5wcmV0dHkgfHwgZmFsc2U7XG4gICAgICB0aGlzLmFsbG93RW1wdHkgPSAocmVmID0gb3B0aW9ucy5hbGxvd0VtcHR5KSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG4gICAgICBpZiAodGhpcy5wcmV0dHkpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAocmVmMSA9IG9wdGlvbnMuaW5kZW50KSAhPSBudWxsID8gcmVmMSA6ICcgICc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9IChyZWYyID0gb3B0aW9ucy5uZXdsaW5lKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgICB0aGlzLm9mZnNldCA9IChyZWYzID0gb3B0aW9ucy5vZmZzZXQpICE9IG51bGwgPyByZWYzIDogMDtcbiAgICAgICAgdGhpcy5kb250cHJldHR5dGV4dG5vZGVzID0gKHJlZjQgPSBvcHRpb25zLmRvbnRwcmV0dHl0ZXh0bm9kZXMpICE9IG51bGwgPyByZWY0IDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gJyc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9ICcnO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZG9udHByZXR0eXRleHRub2RlcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPSAocmVmNSA9IG9wdGlvbnMuc3BhY2ViZWZvcmVzbGFzaCkgIT0gbnVsbCA/IHJlZjUgOiAnJztcbiAgICAgIGlmICh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zcGFjZWJlZm9yZXNsYXNoID0gJyAnO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXdsaW5lZGVmYXVsdCA9IHRoaXMubmV3bGluZTtcbiAgICAgIHRoaXMucHJldHR5ZGVmYXVsdCA9IHRoaXMucHJldHR5O1xuICAgICAgcmVmNiA9IG9wdGlvbnMud3JpdGVyIHx8IHt9O1xuICAgICAgZm9yIChrZXkgaW4gcmVmNikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWY2LCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWY2W2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTFdyaXRlckJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgaWYgKFwicHJldHR5XCIgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnByZXR0eSA9IG9wdGlvbnMucHJldHR5O1xuICAgICAgfVxuICAgICAgaWYgKFwiYWxsb3dFbXB0eVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hbGxvd0VtcHR5ID0gb3B0aW9ucy5hbGxvd0VtcHR5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJldHR5KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gXCJpbmRlbnRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbmRlbnQgOiAnICAnO1xuICAgICAgICB0aGlzLm5ld2xpbmUgPSBcIm5ld2xpbmVcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5uZXdsaW5lIDogJ1xcbic7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gXCJvZmZzZXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5vZmZzZXQgOiAwO1xuICAgICAgICB0aGlzLmRvbnRwcmV0dHl0ZXh0bm9kZXMgPSBcImRvbnRwcmV0dHl0ZXh0bm9kZXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kb250cHJldHR5dGV4dG5vZGVzIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gJyc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9ICcnO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZG9udHByZXR0eXRleHRub2RlcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPSBcInNwYWNlYmVmb3Jlc2xhc2hcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zcGFjZWJlZm9yZXNsYXNoIDogJyc7XG4gICAgICBpZiAodGhpcy5zcGFjZWJlZm9yZXNsYXNoID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3BhY2ViZWZvcmVzbGFzaCA9ICcgJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV3bGluZWRlZmF1bHQgPSB0aGlzLm5ld2xpbmU7XG4gICAgICB0aGlzLnByZXR0eWRlZmF1bHQgPSB0aGlzLnByZXR0eTtcbiAgICAgIHJlZiA9IG9wdGlvbnMud3JpdGVyIHx8IHt9O1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTFdyaXRlckJhc2UucHJvdG90eXBlLnNwYWNlID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQ7XG4gICAgICBpZiAodGhpcy5wcmV0dHkpIHtcbiAgICAgICAgaW5kZW50ID0gKGxldmVsIHx8IDApICsgdGhpcy5vZmZzZXQgKyAxO1xuICAgICAgICBpZiAoaW5kZW50ID4gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkoaW5kZW50KS5qb2luKHRoaXMuaW5kZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTFdyaXRlckJhc2U7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEb2N1bWVudCwgWE1MRG9jdW1lbnRDQiwgWE1MU3RyZWFtV3JpdGVyLCBYTUxTdHJpbmdXcml0ZXIsIGFzc2lnbiwgaXNGdW5jdGlvbiwgcmVmO1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4vVXRpbGl0eScpLCBhc3NpZ24gPSByZWYuYXNzaWduLCBpc0Z1bmN0aW9uID0gcmVmLmlzRnVuY3Rpb247XG5cbiAgWE1MRG9jdW1lbnQgPSByZXF1aXJlKCcuL1hNTERvY3VtZW50Jyk7XG5cbiAgWE1MRG9jdW1lbnRDQiA9IHJlcXVpcmUoJy4vWE1MRG9jdW1lbnRDQicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgWE1MU3RyZWFtV3JpdGVyID0gcmVxdWlyZSgnLi9YTUxTdHJlYW1Xcml0ZXInKTtcblxuICBtb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lLCB4bWxkZWMsIGRvY3R5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jLCByb290O1xuICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgZWxlbWVudCBuZWVkcyBhIG5hbWVcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIHhtbGRlYywgZG9jdHlwZSwgb3B0aW9ucyk7XG4gICAgZG9jID0gbmV3IFhNTERvY3VtZW50KG9wdGlvbnMpO1xuICAgIHJvb3QgPSBkb2MuZWxlbWVudChuYW1lKTtcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGxlc3MpIHtcbiAgICAgIGRvYy5kZWNsYXJhdGlvbihvcHRpb25zKTtcbiAgICAgIGlmICgob3B0aW9ucy5wdWJJRCAhPSBudWxsKSB8fCAob3B0aW9ucy5zeXNJRCAhPSBudWxsKSkge1xuICAgICAgICBkb2MuZG9jdHlwZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuYmVnaW4gPSBmdW5jdGlvbihvcHRpb25zLCBvbkRhdGEsIG9uRW5kKSB7XG4gICAgdmFyIHJlZjE7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgIHJlZjEgPSBbb3B0aW9ucywgb25EYXRhXSwgb25EYXRhID0gcmVmMVswXSwgb25FbmQgPSByZWYxWzFdO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob25EYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTERvY3VtZW50Q0Iob3B0aW9ucywgb25EYXRhLCBvbkVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgWE1MRG9jdW1lbnQob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLnN0cmluZ1dyaXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFhNTFN0cmluZ1dyaXRlcihvcHRpb25zKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5zdHJlYW1Xcml0ZXIgPSBmdW5jdGlvbihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFhNTFN0cmVhbVdyaXRlcihzdHJlYW0sIG9wdGlvbnMpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRncmFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRvbWFpblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0aW1lcnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsImNvbnN0IER5bmFtb0RCID0gcmVxdWlyZShcImF3cy1zZGsvY2xpZW50cy9keW5hbW9kYlwiKVxuY29uc3QgeyBSRUdJT04sIEFETUlOU19UQUJMRSB9ID0gcHJvY2Vzcy5lbnY7XG5jb25zdCBkb2NDbGllbnQgPSBuZXcgRHluYW1vREIuRG9jdW1lbnRDbGllbnQoeyByZWdpb246IFJFR0lPTiB9KVxuXG5leHBvcnRzLmhhbmRsZXIgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgY29uc3QgYWNjb3VudElkID0gZXZlbnQucmVxdWVzdENvbnRleHQuYXV0aG9yaXplci5pZFxuXG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBUYWJsZU5hbWU6IEFETUlOU19UQUJMRSxcbiAgICBFeGNsdXNpdmVTdGFydEtleTogdW5kZWZpbmVkLFxuICAgIEZpbHRlckV4cHJlc3Npb246IGBpZCA9IDppZGAsXG4gICAgUHJvamVjdGlvbkV4cHJlc3Npb246IFwiZW1haWwsIGlkLCAjbiwgY29tbWVyY2lhbF9uYW1lLCBwaG9uZV9udW1iZXIsIGlzX2VtYWlsX3ZlcmlmaWVkLCBvcmlnaW5hbF9wcm9maWxlX3Bob3RvLCBpbWFnZV9wb3NpdGlvbiwgaW1hZ2Vfem9vbSwgaW1hZ2Vfcm90YXRlXCIsXG4gICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgXCI6aWRcIjogYWNjb3VudElkIFxuICAgIH0sXG4gICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgICBcIiNuXCI6IFwibmFtZVwiXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGRvY0NsaWVudC5zY2FuKHBhcmFtcykucHJvbWlzZSgpXG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaXRlbXMuSXRlbXMpLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIiwgLy8gUmVxdWlyZWQgZm9yIENPUlMgc3VwcG9ydCB0byB3b3JrXG4gICAgICB9LFxuICAgICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzQ29kZSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZTogXCJFcnJvIGRlc2NvbmhlY2lkbywgdGVudGUgbm92YW1lbnRlLlwiIH0pLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIiwgLy8gUmVxdWlyZWQgZm9yIENPUlMgc3VwcG9ydCB0byB3b3JrXG4gICAgICB9LFxuICAgICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZSxcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=